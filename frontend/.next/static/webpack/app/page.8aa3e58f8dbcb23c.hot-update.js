"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory\n            const marketAddresses = await factory.getMarkets();\n            // Fetch MarketCreated events to get creation transaction hashes and creator addresses\n            const creationTxMap = new Map();\n            const creatorMap = new Map();\n            try {\n                // Query MarketCreated events from the factory contract\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        eventTopic\n                    ]\n                };\n                const events = await provider.getLogs(filter);\n                // Parse events\n                for (const log of events){\n                    try {\n                        // Decode the event (market address is the first indexed parameter, creator is second)\n                        const decoded = factory.interface.parseLog({\n                            topics: log.topics,\n                            data: log.data\n                        });\n                        if (decoded && decoded.args && decoded.args.market) {\n                            const marketAddress = decoded.args.market.toLowerCase();\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            // Extract creator address (second indexed parameter)\n                            if (decoded.args.creator) {\n                                creatorMap.set(marketAddress, decoded.args.creator);\n                            }\n                        }\n                    } catch (parseErr) {\n                        // Try alternative parsing - market address might be in topics[1], creator in topics[2]\n                        if (log.topics && log.topics.length > 2) {\n                            const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                            const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26));\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            creatorMap.set(marketAddress, creatorAddress);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" markets in backend metadata\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market\n            const marketPromises = marketAddresses.map(async (address)=>{\n                const marketContract = getMarketContract(address, provider);\n                try {\n                    var _marketAddresses_;\n                    const [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                        marketContract.getCurrentPrice(),\n                        marketContract.lockPrice(),\n                        marketContract.state(),\n                        marketContract.totalYes(),\n                        marketContract.totalNo(),\n                        marketContract.feedId()\n                    ]);\n                    // Fetch question from contract separately (with error handling)\n                    let question = \"\";\n                    try {\n                        question = await marketContract.question();\n                    } catch (err) {\n                        console.warn(\"Failed to fetch question for market \".concat(address, \":\"), err);\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes)\n                    const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_6__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    const feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_7__.hexlify(feedId);\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    const creatorAddress = creatorMap.get(addressLower);\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(currentPrice),\n                        lockPrice: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(lockPrice),\n                        state: Number(state),\n                        totalYes: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(totalYes),\n                        totalNo: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(totalNo),\n                        // Use question from contract first, fallback to backend metadata\n                        question: question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question),\n                        category: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress\n                    };\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least the question from contract if other calls fail\n                    let question = \"\";\n                    try {\n                        question = await marketContract.question();\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch question for market \".concat(address));\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // Filter out markets with empty addresses (failed fetches)\n            const validMarkets = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\");\n            console.log(\"[useMarkets] Valid markets after filtering: \".concat(validMarkets.length));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const marketContract = getMarketContract(marketAddress, provider);\n            const [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                marketContract.getCurrentPrice(),\n                marketContract.lockPrice(),\n                marketContract.state(),\n                marketContract.totalYes(),\n                marketContract.totalNo(),\n                marketContract.feedId()\n            ]);\n            // Fetch question from contract\n            let question = \"\";\n            try {\n                question = await marketContract.question();\n            } catch (err) {\n                console.warn(\"Failed to fetch question for market \".concat(marketAddress, \":\"), err);\n            }\n            const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_6__.toUtf8String(feedId).replace(/\\0/g, \"\");\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_7__.hexlify(feedId),\n                currentPrice: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(currentPrice),\n                lockPrice: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(lockPrice),\n                state: Number(state),\n                totalYes: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(totalYes),\n                totalNo: ethers__WEBPACK_IMPORTED_MODULE_8__.formatEther(totalNo),\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF5RDtBQUNFO0FBQ2pDO0FBQytCO0FBTy9CO0FBRTFCLE1BQU1VLGFBQWFMLDJEQUFrQjtBQUVyQzs7Q0FFQyxHQUNELFNBQVNPLHVCQUF1QkMsTUFBa0I7SUFDaEQsTUFBTUMsV0FBV0MsV0FBV0YsT0FBT0MsUUFBUTtJQUMzQyxNQUFNRSxVQUFVRCxXQUFXRixPQUFPRyxPQUFPO0lBQ3pDLE1BQU1DLGlCQUFpQkgsV0FBV0U7SUFFbEMscUNBQXFDO0lBQ3JDLElBQUlFLFFBQVFEO0lBRVosMkJBQTJCO0lBQzNCLElBQUlKLE9BQU9NLEtBQUssS0FBS1gsdURBQVdBLENBQUNZLE1BQU0sRUFBRTtRQUN2Q0YsU0FBUztJQUNYO0lBRUEsK0RBQStEO0lBQy9ELElBQUlELGlCQUFpQixHQUFHO1FBQ3RCLE1BQU1JLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQ1QsVUFBVUUsV0FBV00sS0FBS0UsR0FBRyxDQUFDVixVQUFVRTtRQUNqRUUsU0FBVSxJQUFJRyxVQUFVLEtBQU0sdUNBQXVDO0lBQ3ZFO0lBRUEsT0FBT0g7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU087SUFDZCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBRzNCLCtDQUFRQSxDQUFlLEVBQUU7SUFDdkQsTUFBTSxDQUFDNEIsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDOEIsT0FBT0MsU0FBUyxHQUFHL0IsK0NBQVFBLENBQWdCO0lBRWxELE1BQU1nQyxlQUFlOUIsa0RBQVdBLENBQUM7UUFDL0IsSUFBSTtZQUNGMkIsV0FBVztZQUNYRSxTQUFTO1lBRVQsTUFBTUUsV0FBVzFCLDJEQUFXQTtZQUM1QixNQUFNMkIsVUFBVTVCLGtFQUFrQkEsQ0FBQzJCO1lBRW5DLHdDQUF3QztZQUN4QyxNQUFNRSxrQkFBNEIsTUFBTUQsUUFBUUUsVUFB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QUFXcEUsT0FBT0wsVUFBVUUsU0FBU3dFLE9BQU8sR0FDL0QsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO2dCQUNoQk4sZUFBZU8sZUFBZTtnQkFDOUJQLGVBQWVHLFNBQVM7Z0JBQ3hCSCxlQUFlakUsS0FBSztnQkFDcEJpRSxlQUFldEUsUUFBUTtnQkFDdkJzRSxlQUFlcEUsT0FBTztnQkFDdEJvRSxlQUFlSSxNQUFNO2FBQ3RCO1lBRUgsK0JBQStCO1lBQy9CLElBQUlJLFdBQVc7WUFDZixJQUFJO2dCQUNGQSxXQUFXLE1BQU1SLGVBQWVRLFFBQVE7WUFDMUMsRUFBRSxPQUFPN0IsS0FBSztnQkFDWkMsUUFBUUMsSUFBSSxDQUFDLHVDQUFxRCxPQUFkWixlQUFjLE1BQUlVO1lBQ3hFO1lBRUEsTUFBTThCLFlBQVkxRixnREFBbUIsQ0FBQ3FGLFFBQVFPLE9BQU8sQ0FBQyxPQUFPO1lBRTdEdUIsVUFBVTtnQkFDUjNFLFNBQVNVO2dCQUNUbUMsUUFBUUssYUFBYTFGLDJDQUFjLENBQUNxRjtnQkFDcENGLGNBQWNuRiwrQ0FBa0IsQ0FBQ21GO2dCQUNqQ0MsV0FBV3BGLCtDQUFrQixDQUFDb0Y7Z0JBQzlCcEUsT0FBT3dGLE9BQU94RjtnQkFDZEwsVUFBVVgsK0NBQWtCLENBQUNXO2dCQUM3QkUsU0FBU2IsK0NBQWtCLENBQUNhO2dCQUM1QjRFLFVBQVVBO1lBQ1o7UUFDRixFQUFFLE9BQU83QixLQUFVO1lBQ2pCQyxRQUFRbEMsS0FBSyxDQUFDLDJCQUEyQmlDO1lBQ3pDaEMsU0FBU2dDLElBQUlvRCxPQUFPLElBQUk7UUFDMUIsU0FBVTtZQUNSdEYsV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPO1FBQUVoQjtRQUFRZTtRQUFTRTtRQUFPc0YsU0FBU0c7SUFBWTtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlTWFya2V0cy50cz9kM2MzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBldGhlcnMsIEJyb3dzZXJQcm92aWRlciwgQ29udHJhY3QgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgbWFya2V0QXJ0aWZhY3QgZnJvbSBcIkAvYWJpL1ByZWRpY3Rpb25NYXJrZXQuanNvblwiO1xuaW1wb3J0IHtcbiAgZ2V0RmFjdG9yeUNvbnRyYWN0LFxuICBnZXRQcm92aWRlcixcbiAgTWFya2V0RGF0YSxcbiAgTWFya2V0U3RhdGUsXG4gIEZBQ1RPUllfQUREUkVTUyxcbn0gZnJvbSBcIi4uL2xpYi9jb250cmFjdHNcIjtcblxuY29uc3QgTUFSS0VUX0FCSSA9IG1hcmtldEFydGlmYWN0LmFiaTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmUgYmFzZWQgb24gbGlxdWlkaXR5IGFuZCBhY3Rpdml0eVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldDogTWFya2V0RGF0YSk6IG51bWJlciB7XG4gIGNvbnN0IHRvdGFsWWVzID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxZZXMpO1xuICBjb25zdCB0b3RhbE5vID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxObyk7XG4gIGNvbnN0IHRvdGFsTGlxdWlkaXR5ID0gdG90YWxZZXMgKyB0b3RhbE5vO1xuICBcbiAgLy8gQmFzZSBzY29yZSBmcm9tIGxpcXVpZGl0eSAodm9sdW1lKVxuICBsZXQgc2NvcmUgPSB0b3RhbExpcXVpZGl0eTtcbiAgXG4gIC8vIEJvb3N0IGZvciBhY3RpdmUgbWFya2V0c1xuICBpZiAobWFya2V0LnN0YXRlID09PSBNYXJrZXRTdGF0ZS5BY3RpdmUpIHtcbiAgICBzY29yZSAqPSAxLjI7XG4gIH1cbiAgXG4gIC8vIEJvb3N0IGZvciBtYXJrZXRzIHdpdGggYmFsYW5jZWQgbGlxdWlkaXR5IChtb3JlIGludGVyZXN0aW5nKVxuICBpZiAodG90YWxMaXF1aWRpdHkgPiAwKSB7XG4gICAgY29uc3QgYmFsYW5jZSA9IE1hdGgubWluKHRvdGFsWWVzLCB0b3RhbE5vKSAvIE1hdGgubWF4KHRvdGFsWWVzLCB0b3RhbE5vKTtcbiAgICBzY29yZSAqPSAoMSArIGJhbGFuY2UgKiAwLjMpOyAvLyBVcCB0byAzMCUgYm9vc3QgZm9yIGJhbGFuY2VkIG1hcmtldHNcbiAgfVxuICBcbiAgcmV0dXJuIHNjb3JlO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYWxsIG1hcmtldHMgZnJvbSB0aGUgZmFjdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0cygpIHtcbiAgY29uc3QgW21hcmtldHMsIHNldE1hcmtldHNdID0gdXNlU3RhdGU8TWFya2V0RGF0YVtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGZldGNoTWFya2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICBjb25zdCBmYWN0b3J5ID0gZ2V0RmFjdG9yeUNvbnRyYWN0KHByb3ZpZGVyKTtcblxuICAgICAgLy8gR2V0IGFsbCBtYXJrZXQgYWRkcmVzc2VzIGZyb20gZmFjdG9yeVxuICAgICAgY29uc3QgbWFya2V0QWRkcmVzc2VzOiBzdHJpbmdbXSA9IGF3YWl0IGZhY3RvcnkuZ2V0TWFya2V0cygpO1xuICAgICAgXG4gICAgICAvLyBGZXRjaCBNYXJrZXRDcmVhdGVkIGV2ZW50cyB0byBnZXQgY3JlYXRpb24gdHJhbnNhY3Rpb24gaGFzaGVzIGFuZCBjcmVhdG9yIGFkZHJlc3Nlc1xuICAgICAgY29uc3QgY3JlYXRpb25UeE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICBjb25zdCBjcmVhdG9yTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFF1ZXJ5IE1hcmtldENyZWF0ZWQgZXZlbnRzIGZyb20gdGhlIGZhY3RvcnkgY29udHJhY3RcbiAgICAgICAgLy8gRXZlbnQgc2lnbmF0dXJlOiBNYXJrZXRDcmVhdGVkKGFkZHJlc3MgaW5kZXhlZCBtYXJrZXQsIGFkZHJlc3MgaW5kZXhlZCBjcmVhdG9yLCBhZGRyZXNzIGluZGV4ZWQgZmVlZEFkZHJlc3MpXG4gICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBldGhlcnMuaWQoXCJNYXJrZXRDcmVhdGVkKGFkZHJlc3MsYWRkcmVzcyxhZGRyZXNzKVwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgIGFkZHJlc3M6IEZBQ1RPUllfQUREUkVTUyxcbiAgICAgICAgICB0b3BpY3M6IFtldmVudFRvcGljXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgZXZlbnRzXG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGV2ZW50cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGV2ZW50IChtYXJrZXQgYWRkcmVzcyBpcyB0aGUgZmlyc3QgaW5kZXhlZCBwYXJhbWV0ZXIsIGNyZWF0b3IgaXMgc2Vjb25kKVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IGZhY3RvcnkuaW50ZXJmYWNlLnBhcnNlTG9nKHtcbiAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzLFxuICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWQgJiYgZGVjb2RlZC5hcmdzICYmIGRlY29kZWQuYXJncy5tYXJrZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya2V0QWRkcmVzcyA9IGRlY29kZWQuYXJncy5tYXJrZXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgY3JlYXRpb25UeE1hcC5zZXQobWFya2V0QWRkcmVzcywgbG9nLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgIC8vIEV4dHJhY3QgY3JlYXRvciBhZGRyZXNzIChzZWNvbmQgaW5kZXhlZCBwYXJhbWV0ZXIpXG4gICAgICAgICAgICAgIGlmIChkZWNvZGVkLmFyZ3MuY3JlYXRvcikge1xuICAgICAgICAgICAgICAgIGNyZWF0b3JNYXAuc2V0KG1hcmtldEFkZHJlc3MsIGRlY29kZWQuYXJncy5jcmVhdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyKSB7XG4gICAgICAgICAgICAvLyBUcnkgYWx0ZXJuYXRpdmUgcGFyc2luZyAtIG1hcmtldCBhZGRyZXNzIG1pZ2h0IGJlIGluIHRvcGljc1sxXSwgY3JlYXRvciBpbiB0b3BpY3NbMl1cbiAgICAgICAgICAgIGlmIChsb2cudG9waWNzICYmIGxvZy50b3BpY3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1sxXS5zbGljZSgyNikpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGNyZWF0b3JBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1syXS5zbGljZSgyNikpO1xuICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQobWFya2V0QWRkcmVzcywgY3JlYXRvckFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBNYXJrZXRDcmVhdGVkIGV2ZW50czpcIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHttYXJrZXRBZGRyZXNzZXMubGVuZ3RofSBtYXJrZXRzIGZyb20gZmFjdG9yeTpgLCBtYXJrZXRBZGRyZXNzZXMpO1xuXG4gICAgICAvLyBGZXRjaCBtZXRhZGF0YSBmcm9tIGJhY2tlbmQgQVBJXG4gICAgICBsZXQgYmFja2VuZE1hcmtldHM6IGFueVtdID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCI7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke2FwaVVybH0vYXBpL21hcmtldHNgKTtcbiAgICAgICAgYmFja2VuZE1hcmtldHMgPSByZXNwb25zZS5kYXRhIHx8IFtdO1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kICR7YmFja2VuZE1hcmtldHMubGVuZ3RofSBtYXJrZXRzIGluIGJhY2tlbmQgbWV0YWRhdGFgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0IG1ldGFkYXRhIGZyb20gYmFja2VuZDpcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGJhY2tlbmQgbWFya2V0cyBieSBtYXJrZXRfYWRkcmVzcyAocHJpbWFyeSkgYW5kIGZlZWRJZCAoZmFsbGJhY2spIGZvciBxdWljayBsb29rdXBcbiAgICAgIGNvbnN0IGJhY2tlbmRNYXBCeUFkZHJlc3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5RmVlZElkID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgIGJhY2tlbmRNYXJrZXRzLmZvckVhY2goKG06IGFueSkgPT4ge1xuICAgICAgICAvLyBQcmltYXJ5OiBtYXRjaCBieSBtYXJrZXRfYWRkcmVzcyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKG0ubWFya2V0X2FkZHJlc3MpIHtcbiAgICAgICAgICBjb25zdCBhZGRyTG93ZXIgPSBtLm1hcmtldF9hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYmFja2VuZE1hcEJ5QWRkcmVzcy5zZXQoYWRkckxvd2VyLCBtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjazogbWF0Y2ggYnkgZmVlZElkIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5mZWVkX2lkKSB7XG4gICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBtLmZlZWRfaWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuc2V0KGZlZWRJZExvd2VyLCBtKTtcbiAgICAgICAgICAvLyBBbHNvIHRyeSB3aXRob3V0IDB4IHByZWZpeCBpZiBwcmVzZW50XG4gICAgICAgICAgaWYgKGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIuc2xpY2UoMiksIG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZldGNoIGRhdGEgZm9yIGVhY2ggbWFya2V0XG4gICAgICBjb25zdCBtYXJrZXRQcm9taXNlcyA9IG1hcmtldEFkZHJlc3Nlcy5tYXAoYXN5bmMgKGFkZHJlc3MpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2V0Q29udHJhY3QgPSBnZXRNYXJrZXRDb250cmFjdChhZGRyZXNzLCBwcm92aWRlcik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSxcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3Quc3RhdGUoKSxcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3QudG90YWxZZXMoKSxcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3QudG90YWxObygpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC5mZWVkSWQoKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZldGNoIHF1ZXN0aW9uIGZyb20gY29udHJhY3Qgc2VwYXJhdGVseSAod2l0aCBlcnJvciBoYW5kbGluZylcbiAgICAgICAgICBsZXQgcXVlc3Rpb24gPSBcIlwiO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWVzdGlvbiA9IGF3YWl0IG1hcmtldENvbnRyYWN0LnF1ZXN0aW9uKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCBxdWVzdGlvbiBmb3IgbWFya2V0ICR7YWRkcmVzc306YCwgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IGZlZWRJZCBieXRlczMyIHRvIHN0cmluZyAocmVtb3ZlIG51bGwgYnl0ZXMpXG4gICAgICAgICAgY29uc3QgZmVlZElkU3RyID0gZXRoZXJzLnRvVXRmOFN0cmluZyhmZWVkSWQpLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcbiAgICAgICAgICBjb25zdCBmZWVkSWRIZXggPSBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBtYXRjaGluZyBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAgICAgLy8gUHJpbWFyeTogbWF0Y2ggYnkgbWFya2V0IGFkZHJlc3MgKG1vc3QgcmVsaWFibGUpXG4gICAgICAgICAgY29uc3QgYWRkcmVzc0xvd2VyID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxldCBiYWNrZW5kTWFya2V0ID0gYmFja2VuZE1hcEJ5QWRkcmVzcy5nZXQoYWRkcmVzc0xvd2VyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGYWxsYmFjazogbWF0Y2ggYnkgZmVlZElkIGlmIGFkZHJlc3MgbWF0Y2ggZmFpbGVkXG4gICAgICAgICAgaWYgKCFiYWNrZW5kTWFya2V0KSB7XG4gICAgICAgICAgICBjb25zdCBmZWVkSWRMb3dlciA9IGZlZWRJZEhleC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZmVlZElkTm9QcmVmaXggPSBmZWVkSWRMb3dlci5zdGFydHNXaXRoKCcweCcpID8gZmVlZElkTG93ZXIuc2xpY2UoMikgOiBmZWVkSWRMb3dlcjtcbiAgICAgICAgICAgIGJhY2tlbmRNYXJrZXQgPSBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZExvd2VyKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkTm9QcmVmaXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZFN0ci50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjcmVhdGlvblR4SGFzaCA9IGNyZWF0aW9uVHhNYXAuZ2V0KGFkZHJlc3NMb3dlcik7XG4gICAgICAgICAgY29uc3QgY3JlYXRvckFkZHJlc3MgPSBjcmVhdG9yTWFwLmdldChhZGRyZXNzTG93ZXIpO1xuXG4gICAgICAgICAgLy8gRXh0cmFjdCBpbWFnZVVybCBmcm9tIGJhY2tlbmQgbWFya2V0IChzdXBwb3J0IGJvdGggc25ha2VfY2FzZSBhbmQgY2FtZWxDYXNlKVxuICAgICAgICAgIGNvbnN0IGltYWdlVXJsID0gYmFja2VuZE1hcmtldD8uaW1hZ2VfdXJsIHx8IGJhY2tlbmRNYXJrZXQ/LmltYWdlVXJsIHx8IG51bGw7XG4gICAgICAgICAgaWYgKGltYWdlVXJsICYmIGFkZHJlc3NMb3dlciA9PT0gbWFya2V0QWRkcmVzc2VzWzBdPy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIE1hcmtldCAke2FkZHJlc3N9IGhhcyBpbWFnZVVybDpgLCBpbWFnZVVybC5zdWJzdHJpbmcoMCwgMTAwKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbWFya2V0RGF0YTogTWFya2V0RGF0YSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgICAgIGN1cnJlbnRQcmljZTogZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSksXG4gICAgICAgICAgICBsb2NrUHJpY2U6IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpLFxuICAgICAgICAgICAgc3RhdGU6IE51bWJlcihzdGF0ZSkgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgICAgICB0b3RhbFllczogZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSxcbiAgICAgICAgICAgIHRvdGFsTm86IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSxcbiAgICAgICAgICAgIC8vIFVzZSBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0IGZpcnN0LCBmYWxsYmFjayB0byBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24gfHwgYmFja2VuZE1hcmtldD8ucXVlc3Rpb24sXG4gICAgICAgICAgICBjYXRlZ29yeTogYmFja2VuZE1hcmtldD8uY2F0ZWdvcnksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYmFja2VuZE1hcmtldD8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpbWFnZVVybDogaW1hZ2VVcmwsIC8vIFNldCBpbWFnZVVybCBleHBsaWNpdGx5XG4gICAgICAgICAgICBjcmVhdGlvblR4SGFzaDogY3JlYXRpb25UeEhhc2gsXG4gICAgICAgICAgICBjcmVhdG9yQWRkcmVzczogY3JlYXRvckFkZHJlc3MsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBtYXJrZXREYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIG1hcmtldCAke2FkZHJlc3N9OmAsIGVycik7XG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBhdCBsZWFzdCB0aGUgcXVlc3Rpb24gZnJvbSBjb250cmFjdCBpZiBvdGhlciBjYWxscyBmYWlsXG4gICAgICAgICAgbGV0IHF1ZXN0aW9uID0gXCJcIjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVlc3Rpb24gPSBhd2FpdCBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHF1ZXN0aW9uRXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmZXRjaCBxdWVzdGlvbiBmb3IgbWFya2V0ICR7YWRkcmVzc31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmV0dXJuIG1pbmltYWwgZGF0YSBpZiBjb250cmFjdCBjYWxsIGZhaWxzLCBidXQgc3RpbGwgaW5jbHVkZSB0aGUgYWRkcmVzc1xuICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBtYXJrZXRzIGFyZSBzaG93biBldmVuIGlmIHNvbWUgY2FsbHMgZmFpbFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZmVlZElkOiBcIlwiLFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIGxvY2tQcmljZTogXCIwXCIsXG4gICAgICAgICAgICBzdGF0ZTogTWFya2V0U3RhdGUuQWN0aXZlLFxuICAgICAgICAgICAgdG90YWxZZXM6IFwiMFwiLFxuICAgICAgICAgICAgdG90YWxObzogXCIwXCIsXG4gICAgICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24gfHwgYE1hcmtldCAke2FkZHJlc3Muc2xpY2UoMCwgOCl9Li4uJHthZGRyZXNzLnNsaWNlKC02KX1gLFxuICAgICAgICAgIH0gYXMgTWFya2V0RGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1hcmtldERhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChtYXJrZXRQcm9taXNlcyk7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFN1Y2Nlc3NmdWxseSBmZXRjaGVkIGRhdGEgZm9yICR7bWFya2V0RGF0YS5sZW5ndGh9IG1hcmtldHNgKTtcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIG91dCBtYXJrZXRzIHdpdGggZW1wdHkgYWRkcmVzc2VzIChmYWlsZWQgZmV0Y2hlcylcbiAgICAgIGNvbnN0IHZhbGlkTWFya2V0cyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4gbS5hZGRyZXNzICYmIG0uYWRkcmVzcyAhPT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIik7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFZhbGlkIG1hcmtldHMgYWZ0ZXIgZmlsdGVyaW5nOiAke3ZhbGlkTWFya2V0cy5sZW5ndGh9YCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZXMgYW5kIGFkZCB0byBtYXJrZXQgZGF0YVxuICAgICAgY29uc3QgbWFya2V0c1dpdGhUcmVuZGluZyA9IHZhbGlkTWFya2V0cy5tYXAobWFya2V0ID0+ICh7XG4gICAgICAgIC4uLm1hcmtldCxcbiAgICAgICAgdHJlbmRpbmdTY29yZTogY2FsY3VsYXRlVHJlbmRpbmdTY29yZShtYXJrZXQpLFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZpbmFsIG1hcmtldHMgdG8gZGlzcGxheTpgLCBtYXJrZXRzV2l0aFRyZW5kaW5nLm1hcChtID0+ICh7IFxuICAgICAgICBhZGRyZXNzOiBtLmFkZHJlc3MsIFxuICAgICAgICBxdWVzdGlvbjogbS5xdWVzdGlvbiB8fCAnTm8gcXVlc3Rpb24nLCBcbiAgICAgICAgaGFzSW1hZ2U6ICEhbS5pbWFnZVVybCxcbiAgICAgICAgaW1hZ2VVcmw6IG0uaW1hZ2VVcmwgPyBgJHttLmltYWdlVXJsLnN1YnN0cmluZygwLCA1MCl9Li4uYCA6ICdub25lJ1xuICAgICAgfSkpKTtcbiAgICAgIFxuICAgICAgc2V0TWFya2V0cyhtYXJrZXRzV2l0aFRyZW5kaW5nKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzOlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0c1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaE1hcmtldHMoKTtcbiAgfSwgW2ZldGNoTWFya2V0c10pO1xuXG4gIHJldHVybiB7IG1hcmtldHMsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldHMgfTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGZldGNoIGEgc2luZ2xlIG1hcmtldCdzIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcmtldChtYXJrZXRBZGRyZXNzOiBzdHJpbmcgfCBudWxsKSB7XG4gIGNvbnN0IFttYXJrZXQsIHNldE1hcmtldF0gPSB1c2VTdGF0ZTxNYXJrZXREYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmV0Y2hNYXJrZXQoKTtcbiAgfSwgW21hcmtldEFkZHJlc3NdKTtcblxuICBjb25zdCBmZXRjaE1hcmtldCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gZ2V0TWFya2V0Q29udHJhY3QobWFya2V0QWRkcmVzcywgcHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC5nZXRDdXJyZW50UHJpY2UoKSxcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSxcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC5zdGF0ZSgpLFxuICAgICAgICAgIG1hcmtldENvbnRyYWN0LnRvdGFsWWVzKCksXG4gICAgICAgICAgbWFya2V0Q29udHJhY3QudG90YWxObygpLFxuICAgICAgICAgIG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLFxuICAgICAgICBdKTtcblxuICAgICAgLy8gRmV0Y2ggcXVlc3Rpb24gZnJvbSBjb250cmFjdFxuICAgICAgbGV0IHF1ZXN0aW9uID0gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHF1ZXN0aW9uID0gYXdhaXQgbWFya2V0Q29udHJhY3QucXVlc3Rpb24oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCBxdWVzdGlvbiBmb3IgbWFya2V0ICR7bWFya2V0QWRkcmVzc306YCwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmVlZElkU3RyID0gZXRoZXJzLnRvVXRmOFN0cmluZyhmZWVkSWQpLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcblxuICAgICAgc2V0TWFya2V0KHtcbiAgICAgICAgYWRkcmVzczogbWFya2V0QWRkcmVzcyxcbiAgICAgICAgZmVlZElkOiBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKSxcbiAgICAgICAgY3VycmVudFByaWNlOiBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudFByaWNlKSxcbiAgICAgICAgbG9ja1ByaWNlOiBldGhlcnMuZm9ybWF0RXRoZXIobG9ja1ByaWNlKSxcbiAgICAgICAgc3RhdGU6IE51bWJlcihzdGF0ZSkgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgIHRvdGFsWWVzOiBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxZZXMpLFxuICAgICAgICB0b3RhbE5vOiBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxObyksXG4gICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldDpcIiwgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldFwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IG1hcmtldCwgbG9hZGluZywgZXJyb3IsIHJlZmV0Y2g6IGZldGNoTWFya2V0IH07XG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZXRoZXJzIiwiYXhpb3MiLCJtYXJrZXRBcnRpZmFjdCIsImdldEZhY3RvcnlDb250cmFjdCIsImdldFByb3ZpZGVyIiwiTWFya2V0U3RhdGUiLCJGQUNUT1JZX0FERFJFU1MiLCJNQVJLRVRfQUJJIiwiYWJpIiwiY2FsY3VsYXRlVHJlbmRpbmdTY29yZSIsIm1hcmtldCIsInRvdGFsWWVzIiwicGFyc2VGbG9hdCIsInRvdGFsTm8iLCJ0b3RhbExpcXVpZGl0eSIsInNjb3JlIiwic3RhdGUiLCJBY3RpdmUiLCJiYWxhbmNlIiwiTWF0aCIsIm1pbiIsIm1heCIsInVzZU1hcmtldHMiLCJtYXJrZXRzIiwic2V0TWFya2V0cyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoTWFya2V0cyIsInByb3ZpZGVyIiwiZmFjdG9yeSIsIm1hcmtldEFkZHJlc3NlcyIsImdldE1hcmtldHMiLCJjcmVhdGlvblR4TWFwIiwiTWFwIiwiY3JlYXRvck1hcCIsImV2ZW50VG9waWMiLCJpZCIsImZpbHRlciIsImFkZHJlc3MiLCJ0b3BpY3MiLCJldmVudHMiLCJnZXRMb2dzIiwibG9nIiwiZGVjb2RlZCIsImludGVyZmFjZSIsInBhcnNlTG9nIiwiZGF0YSIsImFyZ3MiLCJtYXJrZXRBZGRyZXNzIiwidG9Mb3dlckNhc2UiLCJzZXQiLCJ0cmFuc2FjdGlvbkhhc2giLCJjcmVhdG9yIiwicGFyc2VFcnIiLCJsZW5ndGgiLCJnZXRBZGRyZXNzIiwic2xpY2UiLCJjcmVhdG9yQWRkcmVzcyIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwiYmFja2VuZE1hcmtldHMiLCJhcGlVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInJlc3BvbnNlIiwiZ2V0IiwiYmFja2VuZE1hcEJ5QWRkcmVzcyIsImJhY2tlbmRNYXBCeUZlZWRJZCIsImZvckVhY2giLCJtIiwibWFya2V0X2FkZHJlc3MiLCJhZGRyTG93ZXIiLCJmZWVkX2lkIiwiZmVlZElkTG93ZXIiLCJzdGFydHNXaXRoIiwibWFya2V0UHJvbWlzZXMiLCJtYXAiLCJtYXJrZXRDb250cmFjdCIsImdldE1hcmtldENvbnRyYWN0IiwiY3VycmVudFByaWNlIiwibG9ja1ByaWNlIiwiZmVlZElkIiwiUHJvbWlzZSIsImFsbCIsImdldEN1cnJlbnRQcmljZSIsInF1ZXN0aW9uIiwiZmVlZElkU3RyIiwidG9VdGY4U3RyaW5nIiwicmVwbGFjZSIsImZlZWRJZEhleCIsImhleGxpZnkiLCJhZGRyZXNzTG93ZXIiLCJiYWNrZW5kTWFya2V0IiwiZmVlZElkTm9QcmVmaXgiLCJjcmVhdGlvblR4SGFzaCIsImltYWdlVXJsIiwiaW1hZ2VfdXJsIiwic3Vic3RyaW5nIiwibWFya2V0RGF0YSIsImZvcm1hdEV0aGVyIiwiTnVtYmVyIiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsInF1ZXN0aW9uRXJyIiwidmFsaWRNYXJrZXRzIiwibWFya2V0c1dpdGhUcmVuZGluZyIsInRyZW5kaW5nU2NvcmUiLCJoYXNJbWFnZSIsIm1lc3NhZ2UiLCJyZWZldGNoIiwidXNlTWFya2V0Iiwic2V0TWFya2V0IiwiZmV0Y2hNYXJrZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});