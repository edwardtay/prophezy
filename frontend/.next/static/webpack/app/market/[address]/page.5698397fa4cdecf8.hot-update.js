"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/market/[address]/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory (ONLY on-chain markets - no mocks)\n            const marketAddresses = await factory.getMarkets();\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" on-chain markets from factory contract\"));\n            // Fetch MarketCreated events to get creation transaction hashes and creator addresses\n            const creationTxMap = new Map();\n            const creatorMap = new Map();\n            try {\n                // Query MarketCreated events from the factory contract\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        eventTopic\n                    ]\n                };\n                const events = await provider.getLogs(filter);\n                console.log(\"[useMarkets] Found \".concat(events.length, \" MarketCreated events\"));\n                // Parse events\n                for (const log of events){\n                    try {\n                        // Get transaction to find sender (creator)\n                        let txSender = null;\n                        try {\n                            const tx = await provider.getTransaction(log.transactionHash);\n                            if (tx && tx.from) {\n                                txSender = tx.from.toLowerCase();\n                            }\n                        } catch (txErr) {\n                            console.warn(\"Failed to get transaction \".concat(log.transactionHash, \":\"), txErr);\n                        }\n                        // Try to decode using factory interface\n                        let decoded = null;\n                        try {\n                            decoded = factory.interface.parseLog({\n                                topics: log.topics,\n                                data: log.data\n                            });\n                        } catch (parseErr) {\n                            // Try alternative parsing - extract from topics directly\n                            if (log.topics && log.topics.length >= 3) {\n                                // topics[0] = event signature\n                                // topics[1] = market address (first indexed param)\n                                // topics[2] = creator address (second indexed param)\n                                const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                                const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26));\n                                creationTxMap.set(marketAddress, log.transactionHash);\n                                creatorMap.set(marketAddress, creatorAddress);\n                                console.log(\"[useMarkets] Extracted creator from topics: \".concat(creatorAddress, \" for market \").concat(marketAddress));\n                                continue;\n                            }\n                        }\n                        // If decoded successfully\n                        if (decoded && decoded.args) {\n                            var _decoded_args_market, _decoded_args_;\n                            const marketAddress = ((_decoded_args_market = decoded.args.market) === null || _decoded_args_market === void 0 ? void 0 : _decoded_args_market.toLowerCase()) || ((_decoded_args_ = decoded.args[0]) === null || _decoded_args_ === void 0 ? void 0 : _decoded_args_.toLowerCase());\n                            if (marketAddress) {\n                                var _decoded_args_creator, _decoded_args_1;\n                                creationTxMap.set(marketAddress, log.transactionHash);\n                                // Try multiple ways to get creator\n                                const creatorAddress = ((_decoded_args_creator = decoded.args.creator) === null || _decoded_args_creator === void 0 ? void 0 : _decoded_args_creator.toLowerCase()) || ((_decoded_args_1 = decoded.args[1]) === null || _decoded_args_1 === void 0 ? void 0 : _decoded_args_1.toLowerCase()) || txSender;\n                                if (creatorAddress) {\n                                    creatorMap.set(marketAddress, creatorAddress);\n                                    console.log(\"[useMarkets] Extracted creator: \".concat(creatorAddress, \" for market \").concat(marketAddress));\n                                } else {\n                                    console.warn(\"[useMarkets] Could not extract creator for market \".concat(marketAddress));\n                                }\n                            }\n                        } else if (txSender && log.topics && log.topics.length >= 2) {\n                            // Fallback: use transaction sender as creator\n                            const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            creatorMap.set(marketAddress, txSender);\n                            console.log(\"[useMarkets] Using tx sender as creator: \".concat(txSender, \" for market \").concat(marketAddress));\n                        }\n                    } catch (parseErr) {\n                        console.error(\"[useMarkets] Error parsing event log:\", parseErr);\n                    }\n                }\n                console.log(\"[useMarkets] Creator map size: \".concat(creatorMap.size, \", Creation tx map size: \").concat(creationTxMap.size));\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API (ONLY for enriching on-chain markets with metadata - not for displaying)\n            // Backend markets are matched to on-chain markets by market_address\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" backend metadata entries (for enrichment only, not displayed separately)\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market using new ABI\n            const marketPromises = marketAddresses.map(async (address)=>{\n                // Use BrowserProvider and Contract directly with new ABI\n                let providerForContract;\n                if ( true && window.ethereum) {\n                    providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n                } else {\n                    providerForContract = provider;\n                }\n                const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                try {\n                    var _marketAddresses_;\n                    // Use new ABI methods: question, deadline, resolved, outcome\n                    const [question, deadline, resolved, outcome] = await Promise.all([\n                        marketContract.question(),\n                        marketContract.deadline(),\n                        marketContract.resolved(),\n                        marketContract.outcome()\n                    ]);\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    let currentPrice = 0n;\n                    let lockPrice = 0n;\n                    let totalYes = 0n;\n                    let totalNo = 0n;\n                    let feedId = \"0x0\";\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    // Wrap each call in a promise that catches errors\n                    const safeCall = async (fn, defaultValue)=>{\n                        try {\n                            return await fn();\n                        } catch (e) {\n                            return defaultValue;\n                        }\n                    };\n                    try {\n                        [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                            safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                            safeCall(()=>marketContract.lockPrice(), 0n),\n                            safeCall(()=>marketContract.state(), 0),\n                            safeCall(()=>marketContract.totalYes(), 0n),\n                            safeCall(()=>marketContract.totalNo(), 0n),\n                            safeCall(()=>marketContract.feedId(), \"0x0\")\n                        ]);\n                    } catch (err) {\n                        // If methods don't exist, defaults are already set above\n                        console.warn(\"Some optional methods not available for market \".concat(address, \", using defaults\"));\n                    }\n                    // Map resolved/outcome to MarketState\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    } else {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes) if it's a bytes32\n                    let feedIdStr = \"\";\n                    let feedIdHex = \"0x0\";\n                    if (feedId && feedId !== \"0x0\") {\n                        try {\n                            feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                            feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        } catch (e) {\n                            feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        }\n                    }\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    // Get creator from event map first, fallback to backend creator_address\n                    let creatorAddress = creatorMap.get(addressLower);\n                    // Fallback 1: Use backend creator_address\n                    if (!creatorAddress && (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.creator_address)) {\n                        creatorAddress = backendMarket.creator_address.toLowerCase();\n                        console.log(\"[useMarkets] Using creator from backend: \".concat(creatorAddress, \" for market \").concat(address));\n                    }\n                    // Fallback 2: If we have creationTxHash but no creator, fetch from transaction\n                    if (!creatorAddress && creationTxHash) {\n                        try {\n                            const tx = await provider.getTransaction(creationTxHash);\n                            if (tx && tx.from) {\n                                creatorAddress = tx.from.toLowerCase();\n                                creatorMap.set(addressLower, creatorAddress); // Cache it\n                                console.log(\"[useMarkets] Fetched creator from transaction: \".concat(creatorAddress, \" for market \").concat(address));\n                            }\n                        } catch (txErr) {\n                            console.warn(\"[useMarkets] Failed to fetch creator from tx \".concat(creationTxHash, \":\"), txErr);\n                        }\n                    }\n                    // Fallback 3: Try to find creation transaction by searching for MarketCreated events for this specific market\n                    if (!creatorAddress) {\n                        try {\n                            // Query events filtered by this specific market address\n                            const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                            const marketTopic = ethers__WEBPACK_IMPORTED_MODULE_9__.zeroPadValue(address, 32); // Pad address to 32 bytes for topic\n                            const filter = {\n                                address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                                topics: [\n                                    eventTopic,\n                                    marketTopic\n                                ]\n                            };\n                            const marketEvents = await provider.getLogs(filter);\n                            if (marketEvents.length > 0) {\n                                const log = marketEvents[0];\n                                // Extract creator from topics[2]\n                                if (log.topics && log.topics.length >= 3) {\n                                    creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26)).toLowerCase();\n                                    creatorMap.set(addressLower, creatorAddress);\n                                    console.log(\"[useMarkets] Found creator from market-specific event: \".concat(creatorAddress, \" for market \").concat(address));\n                                }\n                            }\n                        } catch (eventErr) {\n                            console.warn(\"[useMarkets] Failed to fetch creator from events for market \".concat(address, \":\"), eventErr);\n                        }\n                    }\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    // Ensure we always have a question - prioritize contract, then backend, then fallback\n                    const displayQuestion = question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question) || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6));\n                    // Category: use backend if available, otherwise try to infer or use \"Other\"\n                    const displayCategory = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category) || \"Other\";\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                        lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                        state: state,\n                        totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                        totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                        // Use question from contract first (most reliable), fallback to backend, then generic\n                        question: displayQuestion,\n                        category: displayCategory,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress,\n                        createdAt: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.created_at) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.createdAt),\n                        // Include backend market_id for API calls (MarketInfo, MarketChat)\n                        marketId: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.market_id) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.id) || undefined\n                    };\n                    // Log if market is missing backend metadata\n                    if (!backendMarket) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" is on-chain but missing backend metadata. Using contract data only.\"));\n                    }\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least basic data using new ABI if other calls fail\n                    let question = \"\";\n                    let deadline = 0;\n                    let resolved = false;\n                    let outcome = 0n;\n                    try {\n                        const basicContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                        [question, deadline, resolved, outcome] = await Promise.all([\n                            basicContract.question(),\n                            basicContract.deadline(),\n                            basicContract.resolved(),\n                            basicContract.outcome()\n                        ]);\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch basic data for market \".concat(address, \":\"), questionErr);\n                    }\n                    // Determine state from resolved/deadline\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (deadline > 0 && deadline <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: state,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // Batch fetch creators for markets that are still missing them\n            const marketsNeedingCreators = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.creatorAddress);\n            if (marketsNeedingCreators.length > 0) {\n                console.log(\"[useMarkets] \".concat(marketsNeedingCreators.length, \" markets missing creators, attempting to fetch...\"));\n                // Try to fetch creators from their creation transactions in parallel\n                await Promise.all(marketsNeedingCreators.map(async (market)=>{\n                    const addressLower = market.address.toLowerCase();\n                    // Try to find MarketCreated event for this specific market\n                    try {\n                        const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                        const marketTopic = ethers__WEBPACK_IMPORTED_MODULE_9__.zeroPadValue(market.address, 32);\n                        const filter = {\n                            address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                            topics: [\n                                eventTopic,\n                                marketTopic\n                            ]\n                        };\n                        const events = await provider.getLogs(filter);\n                        if (events.length > 0) {\n                            const log = events[0];\n                            if (log.topics && log.topics.length >= 3) {\n                                const creator = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26)).toLowerCase();\n                                market.creatorAddress = creator;\n                                creatorMap.set(addressLower, creator);\n                                console.log(\"[useMarkets] Found creator for \".concat(market.address, \": \").concat(creator));\n                            }\n                        }\n                    } catch (err) {\n                        console.warn(\"[useMarkets] Could not fetch creator for \".concat(market.address, \":\"), err);\n                    }\n                }));\n            }\n            // Auto-sync: Create backend entries for on-chain markets missing backend metadata\n            // This ensures all markets have complete data\n            const marketsNeedingBackendSync = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.marketId && // No backend ID means no backend entry\n                m.question && // Has question from contract\n                m.question !== \"Market \".concat(m.address.slice(0, 8), \"...\").concat(m.address.slice(-6)) // Not just fallback\n            );\n            if (marketsNeedingBackendSync.length > 0) {\n                console.log(\"[useMarkets] \".concat(marketsNeedingBackendSync.length, \" on-chain markets missing backend metadata. Auto-syncing...\"));\n                // Try to create backend entries for these markets (non-blocking)\n                Promise.all(marketsNeedingBackendSync.map(async (market)=>{\n                    try {\n                        const apiUrl = \"http://localhost:3001\" || 0;\n                        // Check if backend entry already exists\n                        const backendMarkets = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                        const exists = backendMarkets.data.some((m)=>{\n                            var _m_market_address;\n                            return ((_m_market_address = m.market_address) === null || _m_market_address === void 0 ? void 0 : _m_market_address.toLowerCase()) === market.address.toLowerCase();\n                        });\n                        if (!exists && market.question && market.creatorAddress) {\n                            // Create backend entry with contract data\n                            await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].post(\"\".concat(apiUrl, \"/api/markets\"), {\n                                question: market.question,\n                                category: market.category || \"Other\",\n                                duration: 7 * 24 * 60 * 60,\n                                resolutionDelay: 24 * 60 * 60,\n                                imageUrl: market.imageUrl || null,\n                                oracleType: \"chainlink\",\n                                creatorAddress: market.creatorAddress,\n                                marketAddress: market.address\n                            });\n                            console.log(\"[useMarkets] Auto-created backend entry for market \".concat(market.address));\n                        }\n                    } catch (err) {\n                        // Silently fail - this is just a sync attempt\n                        console.debug(\"[useMarkets] Could not auto-sync market \".concat(market.address, \":\"), err);\n                    }\n                })).catch(()=>{\n                // Ignore errors - this is best effort\n                });\n            }\n            // Filter out markets with empty/invalid addresses - only show real on-chain markets\n            const validMarkets = marketData.filter((m)=>{\n                // Must have a valid address\n                if (!m.address || m.address === \"0x0000000000000000000000000000000000000000\") {\n                    return false;\n                }\n                // Must be a valid Ethereum address format\n                if (!/^0x[a-fA-F0-9]{40}$/.test(m.address)) {\n                    return false;\n                }\n                // Must have been fetched from factory (exists in marketAddresses)\n                return true;\n            });\n            const marketsWithCreators = validMarkets.filter((m)=>m.creatorAddress).length;\n            console.log(\"[useMarkets] Valid on-chain markets: \".concat(validMarkets.length, \", Markets with creators: \").concat(marketsWithCreators));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            // Use BrowserProvider and Contract directly with new ABI\n            let providerForContract;\n            if ( true && window.ethereum) {\n                providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n            } else {\n                const baseProvider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n                providerForContract = baseProvider;\n            }\n            const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(marketAddress, MARKET_ABI, providerForContract);\n            // Use new ABI methods: question, deadline, resolved, outcome\n            const [question, deadline, resolved, outcome] = await Promise.all([\n                marketContract.question(),\n                marketContract.deadline(),\n                marketContract.resolved(),\n                marketContract.outcome()\n            ]);\n            // Try to get additional data if methods exist (for backward compatibility)\n            let currentPrice = 0n;\n            let lockPrice = 0n;\n            let totalYes = 0n;\n            let totalNo = 0n;\n            let feedId = \"0x0\";\n            let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            // Try to get additional data if methods exist (for backward compatibility)\n            // Wrap each call in a promise that catches errors\n            const safeCall = async (fn, defaultValue)=>{\n                try {\n                    return await fn();\n                } catch (e) {\n                    return defaultValue;\n                }\n            };\n            try {\n                [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                    safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                    safeCall(()=>marketContract.lockPrice(), 0n),\n                    safeCall(()=>marketContract.state(), 0),\n                    safeCall(()=>marketContract.totalYes(), 0n),\n                    safeCall(()=>marketContract.totalNo(), 0n),\n                    safeCall(()=>marketContract.feedId(), \"0x0\")\n                ]);\n            } catch (err) {\n                // If methods don't exist, defaults are already set above\n                console.warn(\"Some optional methods not available for market \".concat(marketAddress, \", using defaults\"));\n            }\n            // Map resolved/outcome to MarketState\n            if (resolved) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n            } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n            } else {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            }\n            // Convert feedId bytes32 to string if available\n            let feedIdStr = \"\";\n            let feedIdHex = \"0x0\";\n            if (feedId && feedId !== \"0x0\") {\n                try {\n                    feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                } catch (e) {\n                    feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                }\n            }\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdHex,\n                currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                state: state,\n                totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0U7QUFDakM7QUFDK0I7QUFPL0I7QUFFMUIsTUFBTVksYUFBYUwsMkRBQWtCO0FBRXJDOztDQUVDLEdBQ0QsU0FBU08sdUJBQXVCQyxNQUFrQjtJQUNoRCxNQUFNQyxXQUFXQyxXQUFXRixPQUFPQyxRQUFRO0lBQzNDLE1BQU1FLFVBQVVELFdBQVdGLE9BQU9HLE9BQU87SUFDekMsTUFBTUMsaUJBQWlCSCxXQUFXRTtJQUVsQyxxQ0FBcUM7SUFDckMsSUFBSUUsUUFBUUQ7SUFFWiwyQkFBMkI7SUFDM0IsSUFBSUosT0FBT00sS0FBSyxLQUFLWCx1REFBV0EsQ0FBQ1ksTUFBTSxFQUFFO1FBQ3ZDRixTQUFTO0lBQ1g7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTUksVUFBVUMsS0FBS0MsR0FBRyxDQUFDVCxVQUFVRSxXQUFXTSxLQUFLRSxHQUFHLENBQUNWLFVBQVVFO1FBQ2pFRSxTQUFVLElBQUlHLFVBQVUsS0FBTSx1Q0FBdUM7SUFDdkU7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTTztJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQWUsRUFBRTtJQUN2RCxNQUFNLENBQUM4QixTQUFTQyxXQUFXLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWtDLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQixJQUFJO1lBQ0Y2QixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxNQUFNRSxXQUFXMUIsMkRBQVdBO1lBQzVCLE1BQU0yQixVQUFVNUIsa0VBQWtCQSxDQUFDMkI7WUFFbkMsMkVBQTJFO1lBQzNFLE1BQU1FLGtCQUE0QixNQUFNRCxRQUFRRSxV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bEMsUUFBUVAsS0FBSyxDQUFDLDJCQUEyQnlDO1lBQ3pDeEMsU0FBU3dDLElBQUl3RixPQUFPLElBQUk7UUFDMUIsU0FBVTtZQUNSbEksV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPO1FBQUVoQjtRQUFRZTtRQUFTRTtRQUFPa0ksU0FBU0c7SUFBWTtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlTWFya2V0cy50cz9kM2MzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBldGhlcnMsIEJyb3dzZXJQcm92aWRlciwgQ29udHJhY3QgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgbWFya2V0QXJ0aWZhY3QgZnJvbSBcIkAvYWJpL1ByZWRpY3Rpb25NYXJrZXQuanNvblwiO1xuaW1wb3J0IHtcbiAgZ2V0RmFjdG9yeUNvbnRyYWN0LFxuICBnZXRQcm92aWRlcixcbiAgTWFya2V0RGF0YSxcbiAgTWFya2V0U3RhdGUsXG4gIEZBQ1RPUllfQUREUkVTUyxcbn0gZnJvbSBcIi4uL2xpYi9jb250cmFjdHNcIjtcblxuY29uc3QgTUFSS0VUX0FCSSA9IG1hcmtldEFydGlmYWN0LmFiaTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmUgYmFzZWQgb24gbGlxdWlkaXR5IGFuZCBhY3Rpdml0eVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldDogTWFya2V0RGF0YSk6IG51bWJlciB7XG4gIGNvbnN0IHRvdGFsWWVzID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxZZXMpO1xuICBjb25zdCB0b3RhbE5vID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxObyk7XG4gIGNvbnN0IHRvdGFsTGlxdWlkaXR5ID0gdG90YWxZZXMgKyB0b3RhbE5vO1xuICBcbiAgLy8gQmFzZSBzY29yZSBmcm9tIGxpcXVpZGl0eSAodm9sdW1lKVxuICBsZXQgc2NvcmUgPSB0b3RhbExpcXVpZGl0eTtcbiAgXG4gIC8vIEJvb3N0IGZvciBhY3RpdmUgbWFya2V0c1xuICBpZiAobWFya2V0LnN0YXRlID09PSBNYXJrZXRTdGF0ZS5BY3RpdmUpIHtcbiAgICBzY29yZSAqPSAxLjI7XG4gIH1cbiAgXG4gIC8vIEJvb3N0IGZvciBtYXJrZXRzIHdpdGggYmFsYW5jZWQgbGlxdWlkaXR5IChtb3JlIGludGVyZXN0aW5nKVxuICBpZiAodG90YWxMaXF1aWRpdHkgPiAwKSB7XG4gICAgY29uc3QgYmFsYW5jZSA9IE1hdGgubWluKHRvdGFsWWVzLCB0b3RhbE5vKSAvIE1hdGgubWF4KHRvdGFsWWVzLCB0b3RhbE5vKTtcbiAgICBzY29yZSAqPSAoMSArIGJhbGFuY2UgKiAwLjMpOyAvLyBVcCB0byAzMCUgYm9vc3QgZm9yIGJhbGFuY2VkIG1hcmtldHNcbiAgfVxuICBcbiAgcmV0dXJuIHNjb3JlO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYWxsIG1hcmtldHMgZnJvbSB0aGUgZmFjdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0cygpIHtcbiAgY29uc3QgW21hcmtldHMsIHNldE1hcmtldHNdID0gdXNlU3RhdGU8TWFya2V0RGF0YVtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGZldGNoTWFya2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICBjb25zdCBmYWN0b3J5ID0gZ2V0RmFjdG9yeUNvbnRyYWN0KHByb3ZpZGVyKTtcblxuICAgICAgLy8gR2V0IGFsbCBtYXJrZXQgYWRkcmVzc2VzIGZyb20gZmFjdG9yeSAoT05MWSBvbi1jaGFpbiBtYXJrZXRzIC0gbm8gbW9ja3MpXG4gICAgICBjb25zdCBtYXJrZXRBZGRyZXNzZXM6IHN0cmluZ1tdID0gYXdhaXQgZmFjdG9yeS5nZXRNYXJrZXRzKCk7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kICR7bWFya2V0QWRkcmVzc2VzLmxlbmd0aH0gb24tY2hhaW4gbWFya2V0cyBmcm9tIGZhY3RvcnkgY29udHJhY3RgKTtcbiAgICAgIFxuICAgICAgLy8gRmV0Y2ggTWFya2V0Q3JlYXRlZCBldmVudHMgdG8gZ2V0IGNyZWF0aW9uIHRyYW5zYWN0aW9uIGhhc2hlcyBhbmQgY3JlYXRvciBhZGRyZXNzZXNcbiAgICAgIGNvbnN0IGNyZWF0aW9uVHhNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgY29uc3QgY3JlYXRvck1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBRdWVyeSBNYXJrZXRDcmVhdGVkIGV2ZW50cyBmcm9tIHRoZSBmYWN0b3J5IGNvbnRyYWN0XG4gICAgICAgIC8vIEV2ZW50IHNpZ25hdHVyZTogTWFya2V0Q3JlYXRlZChhZGRyZXNzIGluZGV4ZWQgbWFya2V0LCBhZGRyZXNzIGluZGV4ZWQgY3JlYXRvciwgYWRkcmVzcyBpbmRleGVkIGZlZWRBZGRyZXNzKVxuICAgICAgICBjb25zdCBldmVudFRvcGljID0gZXRoZXJzLmlkKFwiTWFya2V0Q3JlYXRlZChhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcylcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICBhZGRyZXNzOiBGQUNUT1JZX0FERFJFU1MsXG4gICAgICAgICAgdG9waWNzOiBbZXZlbnRUb3BpY10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHtldmVudHMubGVuZ3RofSBNYXJrZXRDcmVhdGVkIGV2ZW50c2ApO1xuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgZXZlbnRzXG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGV2ZW50cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBHZXQgdHJhbnNhY3Rpb24gdG8gZmluZCBzZW5kZXIgKGNyZWF0b3IpXG4gICAgICAgICAgICBsZXQgdHhTZW5kZXI6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvbihsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgaWYgKHR4ICYmIHR4LmZyb20pIHtcbiAgICAgICAgICAgICAgICB0eFNlbmRlciA9IHR4LmZyb20udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAodHhFcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uICR7bG9nLnRyYW5zYWN0aW9uSGFzaH06YCwgdHhFcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHVzaW5nIGZhY3RvcnkgaW50ZXJmYWNlXG4gICAgICAgICAgICBsZXQgZGVjb2RlZDogYW55ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlY29kZWQgPSBmYWN0b3J5LmludGVyZmFjZS5wYXJzZUxvZyh7XG4gICAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyKSB7XG4gICAgICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXJzaW5nIC0gZXh0cmFjdCBmcm9tIHRvcGljcyBkaXJlY3RseVxuICAgICAgICAgICAgICBpZiAobG9nLnRvcGljcyAmJiBsb2cudG9waWNzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9waWNzWzBdID0gZXZlbnQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgLy8gdG9waWNzWzFdID0gbWFya2V0IGFkZHJlc3MgKGZpcnN0IGluZGV4ZWQgcGFyYW0pXG4gICAgICAgICAgICAgICAgLy8gdG9waWNzWzJdID0gY3JlYXRvciBhZGRyZXNzIChzZWNvbmQgaW5kZXhlZCBwYXJhbSlcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1sxXS5zbGljZSgyNikpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRvckFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzJdLnNsaWNlKDI2KSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3JlYXRpb25UeE1hcC5zZXQobWFya2V0QWRkcmVzcywgbG9nLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQobWFya2V0QWRkcmVzcywgY3JlYXRvckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRXh0cmFjdGVkIGNyZWF0b3IgZnJvbSB0b3BpY3M6ICR7Y3JlYXRvckFkZHJlc3N9IGZvciBtYXJrZXQgJHttYXJrZXRBZGRyZXNzfWApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGRlY29kZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICBpZiAoZGVjb2RlZCAmJiBkZWNvZGVkLmFyZ3MpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya2V0QWRkcmVzcyA9IGRlY29kZWQuYXJncy5tYXJrZXQ/LnRvTG93ZXJDYXNlKCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWQuYXJnc1swXT8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChtYXJrZXRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRpb25UeE1hcC5zZXQobWFya2V0QWRkcmVzcywgbG9nLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVHJ5IG11bHRpcGxlIHdheXMgdG8gZ2V0IGNyZWF0b3JcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdG9yQWRkcmVzcyA9IGRlY29kZWQuYXJncy5jcmVhdG9yPy50b0xvd2VyQ2FzZSgpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkLmFyZ3NbMV0/LnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhTZW5kZXI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0b3JBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICBjcmVhdG9yTWFwLnNldChtYXJrZXRBZGRyZXNzLCBjcmVhdG9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEV4dHJhY3RlZCBjcmVhdG9yOiAke2NyZWF0b3JBZGRyZXNzfSBmb3IgbWFya2V0ICR7bWFya2V0QWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdXNlTWFya2V0c10gQ291bGQgbm90IGV4dHJhY3QgY3JlYXRvciBmb3IgbWFya2V0ICR7bWFya2V0QWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHhTZW5kZXIgJiYgbG9nLnRvcGljcyAmJiBsb2cudG9waWNzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiB1c2UgdHJhbnNhY3Rpb24gc2VuZGVyIGFzIGNyZWF0b3JcbiAgICAgICAgICAgICAgY29uc3QgbWFya2V0QWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKFwiMHhcIiArIGxvZy50b3BpY3NbMV0uc2xpY2UoMjYpKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQobWFya2V0QWRkcmVzcywgdHhTZW5kZXIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFVzaW5nIHR4IHNlbmRlciBhcyBjcmVhdG9yOiAke3R4U2VuZGVyfSBmb3IgbWFya2V0ICR7bWFya2V0QWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW3VzZU1hcmtldHNdIEVycm9yIHBhcnNpbmcgZXZlbnQgbG9nOmAsIHBhcnNlRXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gQ3JlYXRvciBtYXAgc2l6ZTogJHtjcmVhdG9yTWFwLnNpemV9LCBDcmVhdGlvbiB0eCBtYXAgc2l6ZTogJHtjcmVhdGlvblR4TWFwLnNpemV9YCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGZldGNoIE1hcmtldENyZWF0ZWQgZXZlbnRzOlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke21hcmtldEFkZHJlc3Nlcy5sZW5ndGh9IG1hcmtldHMgZnJvbSBmYWN0b3J5OmAsIG1hcmtldEFkZHJlc3Nlcyk7XG5cbiAgICAgIC8vIEZldGNoIG1ldGFkYXRhIGZyb20gYmFja2VuZCBBUEkgKE9OTFkgZm9yIGVucmljaGluZyBvbi1jaGFpbiBtYXJrZXRzIHdpdGggbWV0YWRhdGEgLSBub3QgZm9yIGRpc3BsYXlpbmcpXG4gICAgICAvLyBCYWNrZW5kIG1hcmtldHMgYXJlIG1hdGNoZWQgdG8gb24tY2hhaW4gbWFya2V0cyBieSBtYXJrZXRfYWRkcmVzc1xuICAgICAgbGV0IGJhY2tlbmRNYXJrZXRzOiBhbnlbXSA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMVwiO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHthcGlVcmx9L2FwaS9tYXJrZXRzYCk7XG4gICAgICAgIGJhY2tlbmRNYXJrZXRzID0gcmVzcG9uc2UuZGF0YSB8fCBbXTtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke2JhY2tlbmRNYXJrZXRzLmxlbmd0aH0gYmFja2VuZCBtZXRhZGF0YSBlbnRyaWVzIChmb3IgZW5yaWNobWVudCBvbmx5LCBub3QgZGlzcGxheWVkIHNlcGFyYXRlbHkpYCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldCBtZXRhZGF0YSBmcm9tIGJhY2tlbmQ6XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBiYWNrZW5kIG1hcmtldHMgYnkgbWFya2V0X2FkZHJlc3MgKHByaW1hcnkpIGFuZCBmZWVkSWQgKGZhbGxiYWNrKSBmb3IgcXVpY2sgbG9va3VwXG4gICAgICBjb25zdCBiYWNrZW5kTWFwQnlBZGRyZXNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgIGNvbnN0IGJhY2tlbmRNYXBCeUZlZWRJZCA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICBiYWNrZW5kTWFya2V0cy5mb3JFYWNoKChtOiBhbnkpID0+IHtcbiAgICAgICAgLy8gUHJpbWFyeTogbWF0Y2ggYnkgbWFya2V0X2FkZHJlc3MgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtLm1hcmtldF9hZGRyZXNzKSB7XG4gICAgICAgICAgY29uc3QgYWRkckxvd2VyID0gbS5tYXJrZXRfYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJhY2tlbmRNYXBCeUFkZHJlc3Muc2V0KGFkZHJMb3dlciwgbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2s6IG1hdGNoIGJ5IGZlZWRJZCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKG0uZmVlZF9pZCkge1xuICAgICAgICAgIGNvbnN0IGZlZWRJZExvd2VyID0gbS5mZWVkX2lkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLnNldChmZWVkSWRMb3dlciwgbSk7XG4gICAgICAgICAgLy8gQWxzbyB0cnkgd2l0aG91dCAweCBwcmVmaXggaWYgcHJlc2VudFxuICAgICAgICAgIGlmIChmZWVkSWRMb3dlci5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuc2V0KGZlZWRJZExvd2VyLnNsaWNlKDIpLCBtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGZXRjaCBkYXRhIGZvciBlYWNoIG1hcmtldCB1c2luZyBuZXcgQUJJXG4gICAgICBjb25zdCBtYXJrZXRQcm9taXNlcyA9IG1hcmtldEFkZHJlc3Nlcy5tYXAoYXN5bmMgKGFkZHJlc3MpID0+IHtcbiAgICAgICAgLy8gVXNlIEJyb3dzZXJQcm92aWRlciBhbmQgQ29udHJhY3QgZGlyZWN0bHkgd2l0aCBuZXcgQUJJXG4gICAgICAgIGxldCBwcm92aWRlckZvckNvbnRyYWN0OiBCcm93c2VyUHJvdmlkZXI7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBuZXcgQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IHByb3ZpZGVyIGFzIGFueSBhcyBCcm93c2VyUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2V0Q29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgTUFSS0VUX0FCSSwgcHJvdmlkZXJGb3JDb250cmFjdCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVc2UgbmV3IEFCSSBtZXRob2RzOiBxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXG4gICAgICAgICAgY29uc3QgW3F1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbWFya2V0Q29udHJhY3QucXVlc3Rpb24oKSxcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmRlYWRsaW5lKCksXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5yZXNvbHZlZCgpLFxuICAgICAgICAgICAgbWFya2V0Q29udHJhY3Qub3V0Y29tZSgpLCAvLyBlbnVtOiAwLDEsMlxuICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICAgICAgbGV0IGN1cnJlbnRQcmljZSA9IDBuO1xuICAgICAgICAgIGxldCBsb2NrUHJpY2UgPSAwbjtcbiAgICAgICAgICBsZXQgdG90YWxZZXMgPSAwbjtcbiAgICAgICAgICBsZXQgdG90YWxObyA9IDBuO1xuICAgICAgICAgIGxldCBmZWVkSWQgPSBcIjB4MFwiO1xuICAgICAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcblxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgYWRkaXRpb25hbCBkYXRhIGlmIG1ldGhvZHMgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgICAgIC8vIFdyYXAgZWFjaCBjYWxsIGluIGEgcHJvbWlzZSB0aGF0IGNhdGNoZXMgZXJyb3JzXG4gICAgICAgICAgY29uc3Qgc2FmZUNhbGwgPSBhc3luYyAoZm46ICgpID0+IFByb21pc2U8YW55PiwgZGVmYXVsdFZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QuZ2V0Q3VycmVudFByaWNlKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QubG9ja1ByaWNlKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3Quc3RhdGUoKSwgMCksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsWWVzKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QudG90YWxObygpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLCBcIjB4MFwiKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgbWV0aG9kcyBkb24ndCBleGlzdCwgZGVmYXVsdHMgYXJlIGFscmVhZHkgc2V0IGFib3ZlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNvbWUgb3B0aW9uYWwgbWV0aG9kcyBub3QgYXZhaWxhYmxlIGZvciBtYXJrZXQgJHthZGRyZXNzfSwgdXNpbmcgZGVmYXVsdHNgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNYXAgcmVzb2x2ZWQvb3V0Y29tZSB0byBNYXJrZXRTdGF0ZVxuICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5SZXNvbHZlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKE51bWJlcihkZWFkbGluZSkgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuTG9ja2VkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IGZlZWRJZCBieXRlczMyIHRvIHN0cmluZyAocmVtb3ZlIG51bGwgYnl0ZXMpIGlmIGl0J3MgYSBieXRlczMyXG4gICAgICAgICAgbGV0IGZlZWRJZFN0ciA9IFwiXCI7XG4gICAgICAgICAgbGV0IGZlZWRJZEhleCA9IFwiMHgwXCI7XG4gICAgICAgICAgaWYgKGZlZWRJZCAmJiBmZWVkSWQgIT09IFwiMHgwXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZlZWRJZFN0ciA9IGV0aGVycy50b1V0ZjhTdHJpbmcoZmVlZElkKS5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG4gICAgICAgICAgICAgIGZlZWRJZEhleCA9IGZlZWRJZFN0ciB8fCBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIGZlZWRJZEhleCA9IHR5cGVvZiBmZWVkSWQgPT09IFwic3RyaW5nXCIgPyBmZWVkSWQgOiBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBtYXRjaGluZyBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAgICAgLy8gUHJpbWFyeTogbWF0Y2ggYnkgbWFya2V0IGFkZHJlc3MgKG1vc3QgcmVsaWFibGUpXG4gICAgICAgICAgY29uc3QgYWRkcmVzc0xvd2VyID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxldCBiYWNrZW5kTWFya2V0ID0gYmFja2VuZE1hcEJ5QWRkcmVzcy5nZXQoYWRkcmVzc0xvd2VyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGYWxsYmFjazogbWF0Y2ggYnkgZmVlZElkIGlmIGFkZHJlc3MgbWF0Y2ggZmFpbGVkXG4gICAgICAgICAgaWYgKCFiYWNrZW5kTWFya2V0KSB7XG4gICAgICAgICAgICBjb25zdCBmZWVkSWRMb3dlciA9IGZlZWRJZEhleC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZmVlZElkTm9QcmVmaXggPSBmZWVkSWRMb3dlci5zdGFydHNXaXRoKCcweCcpID8gZmVlZElkTG93ZXIuc2xpY2UoMikgOiBmZWVkSWRMb3dlcjtcbiAgICAgICAgICAgIGJhY2tlbmRNYXJrZXQgPSBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZExvd2VyKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkTm9QcmVmaXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZFN0ci50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjcmVhdGlvblR4SGFzaCA9IGNyZWF0aW9uVHhNYXAuZ2V0KGFkZHJlc3NMb3dlcik7XG4gICAgICAgICAgLy8gR2V0IGNyZWF0b3IgZnJvbSBldmVudCBtYXAgZmlyc3QsIGZhbGxiYWNrIHRvIGJhY2tlbmQgY3JlYXRvcl9hZGRyZXNzXG4gICAgICAgICAgbGV0IGNyZWF0b3JBZGRyZXNzID0gY3JlYXRvck1hcC5nZXQoYWRkcmVzc0xvd2VyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGYWxsYmFjayAxOiBVc2UgYmFja2VuZCBjcmVhdG9yX2FkZHJlc3NcbiAgICAgICAgICBpZiAoIWNyZWF0b3JBZGRyZXNzICYmIGJhY2tlbmRNYXJrZXQ/LmNyZWF0b3JfYWRkcmVzcykge1xuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3MgPSBiYWNrZW5kTWFya2V0LmNyZWF0b3JfYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBVc2luZyBjcmVhdG9yIGZyb20gYmFja2VuZDogJHtjcmVhdG9yQWRkcmVzc30gZm9yIG1hcmtldCAke2FkZHJlc3N9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZhbGxiYWNrIDI6IElmIHdlIGhhdmUgY3JlYXRpb25UeEhhc2ggYnV0IG5vIGNyZWF0b3IsIGZldGNoIGZyb20gdHJhbnNhY3Rpb25cbiAgICAgICAgICBpZiAoIWNyZWF0b3JBZGRyZXNzICYmIGNyZWF0aW9uVHhIYXNoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGNyZWF0aW9uVHhIYXNoKTtcbiAgICAgICAgICAgICAgaWYgKHR4ICYmIHR4LmZyb20pIHtcbiAgICAgICAgICAgICAgICBjcmVhdG9yQWRkcmVzcyA9IHR4LmZyb20udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjcmVhdG9yTWFwLnNldChhZGRyZXNzTG93ZXIsIGNyZWF0b3JBZGRyZXNzKTsgLy8gQ2FjaGUgaXRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZldGNoZWQgY3JlYXRvciBmcm9tIHRyYW5zYWN0aW9uOiAke2NyZWF0b3JBZGRyZXNzfSBmb3IgbWFya2V0ICR7YWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAodHhFcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdXNlTWFya2V0c10gRmFpbGVkIHRvIGZldGNoIGNyZWF0b3IgZnJvbSB0eCAke2NyZWF0aW9uVHhIYXNofTpgLCB0eEVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZhbGxiYWNrIDM6IFRyeSB0byBmaW5kIGNyZWF0aW9uIHRyYW5zYWN0aW9uIGJ5IHNlYXJjaGluZyBmb3IgTWFya2V0Q3JlYXRlZCBldmVudHMgZm9yIHRoaXMgc3BlY2lmaWMgbWFya2V0XG4gICAgICAgICAgaWYgKCFjcmVhdG9yQWRkcmVzcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gUXVlcnkgZXZlbnRzIGZpbHRlcmVkIGJ5IHRoaXMgc3BlY2lmaWMgbWFya2V0IGFkZHJlc3NcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGV0aGVycy5pZChcIk1hcmtldENyZWF0ZWQoYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MpXCIpO1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXRUb3BpYyA9IGV0aGVycy56ZXJvUGFkVmFsdWUoYWRkcmVzcywgMzIpOyAvLyBQYWQgYWRkcmVzcyB0byAzMiBieXRlcyBmb3IgdG9waWNcbiAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IEZBQ1RPUllfQUREUkVTUyxcbiAgICAgICAgICAgICAgICB0b3BpY3M6IFtldmVudFRvcGljLCBtYXJrZXRUb3BpY10sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtldEV2ZW50cyA9IGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChtYXJrZXRFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZyA9IG1hcmtldEV2ZW50c1swXTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGNyZWF0b3IgZnJvbSB0b3BpY3NbMl1cbiAgICAgICAgICAgICAgICBpZiAobG9nLnRvcGljcyAmJiBsb2cudG9waWNzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICBjcmVhdG9yQWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKFwiMHhcIiArIGxvZy50b3BpY3NbMl0uc2xpY2UoMjYpKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQoYWRkcmVzc0xvd2VyLCBjcmVhdG9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kIGNyZWF0b3IgZnJvbSBtYXJrZXQtc3BlY2lmaWMgZXZlbnQ6ICR7Y3JlYXRvckFkZHJlc3N9IGZvciBtYXJrZXQgJHthZGRyZXNzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXZlbnRFcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdXNlTWFya2V0c10gRmFpbGVkIHRvIGZldGNoIGNyZWF0b3IgZnJvbSBldmVudHMgZm9yIG1hcmtldCAke2FkZHJlc3N9OmAsIGV2ZW50RXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IGltYWdlVXJsIGZyb20gYmFja2VuZCBtYXJrZXQgKHN1cHBvcnQgYm90aCBzbmFrZV9jYXNlIGFuZCBjYW1lbENhc2UpXG4gICAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSBiYWNrZW5kTWFya2V0Py5pbWFnZV91cmwgfHwgYmFja2VuZE1hcmtldD8uaW1hZ2VVcmwgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoaW1hZ2VVcmwgJiYgYWRkcmVzc0xvd2VyID09PSBtYXJrZXRBZGRyZXNzZXNbMF0/LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gaGFzIGltYWdlVXJsOmAsIGltYWdlVXJsLnN1YnN0cmluZygwLCAxMDApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBxdWVzdGlvbiAtIHByaW9yaXRpemUgY29udHJhY3QsIHRoZW4gYmFja2VuZCwgdGhlbiBmYWxsYmFja1xuICAgICAgICAgIGNvbnN0IGRpc3BsYXlRdWVzdGlvbiA9IHF1ZXN0aW9uIHx8IGJhY2tlbmRNYXJrZXQ/LnF1ZXN0aW9uIHx8IGBNYXJrZXQgJHthZGRyZXNzLnNsaWNlKDAsIDgpfS4uLiR7YWRkcmVzcy5zbGljZSgtNil9YDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYXRlZ29yeTogdXNlIGJhY2tlbmQgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdHJ5IHRvIGluZmVyIG9yIHVzZSBcIk90aGVyXCJcbiAgICAgICAgICBjb25zdCBkaXNwbGF5Q2F0ZWdvcnkgPSBiYWNrZW5kTWFya2V0Py5jYXRlZ29yeSB8fCBcIk90aGVyXCI7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbWFya2V0RGF0YTogTWFya2V0RGF0YSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgICAgIGN1cnJlbnRQcmljZTogY3VycmVudFByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudFByaWNlKSA6IFwiMFwiLFxuICAgICAgICAgICAgbG9ja1ByaWNlOiBsb2NrUHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpIDogXCIwXCIsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgICAgICB0b3RhbFllczogdG90YWxZZXMgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbFllcykgOiBcIjBcIixcbiAgICAgICAgICAgIHRvdGFsTm86IHRvdGFsTm8gPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSA6IFwiMFwiLFxuICAgICAgICAgICAgLy8gVXNlIHF1ZXN0aW9uIGZyb20gY29udHJhY3QgZmlyc3QgKG1vc3QgcmVsaWFibGUpLCBmYWxsYmFjayB0byBiYWNrZW5kLCB0aGVuIGdlbmVyaWNcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBkaXNwbGF5UXVlc3Rpb24sXG4gICAgICAgICAgICBjYXRlZ29yeTogZGlzcGxheUNhdGVnb3J5LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGJhY2tlbmRNYXJrZXQ/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaW1hZ2VVcmw6IGltYWdlVXJsLCAvLyBTZXQgaW1hZ2VVcmwgZXhwbGljaXRseSAoZnJvbSBiYWNrZW5kIGlmIGF2YWlsYWJsZSlcbiAgICAgICAgICAgIGNyZWF0aW9uVHhIYXNoOiBjcmVhdGlvblR4SGFzaCxcbiAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzOiBjcmVhdG9yQWRkcmVzcywgLy8gU2hvdWxkIGFsd2F5cyBiZSBzZXQgYnkgbm93IChmcm9tIGV2ZW50cyBvciBiYWNrZW5kKVxuICAgICAgICAgICAgY3JlYXRlZEF0OiBiYWNrZW5kTWFya2V0Py5jcmVhdGVkX2F0IHx8IGJhY2tlbmRNYXJrZXQ/LmNyZWF0ZWRBdCwgLy8gU3VwcG9ydCBib3RoIG5hbWluZyBjb252ZW50aW9uc1xuICAgICAgICAgICAgLy8gSW5jbHVkZSBiYWNrZW5kIG1hcmtldF9pZCBmb3IgQVBJIGNhbGxzIChNYXJrZXRJbmZvLCBNYXJrZXRDaGF0KVxuICAgICAgICAgICAgbWFya2V0SWQ6IGJhY2tlbmRNYXJrZXQ/Lm1hcmtldF9pZCB8fCBiYWNrZW5kTWFya2V0Py5pZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2cgaWYgbWFya2V0IGlzIG1pc3NpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgICAgIGlmICghYmFja2VuZE1hcmtldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBNYXJrZXQgJHthZGRyZXNzfSBpcyBvbi1jaGFpbiBidXQgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhLiBVc2luZyBjb250cmFjdCBkYXRhIG9ubHkuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1hcmtldERhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbWFya2V0ICR7YWRkcmVzc306YCwgZXJyKTtcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGF0IGxlYXN0IGJhc2ljIGRhdGEgdXNpbmcgbmV3IEFCSSBpZiBvdGhlciBjYWxscyBmYWlsXG4gICAgICAgICAgbGV0IHF1ZXN0aW9uID0gXCJcIjtcbiAgICAgICAgICBsZXQgZGVhZGxpbmUgPSAwO1xuICAgICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgIGxldCBvdXRjb21lID0gMG47XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2ljQ29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgTUFSS0VUX0FCSSwgcHJvdmlkZXJGb3JDb250cmFjdCk7XG4gICAgICAgICAgICBbcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3QucXVlc3Rpb24oKSxcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5kZWFkbGluZSgpLFxuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0LnJlc29sdmVkKCksXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3Qub3V0Y29tZSgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBjYXRjaCAocXVlc3Rpb25FcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZldGNoIGJhc2ljIGRhdGEgZm9yIG1hcmtldCAke2FkZHJlc3N9OmAsIHF1ZXN0aW9uRXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHN0YXRlIGZyb20gcmVzb2x2ZWQvZGVhZGxpbmVcbiAgICAgICAgICBsZXQgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLlJlc29sdmVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVhZGxpbmUgPiAwICYmIGRlYWRsaW5lIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkxvY2tlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmV0dXJuIG1pbmltYWwgZGF0YSBpZiBjb250cmFjdCBjYWxsIGZhaWxzLCBidXQgc3RpbGwgaW5jbHVkZSB0aGUgYWRkcmVzc1xuICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBtYXJrZXRzIGFyZSBzaG93biBldmVuIGlmIHNvbWUgY2FsbHMgZmFpbFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZmVlZElkOiBcIlwiLFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIGxvY2tQcmljZTogXCIwXCIsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICB0b3RhbFllczogXCIwXCIsXG4gICAgICAgICAgICB0b3RhbE5vOiBcIjBcIixcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbiB8fCBgTWFya2V0ICR7YWRkcmVzcy5zbGljZSgwLCA4KX0uLi4ke2FkZHJlc3Muc2xpY2UoLTYpfWAsXG4gICAgICAgICAgfSBhcyBNYXJrZXREYXRhO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWFya2V0RGF0YSA9IGF3YWl0IFByb21pc2UuYWxsKG1hcmtldFByb21pc2VzKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gU3VjY2Vzc2Z1bGx5IGZldGNoZWQgZGF0YSBmb3IgJHttYXJrZXREYXRhLmxlbmd0aH0gbWFya2V0c2ApO1xuICAgICAgXG4gICAgICAvLyBCYXRjaCBmZXRjaCBjcmVhdG9ycyBmb3IgbWFya2V0cyB0aGF0IGFyZSBzdGlsbCBtaXNzaW5nIHRoZW1cbiAgICAgIGNvbnN0IG1hcmtldHNOZWVkaW5nQ3JlYXRvcnMgPSBtYXJrZXREYXRhLmZpbHRlcihtID0+IFxuICAgICAgICBtLmFkZHJlc3MgJiYgXG4gICAgICAgIG0uYWRkcmVzcyAhPT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiAmJlxuICAgICAgICAhbS5jcmVhdG9yQWRkcmVzc1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKG1hcmtldHNOZWVkaW5nQ3JlYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdICR7bWFya2V0c05lZWRpbmdDcmVhdG9ycy5sZW5ndGh9IG1hcmtldHMgbWlzc2luZyBjcmVhdG9ycywgYXR0ZW1wdGluZyB0byBmZXRjaC4uLmApO1xuICAgICAgICAvLyBUcnkgdG8gZmV0Y2ggY3JlYXRvcnMgZnJvbSB0aGVpciBjcmVhdGlvbiB0cmFuc2FjdGlvbnMgaW4gcGFyYWxsZWxcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobWFya2V0c05lZWRpbmdDcmVhdG9ycy5tYXAoYXN5bmMgKG1hcmtldCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3NMb3dlciA9IG1hcmtldC5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgTWFya2V0Q3JlYXRlZCBldmVudCBmb3IgdGhpcyBzcGVjaWZpYyBtYXJrZXRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGV0aGVycy5pZChcIk1hcmtldENyZWF0ZWQoYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MpXCIpO1xuICAgICAgICAgICAgY29uc3QgbWFya2V0VG9waWMgPSBldGhlcnMuemVyb1BhZFZhbHVlKG1hcmtldC5hZGRyZXNzLCAzMik7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgIGFkZHJlc3M6IEZBQ1RPUllfQUREUkVTUyxcbiAgICAgICAgICAgICAgdG9waWNzOiBbZXZlbnRUb3BpYywgbWFya2V0VG9waWNdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvZyA9IGV2ZW50c1swXTtcbiAgICAgICAgICAgICAgaWYgKGxvZy50b3BpY3MgJiYgbG9nLnRvcGljcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0b3IgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzJdLnNsaWNlKDI2KSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXQuY3JlYXRvckFkZHJlc3MgPSBjcmVhdG9yO1xuICAgICAgICAgICAgICAgIGNyZWF0b3JNYXAuc2V0KGFkZHJlc3NMb3dlciwgY3JlYXRvcik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCBjcmVhdG9yIGZvciAke21hcmtldC5hZGRyZXNzfTogJHtjcmVhdG9yfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt1c2VNYXJrZXRzXSBDb3VsZCBub3QgZmV0Y2ggY3JlYXRvciBmb3IgJHttYXJrZXQuYWRkcmVzc306YCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXV0by1zeW5jOiBDcmVhdGUgYmFja2VuZCBlbnRyaWVzIGZvciBvbi1jaGFpbiBtYXJrZXRzIG1pc3NpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgLy8gVGhpcyBlbnN1cmVzIGFsbCBtYXJrZXRzIGhhdmUgY29tcGxldGUgZGF0YVxuICAgICAgY29uc3QgbWFya2V0c05lZWRpbmdCYWNrZW5kU3luYyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4gXG4gICAgICAgIG0uYWRkcmVzcyAmJiBcbiAgICAgICAgbS5hZGRyZXNzICE9PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiICYmXG4gICAgICAgICFtLm1hcmtldElkICYmIC8vIE5vIGJhY2tlbmQgSUQgbWVhbnMgbm8gYmFja2VuZCBlbnRyeVxuICAgICAgICBtLnF1ZXN0aW9uICYmIC8vIEhhcyBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0XG4gICAgICAgIG0ucXVlc3Rpb24gIT09IGBNYXJrZXQgJHttLmFkZHJlc3Muc2xpY2UoMCwgOCl9Li4uJHttLmFkZHJlc3Muc2xpY2UoLTYpfWAgLy8gTm90IGp1c3QgZmFsbGJhY2tcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChtYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSAke21hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMubGVuZ3RofSBvbi1jaGFpbiBtYXJrZXRzIG1pc3NpbmcgYmFja2VuZCBtZXRhZGF0YS4gQXV0by1zeW5jaW5nLi4uYCk7XG4gICAgICAgIC8vIFRyeSB0byBjcmVhdGUgYmFja2VuZCBlbnRyaWVzIGZvciB0aGVzZSBtYXJrZXRzIChub24tYmxvY2tpbmcpXG4gICAgICAgIFByb21pc2UuYWxsKG1hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMubWFwKGFzeW5jIChtYXJrZXQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBpVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMVwiO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYmFja2VuZCBlbnRyeSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgY29uc3QgYmFja2VuZE1hcmtldHMgPSBhd2FpdCBheGlvcy5nZXQoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2ApO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gYmFja2VuZE1hcmtldHMuZGF0YS5zb21lKChtOiBhbnkpID0+IFxuICAgICAgICAgICAgICBtLm1hcmtldF9hZGRyZXNzPy50b0xvd2VyQ2FzZSgpID09PSBtYXJrZXQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWV4aXN0cyAmJiBtYXJrZXQucXVlc3Rpb24gJiYgbWFya2V0LmNyZWF0b3JBZGRyZXNzKSB7XG4gICAgICAgICAgICAgIC8vIENyZWF0ZSBiYWNrZW5kIGVudHJ5IHdpdGggY29udHJhY3QgZGF0YVxuICAgICAgICAgICAgICBhd2FpdCBheGlvcy5wb3N0KGAke2FwaVVybH0vYXBpL21hcmtldHNgLCB7XG4gICAgICAgICAgICAgICAgcXVlc3Rpb246IG1hcmtldC5xdWVzdGlvbixcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogbWFya2V0LmNhdGVnb3J5IHx8IFwiT3RoZXJcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNyAqIDI0ICogNjAgKiA2MCwgLy8gRGVmYXVsdCA3IGRheXNcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uRGVsYXk6IDI0ICogNjAgKiA2MCwgLy8gRGVmYXVsdCAyNCBob3Vyc1xuICAgICAgICAgICAgICAgIGltYWdlVXJsOiBtYXJrZXQuaW1hZ2VVcmwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBvcmFjbGVUeXBlOiBcImNoYWlubGlua1wiLCAvLyBEZWZhdWx0XG4gICAgICAgICAgICAgICAgY3JlYXRvckFkZHJlc3M6IG1hcmtldC5jcmVhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBtYXJrZXRBZGRyZXNzOiBtYXJrZXQuYWRkcmVzcyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gQXV0by1jcmVhdGVkIGJhY2tlbmQgZW50cnkgZm9yIG1hcmtldCAke21hcmtldC5hZGRyZXNzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gU2lsZW50bHkgZmFpbCAtIHRoaXMgaXMganVzdCBhIHN5bmMgYXR0ZW1wdFxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW3VzZU1hcmtldHNdIENvdWxkIG5vdCBhdXRvLXN5bmMgbWFya2V0ICR7bWFya2V0LmFkZHJlc3N9OmAsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgLSB0aGlzIGlzIGJlc3QgZWZmb3J0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgb3V0IG1hcmtldHMgd2l0aCBlbXB0eS9pbnZhbGlkIGFkZHJlc3NlcyAtIG9ubHkgc2hvdyByZWFsIG9uLWNoYWluIG1hcmtldHNcbiAgICAgIGNvbnN0IHZhbGlkTWFya2V0cyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4ge1xuICAgICAgICAvLyBNdXN0IGhhdmUgYSB2YWxpZCBhZGRyZXNzXG4gICAgICAgIGlmICghbS5hZGRyZXNzIHx8IG0uYWRkcmVzcyA9PT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdXN0IGJlIGEgdmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXRcbiAgICAgICAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChtLmFkZHJlc3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11c3QgaGF2ZSBiZWVuIGZldGNoZWQgZnJvbSBmYWN0b3J5IChleGlzdHMgaW4gbWFya2V0QWRkcmVzc2VzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBtYXJrZXRzV2l0aENyZWF0b3JzID0gdmFsaWRNYXJrZXRzLmZpbHRlcihtID0+IG0uY3JlYXRvckFkZHJlc3MpLmxlbmd0aDtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gVmFsaWQgb24tY2hhaW4gbWFya2V0czogJHt2YWxpZE1hcmtldHMubGVuZ3RofSwgTWFya2V0cyB3aXRoIGNyZWF0b3JzOiAke21hcmtldHNXaXRoQ3JlYXRvcnN9YCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZXMgYW5kIGFkZCB0byBtYXJrZXQgZGF0YVxuICAgICAgY29uc3QgbWFya2V0c1dpdGhUcmVuZGluZyA9IHZhbGlkTWFya2V0cy5tYXAobWFya2V0ID0+ICh7XG4gICAgICAgIC4uLm1hcmtldCxcbiAgICAgICAgdHJlbmRpbmdTY29yZTogY2FsY3VsYXRlVHJlbmRpbmdTY29yZShtYXJrZXQpLFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZpbmFsIG1hcmtldHMgdG8gZGlzcGxheTpgLCBtYXJrZXRzV2l0aFRyZW5kaW5nLm1hcChtID0+ICh7IFxuICAgICAgICBhZGRyZXNzOiBtLmFkZHJlc3MsIFxuICAgICAgICBxdWVzdGlvbjogbS5xdWVzdGlvbiB8fCAnTm8gcXVlc3Rpb24nLCBcbiAgICAgICAgaGFzSW1hZ2U6ICEhbS5pbWFnZVVybCxcbiAgICAgICAgaW1hZ2VVcmw6IG0uaW1hZ2VVcmwgPyBgJHttLmltYWdlVXJsLnN1YnN0cmluZygwLCA1MCl9Li4uYCA6ICdub25lJ1xuICAgICAgfSkpKTtcbiAgICAgIFxuICAgICAgc2V0TWFya2V0cyhtYXJrZXRzV2l0aFRyZW5kaW5nKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzOlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0c1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaE1hcmtldHMoKTtcbiAgfSwgW2ZldGNoTWFya2V0c10pO1xuXG4gIHJldHVybiB7IG1hcmtldHMsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldHMgfTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGZldGNoIGEgc2luZ2xlIG1hcmtldCdzIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcmtldChtYXJrZXRBZGRyZXNzOiBzdHJpbmcgfCBudWxsKSB7XG4gIGNvbnN0IFttYXJrZXQsIHNldE1hcmtldF0gPSB1c2VTdGF0ZTxNYXJrZXREYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmV0Y2hNYXJrZXQoKTtcbiAgfSwgW21hcmtldEFkZHJlc3NdKTtcblxuICBjb25zdCBmZXRjaE1hcmtldCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIC8vIFVzZSBCcm93c2VyUHJvdmlkZXIgYW5kIENvbnRyYWN0IGRpcmVjdGx5IHdpdGggbmV3IEFCSVxuICAgICAgbGV0IHByb3ZpZGVyRm9yQ29udHJhY3Q6IEJyb3dzZXJQcm92aWRlcjtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmFzZVByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IGJhc2VQcm92aWRlciBhcyBhbnkgYXMgQnJvd3NlclByb3ZpZGVyO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtYXJrZXRDb250cmFjdCA9IG5ldyBDb250cmFjdChtYXJrZXRBZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcblxuICAgICAgLy8gVXNlIG5ldyBBQkkgbWV0aG9kczogcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZVxuICAgICAgY29uc3QgW3F1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5kZWFkbGluZSgpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5yZXNvbHZlZCgpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5vdXRjb21lKCksIC8vIGVudW06IDAsMSwyXG4gICAgICBdKTtcblxuICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICBsZXQgY3VycmVudFByaWNlID0gMG47XG4gICAgICBsZXQgbG9ja1ByaWNlID0gMG47XG4gICAgICBsZXQgdG90YWxZZXMgPSAwbjtcbiAgICAgIGxldCB0b3RhbE5vID0gMG47XG4gICAgICBsZXQgZmVlZElkID0gXCIweDBcIjtcbiAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcblxuICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICAvLyBXcmFwIGVhY2ggY2FsbCBpbiBhIHByb21pc2UgdGhhdCBjYXRjaGVzIGVycm9yc1xuICAgICAgY29uc3Qgc2FmZUNhbGwgPSBhc3luYyAoZm46ICgpID0+IFByb21pc2U8YW55PiwgZGVmYXVsdFZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgW2N1cnJlbnRQcmljZSwgbG9ja1ByaWNlLCBzdGF0ZSwgdG90YWxZZXMsIHRvdGFsTm8sIGZlZWRJZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QuZ2V0Q3VycmVudFByaWNlKCksIDBuKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnN0YXRlKCksIDApLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsWWVzKCksIDBuKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC50b3RhbE5vKCksIDBuKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5mZWVkSWQoKSwgXCIweDBcIiksXG4gICAgICAgIF0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElmIG1ldGhvZHMgZG9uJ3QgZXhpc3QsIGRlZmF1bHRzIGFyZSBhbHJlYWR5IHNldCBhYm92ZVxuICAgICAgICBjb25zb2xlLndhcm4oYFNvbWUgb3B0aW9uYWwgbWV0aG9kcyBub3QgYXZhaWxhYmxlIGZvciBtYXJrZXQgJHttYXJrZXRBZGRyZXNzfSwgdXNpbmcgZGVmYXVsdHNgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFwIHJlc29sdmVkL291dGNvbWUgdG8gTWFya2V0U3RhdGVcbiAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLlJlc29sdmVkO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIoZGVhZGxpbmUpIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuTG9ja2VkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgZmVlZElkIGJ5dGVzMzIgdG8gc3RyaW5nIGlmIGF2YWlsYWJsZVxuICAgICAgbGV0IGZlZWRJZFN0ciA9IFwiXCI7XG4gICAgICBsZXQgZmVlZElkSGV4ID0gXCIweDBcIjtcbiAgICAgIGlmIChmZWVkSWQgJiYgZmVlZElkICE9PSBcIjB4MFwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmVlZElkU3RyID0gZXRoZXJzLnRvVXRmOFN0cmluZyhmZWVkSWQpLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcbiAgICAgICAgICBmZWVkSWRIZXggPSBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZmVlZElkSGV4ID0gdHlwZW9mIGZlZWRJZCA9PT0gXCJzdHJpbmdcIiA/IGZlZWRJZCA6IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0TWFya2V0KHtcbiAgICAgICAgYWRkcmVzczogbWFya2V0QWRkcmVzcyxcbiAgICAgICAgZmVlZElkOiBmZWVkSWRIZXgsXG4gICAgICAgIGN1cnJlbnRQcmljZTogY3VycmVudFByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudFByaWNlKSA6IFwiMFwiLFxuICAgICAgICBsb2NrUHJpY2U6IGxvY2tQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGxvY2tQcmljZSkgOiBcIjBcIixcbiAgICAgICAgc3RhdGU6IHN0YXRlIGFzIE1hcmtldFN0YXRlLFxuICAgICAgICB0b3RhbFllczogdG90YWxZZXMgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbFllcykgOiBcIjBcIixcbiAgICAgICAgdG90YWxObzogdG90YWxObyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsTm8pIDogXCIwXCIsXG4gICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldDpcIiwgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldFwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IG1hcmtldCwgbG9hZGluZywgZXJyb3IsIHJlZmV0Y2g6IGZldGNoTWFya2V0IH07XG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZXRoZXJzIiwiQnJvd3NlclByb3ZpZGVyIiwiQ29udHJhY3QiLCJheGlvcyIsIm1hcmtldEFydGlmYWN0IiwiZ2V0RmFjdG9yeUNvbnRyYWN0IiwiZ2V0UHJvdmlkZXIiLCJNYXJrZXRTdGF0ZSIsIkZBQ1RPUllfQUREUkVTUyIsIk1BUktFVF9BQkkiLCJhYmkiLCJjYWxjdWxhdGVUcmVuZGluZ1Njb3JlIiwibWFya2V0IiwidG90YWxZZXMiLCJwYXJzZUZsb2F0IiwidG90YWxObyIsInRvdGFsTGlxdWlkaXR5Iiwic2NvcmUiLCJzdGF0ZSIsIkFjdGl2ZSIsImJhbGFuY2UiLCJNYXRoIiwibWluIiwibWF4IiwidXNlTWFya2V0cyIsIm1hcmtldHMiLCJzZXRNYXJrZXRzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiZmV0Y2hNYXJrZXRzIiwicHJvdmlkZXIiLCJmYWN0b3J5IiwibWFya2V0QWRkcmVzc2VzIiwiZ2V0TWFya2V0cyIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJjcmVhdGlvblR4TWFwIiwiTWFwIiwiY3JlYXRvck1hcCIsImV2ZW50VG9waWMiLCJpZCIsImZpbHRlciIsImFkZHJlc3MiLCJ0b3BpY3MiLCJldmVudHMiLCJnZXRMb2dzIiwidHhTZW5kZXIiLCJ0eCIsImdldFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25IYXNoIiwiZnJvbSIsInRvTG93ZXJDYXNlIiwidHhFcnIiLCJ3YXJuIiwiZGVjb2RlZCIsImludGVyZmFjZSIsInBhcnNlTG9nIiwiZGF0YSIsInBhcnNlRXJyIiwibWFya2V0QWRkcmVzcyIsImdldEFkZHJlc3MiLCJzbGljZSIsImNyZWF0b3JBZGRyZXNzIiwic2V0IiwiYXJncyIsImNyZWF0b3IiLCJzaXplIiwiZXJyIiwiYmFja2VuZE1hcmtldHMiLCJhcGlVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInJlc3BvbnNlIiwiZ2V0IiwiYmFja2VuZE1hcEJ5QWRkcmVzcyIsImJhY2tlbmRNYXBCeUZlZWRJZCIsImZvckVhY2giLCJtIiwibWFya2V0X2FkZHJlc3MiLCJhZGRyTG93ZXIiLCJmZWVkX2lkIiwiZmVlZElkTG93ZXIiLCJzdGFydHNXaXRoIiwibWFya2V0UHJvbWlzZXMiLCJtYXAiLCJwcm92aWRlckZvckNvbnRyYWN0Iiwid2luZG93IiwiZXRoZXJldW0iLCJtYXJrZXRDb250cmFjdCIsInF1ZXN0aW9uIiwiZGVhZGxpbmUiLCJyZXNvbHZlZCIsIm91dGNvbWUiLCJQcm9taXNlIiwiYWxsIiwiY3VycmVudFByaWNlIiwibG9ja1ByaWNlIiwiZmVlZElkIiwic2FmZUNhbGwiLCJmbiIsImRlZmF1bHRWYWx1ZSIsImdldEN1cnJlbnRQcmljZSIsIlJlc29sdmVkIiwiTnVtYmVyIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiTG9ja2VkIiwiZmVlZElkU3RyIiwiZmVlZElkSGV4IiwidG9VdGY4U3RyaW5nIiwicmVwbGFjZSIsImhleGxpZnkiLCJhZGRyZXNzTG93ZXIiLCJiYWNrZW5kTWFya2V0IiwiZmVlZElkTm9QcmVmaXgiLCJjcmVhdGlvblR4SGFzaCIsImNyZWF0b3JfYWRkcmVzcyIsIm1hcmtldFRvcGljIiwiemVyb1BhZFZhbHVlIiwibWFya2V0RXZlbnRzIiwiZXZlbnRFcnIiLCJpbWFnZVVybCIsImltYWdlX3VybCIsInN1YnN0cmluZyIsImRpc3BsYXlRdWVzdGlvbiIsImRpc3BsYXlDYXRlZ29yeSIsImNhdGVnb3J5IiwibWFya2V0RGF0YSIsImZvcm1hdEV0aGVyIiwiZGVzY3JpcHRpb24iLCJjcmVhdGVkQXQiLCJjcmVhdGVkX2F0IiwibWFya2V0SWQiLCJtYXJrZXRfaWQiLCJ1bmRlZmluZWQiLCJiYXNpY0NvbnRyYWN0IiwicXVlc3Rpb25FcnIiLCJtYXJrZXRzTmVlZGluZ0NyZWF0b3JzIiwibWFya2V0c05lZWRpbmdCYWNrZW5kU3luYyIsImV4aXN0cyIsInNvbWUiLCJwb3N0IiwiZHVyYXRpb24iLCJyZXNvbHV0aW9uRGVsYXkiLCJvcmFjbGVUeXBlIiwiZGVidWciLCJjYXRjaCIsInZhbGlkTWFya2V0cyIsInRlc3QiLCJtYXJrZXRzV2l0aENyZWF0b3JzIiwibWFya2V0c1dpdGhUcmVuZGluZyIsInRyZW5kaW5nU2NvcmUiLCJoYXNJbWFnZSIsIm1lc3NhZ2UiLCJyZWZldGNoIiwidXNlTWFya2V0Iiwic2V0TWFya2V0IiwiZmV0Y2hNYXJrZXQiLCJiYXNlUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});