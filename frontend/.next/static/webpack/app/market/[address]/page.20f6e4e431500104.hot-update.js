"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/market/[address]/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory (ONLY on-chain markets - no mocks)\n            const marketAddresses = await factory.getMarkets();\n            // Single getLogs call for all MarketCreated events (more efficient, avoids rate limits)\n            const creationTxMap = new Map();\n            const creatorByMarket = {};\n            try {\n                // Query all MarketCreated events from the factory contract in one call\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const MARKET_CREATED_TOPIC = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                // Use a reasonable fromBlock - you can adjust this or use deployment block\n                // For now, query from block 0 (or use a known deployment block if available)\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        MARKET_CREATED_TOPIC\n                    ],\n                    fromBlock: 0,\n                    toBlock: \"latest\"\n                };\n                const logs = await provider.getLogs(filter);\n                // Build map: marketAddress -> creator (and also store tx hash)\n                for (const log of logs){\n                    try {\n                        // Parse the event log\n                        let parsed = null;\n                        try {\n                            parsed = factory.interface.parseLog({\n                                topics: log.topics,\n                                data: log.data\n                            });\n                        } catch (parseErr) {\n                            // Fallback: extract directly from topics if parsing fails\n                            if (log.topics && log.topics.length >= 3) {\n                                const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                                const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26)).toLowerCase();\n                                creatorByMarket[marketAddress] = creatorAddress;\n                                creationTxMap.set(marketAddress, log.transactionHash);\n                                continue;\n                            }\n                        }\n                        if (parsed && parsed.args) {\n                            var _parsed_args_market, _parsed_args_, _parsed_args_creator, _parsed_args_1;\n                            const market = ((_parsed_args_market = parsed.args.market) === null || _parsed_args_market === void 0 ? void 0 : _parsed_args_market.toLowerCase()) || ((_parsed_args_ = parsed.args[0]) === null || _parsed_args_ === void 0 ? void 0 : _parsed_args_.toLowerCase());\n                            const creator = ((_parsed_args_creator = parsed.args.creator) === null || _parsed_args_creator === void 0 ? void 0 : _parsed_args_creator.toLowerCase()) || ((_parsed_args_1 = parsed.args[1]) === null || _parsed_args_1 === void 0 ? void 0 : _parsed_args_1.toLowerCase());\n                            if (market && creator) {\n                                creatorByMarket[market] = creator;\n                                creationTxMap.set(market, log.transactionHash);\n                            }\n                        }\n                    } catch (parseErr) {\n                        console.warn(\"[useMarkets] Error parsing log \".concat(log.transactionHash, \":\"), parseErr);\n                    }\n                }\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            // Fetch metadata from backend API (ONLY for enriching on-chain markets with metadata - not for displaying)\n            // Backend markets are matched to on-chain markets by market_address\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market using new ABI\n            const marketPromises = marketAddresses.map(async (address)=>{\n                // Use BrowserProvider and Contract directly with new ABI\n                let providerForContract;\n                if ( true && window.ethereum) {\n                    providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n                } else {\n                    providerForContract = provider;\n                }\n                const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                try {\n                    var _marketAddresses_;\n                    // Wrap each call in a promise that catches errors\n                    const safeCall = async (fn, defaultValue)=>{\n                        try {\n                            return await fn();\n                        } catch (e) {\n                            return defaultValue;\n                        }\n                    };\n                    // Use new ABI methods: question, deadline, resolved, outcome\n                    // Also try to read creator directly from contract if available\n                    const [question, deadline, resolved, outcome] = await Promise.all([\n                        marketContract.question(),\n                        marketContract.deadline(),\n                        marketContract.resolved(),\n                        marketContract.outcome()\n                    ]);\n                    // Try to read creator directly from contract (simplest method)\n                    let creatorFromContract = null;\n                    try {\n                        creatorFromContract = await marketContract.creator();\n                    } catch (err) {\n                    // Contract might not have creator() function, that's okay\n                    }\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    let currentPrice = 0n;\n                    let lockPrice = 0n;\n                    let totalYes = 0n;\n                    let totalNo = 0n;\n                    let feedId = \"0x0\";\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    try {\n                        [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                            safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                            safeCall(()=>marketContract.lockPrice(), 0n),\n                            safeCall(()=>marketContract.state(), 0),\n                            safeCall(()=>marketContract.totalYes(), 0n),\n                            safeCall(()=>marketContract.totalNo(), 0n),\n                            safeCall(()=>marketContract.feedId(), \"0x0\")\n                        ]);\n                    } catch (err) {\n                        // If methods don't exist, defaults are already set above\n                        console.warn(\"Some optional methods not available for market \".concat(address, \", using defaults\"));\n                    }\n                    // Map resolved/outcome to MarketState\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    } else {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes) if it's a bytes32\n                    let feedIdStr = \"\";\n                    let feedIdHex = \"0x0\";\n                    if (feedId && feedId !== \"0x0\") {\n                        try {\n                            feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                            feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        } catch (e) {\n                            feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        }\n                    }\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    // Priority 1: Read creator directly from contract (simplest and most reliable)\n                    let creatorAddress = creatorFromContract ? creatorFromContract.toLowerCase() : null;\n                    // Priority 2: Use creator from event map (from single getLogs call)\n                    if (!creatorAddress) {\n                        creatorAddress = creatorByMarket[addressLower] || null;\n                    }\n                    // Priority 3: Use backend creator_address\n                    if (!creatorAddress && (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.creator_address)) {\n                        creatorAddress = backendMarket.creator_address.toLowerCase();\n                        console.log(\"[useMarkets] Using creator from backend: \".concat(creatorAddress, \" for market \").concat(address));\n                    }\n                    if (creatorAddress) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" creator: \").concat(creatorAddress, \" (from \").concat(creatorFromContract ? \"contract\" : creatorByMarket[addressLower] ? \"events\" : \"backend\", \")\"));\n                    }\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    // Ensure we always have a question - prioritize contract, then backend, then fallback\n                    const displayQuestion = question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question) || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6));\n                    // Category: use backend if available, otherwise try to infer or use \"Other\"\n                    const displayCategory = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category) || \"Other\";\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                        lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                        state: state,\n                        totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                        totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                        // Use question from contract first (most reliable), fallback to backend, then generic\n                        question: displayQuestion,\n                        category: displayCategory,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress,\n                        createdAt: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.created_at) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.createdAt),\n                        // Include backend market_id for API calls (MarketInfo, MarketChat)\n                        marketId: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.market_id) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.id) || undefined\n                    };\n                    // Log if market is missing backend metadata\n                    if (!backendMarket) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" is on-chain but missing backend metadata. Using contract data only.\"));\n                    }\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least basic data using new ABI if other calls fail\n                    let question = \"\";\n                    let deadline = 0;\n                    let resolved = false;\n                    let outcome = 0n;\n                    try {\n                        const basicContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                        [question, deadline, resolved, outcome] = await Promise.all([\n                            basicContract.question(),\n                            basicContract.deadline(),\n                            basicContract.resolved(),\n                            basicContract.outcome()\n                        ]);\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch basic data for market \".concat(address, \":\"), questionErr);\n                    }\n                    // Determine state from resolved/deadline\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (deadline > 0 && deadline <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: state,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // No need for batch fetching - we already have creators from the single getLogs call\n            // Just check if any markets are still missing creators (shouldn't happen if events were parsed correctly)\n            const marketsNeedingCreators = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.creatorAddress);\n            if (marketsNeedingCreators.length > 0) {\n                console.warn(\"[useMarkets] \".concat(marketsNeedingCreators.length, \" markets still missing creators after event parsing. This shouldn't happen if events were parsed correctly.\"));\n            }\n            // Auto-sync: Create backend entries for on-chain markets missing backend metadata\n            // This ensures all markets have complete data\n            const marketsNeedingBackendSync = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.marketId && // No backend ID means no backend entry\n                m.question && // Has question from contract\n                m.question !== \"Market \".concat(m.address.slice(0, 8), \"...\").concat(m.address.slice(-6)) // Not just fallback\n            );\n            if (marketsNeedingBackendSync.length > 0) {\n                console.log(\"[useMarkets] \".concat(marketsNeedingBackendSync.length, \" on-chain markets missing backend metadata. Auto-syncing...\"));\n                // Try to create backend entries for these markets (non-blocking)\n                Promise.all(marketsNeedingBackendSync.map(async (market)=>{\n                    try {\n                        const apiUrl = \"http://localhost:3001\" || 0;\n                        // Check if backend entry already exists\n                        const backendMarkets = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                        const exists = backendMarkets.data.some((m)=>{\n                            var _m_market_address;\n                            return ((_m_market_address = m.market_address) === null || _m_market_address === void 0 ? void 0 : _m_market_address.toLowerCase()) === market.address.toLowerCase();\n                        });\n                        if (!exists && market.question && market.creatorAddress) {\n                            // Create backend entry with contract data\n                            await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].post(\"\".concat(apiUrl, \"/api/markets\"), {\n                                question: market.question,\n                                category: market.category || \"Other\",\n                                duration: 7 * 24 * 60 * 60,\n                                resolutionDelay: 24 * 60 * 60,\n                                imageUrl: market.imageUrl || null,\n                                oracleType: \"chainlink\",\n                                creatorAddress: market.creatorAddress,\n                                marketAddress: market.address\n                            });\n                            console.log(\"[useMarkets] Auto-created backend entry for market \".concat(market.address));\n                        }\n                    } catch (err) {\n                        // Silently fail - this is just a sync attempt\n                        console.debug(\"[useMarkets] Could not auto-sync market \".concat(market.address, \":\"), err);\n                    }\n                })).catch(()=>{\n                // Ignore errors - this is best effort\n                });\n            }\n            // Filter out markets with empty/invalid addresses - only show real on-chain markets\n            const validMarkets = marketData.filter((m)=>{\n                // Must have a valid address\n                if (!m.address || m.address === \"0x0000000000000000000000000000000000000000\") {\n                    return false;\n                }\n                // Must be a valid Ethereum address format\n                if (!/^0x[a-fA-F0-9]{40}$/.test(m.address)) {\n                    return false;\n                }\n                // Must have been fetched from factory (exists in marketAddresses)\n                return true;\n            });\n            const marketsWithCreators = validMarkets.filter((m)=>m.creatorAddress).length;\n            console.log(\"[useMarkets] Valid on-chain markets: \".concat(validMarkets.length, \", Markets with creators: \").concat(marketsWithCreators));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            // Use BrowserProvider and Contract directly with new ABI\n            let providerForContract;\n            if ( true && window.ethereum) {\n                providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n            } else {\n                const baseProvider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n                providerForContract = baseProvider;\n            }\n            const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(marketAddress, MARKET_ABI, providerForContract);\n            // Use new ABI methods: question, deadline, resolved, outcome\n            const [question, deadline, resolved, outcome] = await Promise.all([\n                marketContract.question(),\n                marketContract.deadline(),\n                marketContract.resolved(),\n                marketContract.outcome()\n            ]);\n            // Try to get additional data if methods exist (for backward compatibility)\n            let currentPrice = 0n;\n            let lockPrice = 0n;\n            let totalYes = 0n;\n            let totalNo = 0n;\n            let feedId = \"0x0\";\n            let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            // Try to get additional data if methods exist (for backward compatibility)\n            // Wrap each call in a promise that catches errors\n            const safeCall = async (fn, defaultValue)=>{\n                try {\n                    return await fn();\n                } catch (e) {\n                    return defaultValue;\n                }\n            };\n            try {\n                [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                    safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                    safeCall(()=>marketContract.lockPrice(), 0n),\n                    safeCall(()=>marketContract.state(), 0),\n                    safeCall(()=>marketContract.totalYes(), 0n),\n                    safeCall(()=>marketContract.totalNo(), 0n),\n                    safeCall(()=>marketContract.feedId(), \"0x0\")\n                ]);\n            } catch (err) {\n                // If methods don't exist, defaults are already set above\n                console.warn(\"Some optional methods not available for market \".concat(marketAddress, \", using defaults\"));\n            }\n            // Map resolved/outcome to MarketState\n            if (resolved) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n            } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n            } else {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            }\n            // Convert feedId bytes32 to string if available\n            let feedIdStr = \"\";\n            let feedIdHex = \"0x0\";\n            if (feedId && feedId !== \"0x0\") {\n                try {\n                    feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                } catch (e) {\n                    feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                }\n            }\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdHex,\n                currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                state: state,\n                totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0U7QUFDakM7QUFDK0I7QUFPL0I7QUFFMUIsTUFBTVksYUFBYUwsMkRBQWtCO0FBRXJDOztDQUVDLEdBQ0QsU0FBU08sdUJBQXVCQyxNQUFrQjtJQUNoRCxNQUFNQyxXQUFXQyxXQUFXRixPQUFPQyxRQUFRO0lBQzNDLE1BQU1FLFVBQVVELFdBQVdGLE9BQU9HLE9BQU87SUFDekMsTUFBTUMsaUJBQWlCSCxXQUFXRTtJQUVsQyxxQ0FBcUM7SUFDckMsSUFBSUUsUUFBUUQ7SUFFWiwyQkFBMkI7SUFDM0IsSUFBSUosT0FBT00sS0FBSyxLQUFLWCx1REFBV0EsQ0FBQ1ksTUFBTSxFQUFFO1FBQ3ZDRixTQUFTO0lBQ1g7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTUksVUFBVUMsS0FBS0MsR0FBRyxDQUFDVCxVQUFVRSxXQUFXTSxLQUFLRSxHQUFHLENBQUNWLFVBQVVFO1FBQ2pFRSxTQUFVLElBQUlHLFVBQVUsS0FBTSx1Q0FBdUM7SUFDdkU7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTTztJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQWUsRUFBRTtJQUN2RCxNQUFNLENBQUM4QixTQUFTQyxXQUFXLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWtDLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQixJQUFJO1lBQ0Y2QixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxNQUFNRSxXQUFXMUIsMkRBQVdBO1lBQzVCLE1BQU0yQixVQUFVNUIsa0VBQWtCQSxDQUFDMkI7WUFFbkMsMkVBQTJFO1lBQzNFLE1BQU1FLGtCQUE0QixNQUFNRCxRQUFRRSxV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QUFDYSxZQUFZO2dCQUN6REUsU0FBU0EsVUFBVSxFQUFFLEdBQUdmLGdEQUFrQixDQUFDZSxXQUFXO2dCQUN0RDZFLFVBQVVBO1lBQ1o7UUFDRixFQUFFLE9BQU8xQixLQUFVO1lBQ2pCRixRQUFRbkMsS0FBSyxDQUFDLDJCQUEyQnFDO1lBQ3pDcEMsU0FBU29DLElBQUlxRixPQUFPLElBQUk7UUFDMUIsU0FBVTtZQUNSM0gsV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPO1FBQUVoQjtRQUFRZTtRQUFTRTtRQUFPMkgsU0FBU0c7SUFBWTtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlTWFya2V0cy50cz9kM2MzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBldGhlcnMsIEJyb3dzZXJQcm92aWRlciwgQ29udHJhY3QgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgbWFya2V0QXJ0aWZhY3QgZnJvbSBcIkAvYWJpL1ByZWRpY3Rpb25NYXJrZXQuanNvblwiO1xuaW1wb3J0IHtcbiAgZ2V0RmFjdG9yeUNvbnRyYWN0LFxuICBnZXRQcm92aWRlcixcbiAgTWFya2V0RGF0YSxcbiAgTWFya2V0U3RhdGUsXG4gIEZBQ1RPUllfQUREUkVTUyxcbn0gZnJvbSBcIi4uL2xpYi9jb250cmFjdHNcIjtcblxuY29uc3QgTUFSS0VUX0FCSSA9IG1hcmtldEFydGlmYWN0LmFiaTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmUgYmFzZWQgb24gbGlxdWlkaXR5IGFuZCBhY3Rpdml0eVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldDogTWFya2V0RGF0YSk6IG51bWJlciB7XG4gIGNvbnN0IHRvdGFsWWVzID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxZZXMpO1xuICBjb25zdCB0b3RhbE5vID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxObyk7XG4gIGNvbnN0IHRvdGFsTGlxdWlkaXR5ID0gdG90YWxZZXMgKyB0b3RhbE5vO1xuICBcbiAgLy8gQmFzZSBzY29yZSBmcm9tIGxpcXVpZGl0eSAodm9sdW1lKVxuICBsZXQgc2NvcmUgPSB0b3RhbExpcXVpZGl0eTtcbiAgXG4gIC8vIEJvb3N0IGZvciBhY3RpdmUgbWFya2V0c1xuICBpZiAobWFya2V0LnN0YXRlID09PSBNYXJrZXRTdGF0ZS5BY3RpdmUpIHtcbiAgICBzY29yZSAqPSAxLjI7XG4gIH1cbiAgXG4gIC8vIEJvb3N0IGZvciBtYXJrZXRzIHdpdGggYmFsYW5jZWQgbGlxdWlkaXR5IChtb3JlIGludGVyZXN0aW5nKVxuICBpZiAodG90YWxMaXF1aWRpdHkgPiAwKSB7XG4gICAgY29uc3QgYmFsYW5jZSA9IE1hdGgubWluKHRvdGFsWWVzLCB0b3RhbE5vKSAvIE1hdGgubWF4KHRvdGFsWWVzLCB0b3RhbE5vKTtcbiAgICBzY29yZSAqPSAoMSArIGJhbGFuY2UgKiAwLjMpOyAvLyBVcCB0byAzMCUgYm9vc3QgZm9yIGJhbGFuY2VkIG1hcmtldHNcbiAgfVxuICBcbiAgcmV0dXJuIHNjb3JlO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYWxsIG1hcmtldHMgZnJvbSB0aGUgZmFjdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0cygpIHtcbiAgY29uc3QgW21hcmtldHMsIHNldE1hcmtldHNdID0gdXNlU3RhdGU8TWFya2V0RGF0YVtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGZldGNoTWFya2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICBjb25zdCBmYWN0b3J5ID0gZ2V0RmFjdG9yeUNvbnRyYWN0KHByb3ZpZGVyKTtcblxuICAgICAgLy8gR2V0IGFsbCBtYXJrZXQgYWRkcmVzc2VzIGZyb20gZmFjdG9yeSAoT05MWSBvbi1jaGFpbiBtYXJrZXRzIC0gbm8gbW9ja3MpXG4gICAgICBjb25zdCBtYXJrZXRBZGRyZXNzZXM6IHN0cmluZ1tdID0gYXdhaXQgZmFjdG9yeS5nZXRNYXJrZXRzKCk7XG4gICAgICBcbiAgICAgIC8vIFNpbmdsZSBnZXRMb2dzIGNhbGwgZm9yIGFsbCBNYXJrZXRDcmVhdGVkIGV2ZW50cyAobW9yZSBlZmZpY2llbnQsIGF2b2lkcyByYXRlIGxpbWl0cylcbiAgICAgIGNvbnN0IGNyZWF0aW9uVHhNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgY29uc3QgY3JlYXRvckJ5TWFya2V0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICB0cnkge1xuICAgICAgICAvLyBRdWVyeSBhbGwgTWFya2V0Q3JlYXRlZCBldmVudHMgZnJvbSB0aGUgZmFjdG9yeSBjb250cmFjdCBpbiBvbmUgY2FsbFxuICAgICAgICAvLyBFdmVudCBzaWduYXR1cmU6IE1hcmtldENyZWF0ZWQoYWRkcmVzcyBpbmRleGVkIG1hcmtldCwgYWRkcmVzcyBpbmRleGVkIGNyZWF0b3IsIGFkZHJlc3MgaW5kZXhlZCBmZWVkQWRkcmVzcylcbiAgICAgICAgY29uc3QgTUFSS0VUX0NSRUFURURfVE9QSUMgPSBldGhlcnMuaWQoXCJNYXJrZXRDcmVhdGVkKGFkZHJlc3MsYWRkcmVzcyxhZGRyZXNzKVwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBhIHJlYXNvbmFibGUgZnJvbUJsb2NrIC0geW91IGNhbiBhZGp1c3QgdGhpcyBvciB1c2UgZGVwbG95bWVudCBibG9ja1xuICAgICAgICAvLyBGb3Igbm93LCBxdWVyeSBmcm9tIGJsb2NrIDAgKG9yIHVzZSBhIGtub3duIGRlcGxveW1lbnQgYmxvY2sgaWYgYXZhaWxhYmxlKVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgYWRkcmVzczogRkFDVE9SWV9BRERSRVNTLFxuICAgICAgICAgIHRvcGljczogW01BUktFVF9DUkVBVEVEX1RPUElDXSxcbiAgICAgICAgICBmcm9tQmxvY2s6IDAsIC8vIFN0YXJ0IGZyb20gYmVnaW5uaW5nLCBvciB1c2UgZGVwbG95bWVudCBibG9jayBpZiBrbm93blxuICAgICAgICAgIHRvQmxvY2s6IFwibGF0ZXN0XCIsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gQnVpbGQgbWFwOiBtYXJrZXRBZGRyZXNzIC0+IGNyZWF0b3IgKGFuZCBhbHNvIHN0b3JlIHR4IGhhc2gpXG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV2ZW50IGxvZ1xuICAgICAgICAgICAgbGV0IHBhcnNlZDogYW55ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlZCA9IGZhY3RvcnkuaW50ZXJmYWNlLnBhcnNlTG9nKHtcbiAgICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3MsXG4gICAgICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnIpIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGV4dHJhY3QgZGlyZWN0bHkgZnJvbSB0b3BpY3MgaWYgcGFyc2luZyBmYWlsc1xuICAgICAgICAgICAgICBpZiAobG9nLnRvcGljcyAmJiBsb2cudG9waWNzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya2V0QWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKFwiMHhcIiArIGxvZy50b3BpY3NbMV0uc2xpY2UoMjYpKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0b3JBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1syXS5zbGljZSgyNikpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY3JlYXRvckJ5TWFya2V0W21hcmtldEFkZHJlc3NdID0gY3JlYXRvckFkZHJlc3M7XG4gICAgICAgICAgICAgICAgY3JlYXRpb25UeE1hcC5zZXQobWFya2V0QWRkcmVzcywgbG9nLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBhcnNlZCAmJiBwYXJzZWQuYXJncykge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXQgPSBwYXJzZWQuYXJncy5tYXJrZXQ/LnRvTG93ZXJDYXNlKCkgfHwgcGFyc2VkLmFyZ3NbMF0/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGNyZWF0b3IgPSBwYXJzZWQuYXJncy5jcmVhdG9yPy50b0xvd2VyQ2FzZSgpIHx8IHBhcnNlZC5hcmdzWzFdPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKG1hcmtldCAmJiBjcmVhdG9yKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRvckJ5TWFya2V0W21hcmtldF0gPSBjcmVhdG9yO1xuICAgICAgICAgICAgICAgIGNyZWF0aW9uVHhNYXAuc2V0KG1hcmtldCwgbG9nLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdXNlTWFya2V0c10gRXJyb3IgcGFyc2luZyBsb2cgJHtsb2cudHJhbnNhY3Rpb25IYXNofTpgLCBwYXJzZUVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBNYXJrZXRDcmVhdGVkIGV2ZW50czpcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmV0Y2ggbWV0YWRhdGEgZnJvbSBiYWNrZW5kIEFQSSAoT05MWSBmb3IgZW5yaWNoaW5nIG9uLWNoYWluIG1hcmtldHMgd2l0aCBtZXRhZGF0YSAtIG5vdCBmb3IgZGlzcGxheWluZylcbiAgICAgIC8vIEJhY2tlbmQgbWFya2V0cyBhcmUgbWF0Y2hlZCB0byBvbi1jaGFpbiBtYXJrZXRzIGJ5IG1hcmtldF9hZGRyZXNzXG4gICAgICBsZXQgYmFja2VuZE1hcmtldHM6IGFueVtdID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCI7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke2FwaVVybH0vYXBpL21hcmtldHNgKTtcbiAgICAgICAgYmFja2VuZE1hcmtldHMgPSByZXNwb25zZS5kYXRhIHx8IFtdO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXQgbWV0YWRhdGEgZnJvbSBiYWNrZW5kOlwiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgYmFja2VuZCBtYXJrZXRzIGJ5IG1hcmtldF9hZGRyZXNzIChwcmltYXJ5KSBhbmQgZmVlZElkIChmYWxsYmFjaykgZm9yIHF1aWNrIGxvb2t1cFxuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5QWRkcmVzcyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICBjb25zdCBiYWNrZW5kTWFwQnlGZWVkSWQgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgYmFja2VuZE1hcmtldHMuZm9yRWFjaCgobTogYW55KSA9PiB7XG4gICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldF9hZGRyZXNzIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5tYXJrZXRfYWRkcmVzcykge1xuICAgICAgICAgIGNvbnN0IGFkZHJMb3dlciA9IG0ubWFya2V0X2FkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlBZGRyZXNzLnNldChhZGRyTG93ZXIsIG0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrOiBtYXRjaCBieSBmZWVkSWQgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtLmZlZWRfaWQpIHtcbiAgICAgICAgICBjb25zdCBmZWVkSWRMb3dlciA9IG0uZmVlZF9pZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIsIG0pO1xuICAgICAgICAgIC8vIEFsc28gdHJ5IHdpdGhvdXQgMHggcHJlZml4IGlmIHByZXNlbnRcbiAgICAgICAgICBpZiAoZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLnNldChmZWVkSWRMb3dlci5zbGljZSgyKSwgbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRmV0Y2ggZGF0YSBmb3IgZWFjaCBtYXJrZXQgdXNpbmcgbmV3IEFCSVxuICAgICAgY29uc3QgbWFya2V0UHJvbWlzZXMgPSBtYXJrZXRBZGRyZXNzZXMubWFwKGFzeW5jIChhZGRyZXNzKSA9PiB7XG4gICAgICAgIC8vIFVzZSBCcm93c2VyUHJvdmlkZXIgYW5kIENvbnRyYWN0IGRpcmVjdGx5IHdpdGggbmV3IEFCSVxuICAgICAgICBsZXQgcHJvdmlkZXJGb3JDb250cmFjdDogQnJvd3NlclByb3ZpZGVyO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBwcm92aWRlciBhcyBhbnkgYXMgQnJvd3NlclByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIE1BUktFVF9BQkksIHByb3ZpZGVyRm9yQ29udHJhY3QpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gV3JhcCBlYWNoIGNhbGwgaW4gYSBwcm9taXNlIHRoYXQgY2F0Y2hlcyBlcnJvcnNcbiAgICAgICAgICBjb25zdCBzYWZlQ2FsbCA9IGFzeW5jIChmbjogKCkgPT4gUHJvbWlzZTxhbnk+LCBkZWZhdWx0VmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVzZSBuZXcgQUJJIG1ldGhvZHM6IHF1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVcbiAgICAgICAgICAvLyBBbHNvIHRyeSB0byByZWFkIGNyZWF0b3IgZGlyZWN0bHkgZnJvbSBjb250cmFjdCBpZiBhdmFpbGFibGVcbiAgICAgICAgICBjb25zdCBbcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICAgICAgbWFya2V0Q29udHJhY3QuZGVhZGxpbmUoKSxcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LnJlc29sdmVkKCksXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5vdXRjb21lKCksIC8vIGVudW06IDAsMSwyXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHJlYWQgY3JlYXRvciBkaXJlY3RseSBmcm9tIGNvbnRyYWN0IChzaW1wbGVzdCBtZXRob2QpXG4gICAgICAgICAgbGV0IGNyZWF0b3JGcm9tQ29udHJhY3Q6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjcmVhdG9yRnJvbUNvbnRyYWN0ID0gYXdhaXQgbWFya2V0Q29udHJhY3QuY3JlYXRvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQ29udHJhY3QgbWlnaHQgbm90IGhhdmUgY3JlYXRvcigpIGZ1bmN0aW9uLCB0aGF0J3Mgb2theVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgYWRkaXRpb25hbCBkYXRhIGlmIG1ldGhvZHMgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgICAgIGxldCBjdXJyZW50UHJpY2UgPSAwbjtcbiAgICAgICAgICBsZXQgbG9ja1ByaWNlID0gMG47XG4gICAgICAgICAgbGV0IHRvdGFsWWVzID0gMG47XG4gICAgICAgICAgbGV0IHRvdGFsTm8gPSAwbjtcbiAgICAgICAgICBsZXQgZmVlZElkID0gXCIweDBcIjtcbiAgICAgICAgICBsZXQgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgW2N1cnJlbnRQcmljZSwgbG9ja1ByaWNlLCBzdGF0ZSwgdG90YWxZZXMsIHRvdGFsTm8sIGZlZWRJZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnN0YXRlKCksIDApLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC50b3RhbFllcygpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsTm8oKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5mZWVkSWQoKSwgXCIweDBcIiksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIG1ldGhvZHMgZG9uJ3QgZXhpc3QsIGRlZmF1bHRzIGFyZSBhbHJlYWR5IHNldCBhYm92ZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTb21lIG9wdGlvbmFsIG1ldGhvZHMgbm90IGF2YWlsYWJsZSBmb3IgbWFya2V0ICR7YWRkcmVzc30sIHVzaW5nIGRlZmF1bHRzYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTWFwIHJlc29sdmVkL291dGNvbWUgdG8gTWFya2V0U3RhdGVcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIoZGVhZGxpbmUpIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkxvY2tlZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgKHJlbW92ZSBudWxsIGJ5dGVzKSBpZiBpdCdzIGEgYnl0ZXMzMlxuICAgICAgICAgIGxldCBmZWVkSWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGxldCBmZWVkSWRIZXggPSBcIjB4MFwiO1xuICAgICAgICAgIGlmIChmZWVkSWQgJiYgZmVlZElkICE9PSBcIjB4MFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuICAgICAgICAgICAgICBmZWVkSWRIZXggPSBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBmZWVkSWRIZXggPSB0eXBlb2YgZmVlZElkID09PSBcInN0cmluZ1wiID8gZmVlZElkIDogZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgbWF0Y2hpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldCBhZGRyZXNzIChtb3N0IHJlbGlhYmxlKVxuICAgICAgICAgIGNvbnN0IGFkZHJlc3NMb3dlciA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsZXQgYmFja2VuZE1hcmtldCA9IGJhY2tlbmRNYXBCeUFkZHJlc3MuZ2V0KGFkZHJlc3NMb3dlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmFsbGJhY2s6IG1hdGNoIGJ5IGZlZWRJZCBpZiBhZGRyZXNzIG1hdGNoIGZhaWxlZFxuICAgICAgICAgIGlmICghYmFja2VuZE1hcmtldCkge1xuICAgICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBmZWVkSWRIZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRJZE5vUHJlZml4ID0gZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSA/IGZlZWRJZExvd2VyLnNsaWNlKDIpIDogZmVlZElkTG93ZXI7XG4gICAgICAgICAgICBiYWNrZW5kTWFya2V0ID0gYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRMb3dlcikgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZE5vUHJlZml4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRTdHIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY3JlYXRpb25UeEhhc2ggPSBjcmVhdGlvblR4TWFwLmdldChhZGRyZXNzTG93ZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByaW9yaXR5IDE6IFJlYWQgY3JlYXRvciBkaXJlY3RseSBmcm9tIGNvbnRyYWN0IChzaW1wbGVzdCBhbmQgbW9zdCByZWxpYWJsZSlcbiAgICAgICAgICBsZXQgY3JlYXRvckFkZHJlc3MgPSBjcmVhdG9yRnJvbUNvbnRyYWN0ID8gY3JlYXRvckZyb21Db250cmFjdC50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcmlvcml0eSAyOiBVc2UgY3JlYXRvciBmcm9tIGV2ZW50IG1hcCAoZnJvbSBzaW5nbGUgZ2V0TG9ncyBjYWxsKVxuICAgICAgICAgIGlmICghY3JlYXRvckFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzID0gY3JlYXRvckJ5TWFya2V0W2FkZHJlc3NMb3dlcl0gfHwgbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJpb3JpdHkgMzogVXNlIGJhY2tlbmQgY3JlYXRvcl9hZGRyZXNzXG4gICAgICAgICAgaWYgKCFjcmVhdG9yQWRkcmVzcyAmJiBiYWNrZW5kTWFya2V0Py5jcmVhdG9yX2FkZHJlc3MpIHtcbiAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzID0gYmFja2VuZE1hcmtldC5jcmVhdG9yX2FkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gVXNpbmcgY3JlYXRvciBmcm9tIGJhY2tlbmQ6ICR7Y3JlYXRvckFkZHJlc3N9IGZvciBtYXJrZXQgJHthZGRyZXNzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY3JlYXRvckFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gY3JlYXRvcjogJHtjcmVhdG9yQWRkcmVzc30gKGZyb20gJHtjcmVhdG9yRnJvbUNvbnRyYWN0ID8gJ2NvbnRyYWN0JyA6IGNyZWF0b3JCeU1hcmtldFthZGRyZXNzTG93ZXJdID8gJ2V2ZW50cycgOiAnYmFja2VuZCd9KWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4dHJhY3QgaW1hZ2VVcmwgZnJvbSBiYWNrZW5kIG1hcmtldCAoc3VwcG9ydCBib3RoIHNuYWtlX2Nhc2UgYW5kIGNhbWVsQ2FzZSlcbiAgICAgICAgICBjb25zdCBpbWFnZVVybCA9IGJhY2tlbmRNYXJrZXQ/LmltYWdlX3VybCB8fCBiYWNrZW5kTWFya2V0Py5pbWFnZVVybCB8fCBudWxsO1xuICAgICAgICAgIGlmIChpbWFnZVVybCAmJiBhZGRyZXNzTG93ZXIgPT09IG1hcmtldEFkZHJlc3Nlc1swXT8udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBNYXJrZXQgJHthZGRyZXNzfSBoYXMgaW1hZ2VVcmw6YCwgaW1hZ2VVcmwuc3Vic3RyaW5nKDAsIDEwMCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHF1ZXN0aW9uIC0gcHJpb3JpdGl6ZSBjb250cmFjdCwgdGhlbiBiYWNrZW5kLCB0aGVuIGZhbGxiYWNrXG4gICAgICAgICAgY29uc3QgZGlzcGxheVF1ZXN0aW9uID0gcXVlc3Rpb24gfHwgYmFja2VuZE1hcmtldD8ucXVlc3Rpb24gfHwgYE1hcmtldCAke2FkZHJlc3Muc2xpY2UoMCwgOCl9Li4uJHthZGRyZXNzLnNsaWNlKC02KX1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhdGVnb3J5OiB1c2UgYmFja2VuZCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB0cnkgdG8gaW5mZXIgb3IgdXNlIFwiT3RoZXJcIlxuICAgICAgICAgIGNvbnN0IGRpc3BsYXlDYXRlZ29yeSA9IGJhY2tlbmRNYXJrZXQ/LmNhdGVnb3J5IHx8IFwiT3RoZXJcIjtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBtYXJrZXREYXRhOiBNYXJrZXREYXRhID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZWRJZDogZmVlZElkSGV4LFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBjdXJyZW50UHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihjdXJyZW50UHJpY2UpIDogXCIwXCIsXG4gICAgICAgICAgICBsb2NrUHJpY2U6IGxvY2tQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGxvY2tQcmljZSkgOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSBhcyBNYXJrZXRTdGF0ZSxcbiAgICAgICAgICAgIHRvdGFsWWVzOiB0b3RhbFllcyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSA6IFwiMFwiLFxuICAgICAgICAgICAgdG90YWxObzogdG90YWxObyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsTm8pIDogXCIwXCIsXG4gICAgICAgICAgICAvLyBVc2UgcXVlc3Rpb24gZnJvbSBjb250cmFjdCBmaXJzdCAobW9zdCByZWxpYWJsZSksIGZhbGxiYWNrIHRvIGJhY2tlbmQsIHRoZW4gZ2VuZXJpY1xuICAgICAgICAgICAgcXVlc3Rpb246IGRpc3BsYXlRdWVzdGlvbixcbiAgICAgICAgICAgIGNhdGVnb3J5OiBkaXNwbGF5Q2F0ZWdvcnksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYmFja2VuZE1hcmtldD8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpbWFnZVVybDogaW1hZ2VVcmwsIC8vIFNldCBpbWFnZVVybCBleHBsaWNpdGx5IChmcm9tIGJhY2tlbmQgaWYgYXZhaWxhYmxlKVxuICAgICAgICAgICAgY3JlYXRpb25UeEhhc2g6IGNyZWF0aW9uVHhIYXNoLFxuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3M6IGNyZWF0b3JBZGRyZXNzLCAvLyBTaG91bGQgYWx3YXlzIGJlIHNldCBieSBub3cgKGZyb20gZXZlbnRzIG9yIGJhY2tlbmQpXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IGJhY2tlbmRNYXJrZXQ/LmNyZWF0ZWRfYXQgfHwgYmFja2VuZE1hcmtldD8uY3JlYXRlZEF0LCAvLyBTdXBwb3J0IGJvdGggbmFtaW5nIGNvbnZlbnRpb25zXG4gICAgICAgICAgICAvLyBJbmNsdWRlIGJhY2tlbmQgbWFya2V0X2lkIGZvciBBUEkgY2FsbHMgKE1hcmtldEluZm8sIE1hcmtldENoYXQpXG4gICAgICAgICAgICBtYXJrZXRJZDogYmFja2VuZE1hcmtldD8ubWFya2V0X2lkIHx8IGJhY2tlbmRNYXJrZXQ/LmlkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBpZiBtYXJrZXQgaXMgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAgICAgaWYgKCFiYWNrZW5kTWFya2V0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIE1hcmtldCAke2FkZHJlc3N9IGlzIG9uLWNoYWluIGJ1dCBtaXNzaW5nIGJhY2tlbmQgbWV0YWRhdGEuIFVzaW5nIGNvbnRyYWN0IGRhdGEgb25seS5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWFya2V0RGF0YTtcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBtYXJrZXQgJHthZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgICAgIC8vIFRyeSB0byBnZXQgYXQgbGVhc3QgYmFzaWMgZGF0YSB1c2luZyBuZXcgQUJJIGlmIG90aGVyIGNhbGxzIGZhaWxcbiAgICAgICAgICBsZXQgcXVlc3Rpb24gPSBcIlwiO1xuICAgICAgICAgIGxldCBkZWFkbGluZSA9IDA7XG4gICAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IG91dGNvbWUgPSAwbjtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFzaWNDb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcbiAgICAgICAgICAgIFtxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0LmRlYWRsaW5lKCksXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3QucmVzb2x2ZWQoKSxcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5vdXRjb21lKCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGNhdGNoIChxdWVzdGlvbkVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmV0Y2ggYmFzaWMgZGF0YSBmb3IgbWFya2V0ICR7YWRkcmVzc306YCwgcXVlc3Rpb25FcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgc3RhdGUgZnJvbSByZXNvbHZlZC9kZWFkbGluZVxuICAgICAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWFkbGluZSA+IDAgJiYgZGVhZGxpbmUgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuTG9ja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXR1cm4gbWluaW1hbCBkYXRhIGlmIGNvbnRyYWN0IGNhbGwgZmFpbHMsIGJ1dCBzdGlsbCBpbmNsdWRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIG1hcmtldHMgYXJlIHNob3duIGV2ZW4gaWYgc29tZSBjYWxscyBmYWlsXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IFwiXCIsXG4gICAgICAgICAgICBjdXJyZW50UHJpY2U6IFwiMFwiLFxuICAgICAgICAgICAgbG9ja1ByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIHRvdGFsWWVzOiBcIjBcIixcbiAgICAgICAgICAgIHRvdGFsTm86IFwiMFwiLFxuICAgICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uIHx8IGBNYXJrZXQgJHthZGRyZXNzLnNsaWNlKDAsIDgpfS4uLiR7YWRkcmVzcy5zbGljZSgtNil9YCxcbiAgICAgICAgICB9IGFzIE1hcmtldERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtYXJrZXREYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwobWFya2V0UHJvbWlzZXMpO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCBkYXRhIGZvciAke21hcmtldERhdGEubGVuZ3RofSBtYXJrZXRzYCk7XG4gICAgICBcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJhdGNoIGZldGNoaW5nIC0gd2UgYWxyZWFkeSBoYXZlIGNyZWF0b3JzIGZyb20gdGhlIHNpbmdsZSBnZXRMb2dzIGNhbGxcbiAgICAgIC8vIEp1c3QgY2hlY2sgaWYgYW55IG1hcmtldHMgYXJlIHN0aWxsIG1pc3NpbmcgY3JlYXRvcnMgKHNob3VsZG4ndCBoYXBwZW4gaWYgZXZlbnRzIHdlcmUgcGFyc2VkIGNvcnJlY3RseSlcbiAgICAgIGNvbnN0IG1hcmtldHNOZWVkaW5nQ3JlYXRvcnMgPSBtYXJrZXREYXRhLmZpbHRlcihtID0+IFxuICAgICAgICBtLmFkZHJlc3MgJiYgXG4gICAgICAgIG0uYWRkcmVzcyAhPT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiAmJlxuICAgICAgICAhbS5jcmVhdG9yQWRkcmVzc1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKG1hcmtldHNOZWVkaW5nQ3JlYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFt1c2VNYXJrZXRzXSAke21hcmtldHNOZWVkaW5nQ3JlYXRvcnMubGVuZ3RofSBtYXJrZXRzIHN0aWxsIG1pc3NpbmcgY3JlYXRvcnMgYWZ0ZXIgZXZlbnQgcGFyc2luZy4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGlmIGV2ZW50cyB3ZXJlIHBhcnNlZCBjb3JyZWN0bHkuYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEF1dG8tc3luYzogQ3JlYXRlIGJhY2tlbmQgZW50cmllcyBmb3Igb24tY2hhaW4gbWFya2V0cyBtaXNzaW5nIGJhY2tlbmQgbWV0YWRhdGFcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyBhbGwgbWFya2V0cyBoYXZlIGNvbXBsZXRlIGRhdGFcbiAgICAgIGNvbnN0IG1hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMgPSBtYXJrZXREYXRhLmZpbHRlcihtID0+IFxuICAgICAgICBtLmFkZHJlc3MgJiYgXG4gICAgICAgIG0uYWRkcmVzcyAhPT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiAmJlxuICAgICAgICAhbS5tYXJrZXRJZCAmJiAvLyBObyBiYWNrZW5kIElEIG1lYW5zIG5vIGJhY2tlbmQgZW50cnlcbiAgICAgICAgbS5xdWVzdGlvbiAmJiAvLyBIYXMgcXVlc3Rpb24gZnJvbSBjb250cmFjdFxuICAgICAgICBtLnF1ZXN0aW9uICE9PSBgTWFya2V0ICR7bS5hZGRyZXNzLnNsaWNlKDAsIDgpfS4uLiR7bS5hZGRyZXNzLnNsaWNlKC02KX1gIC8vIE5vdCBqdXN0IGZhbGxiYWNrXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAobWFya2V0c05lZWRpbmdCYWNrZW5kU3luYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gJHttYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jLmxlbmd0aH0gb24tY2hhaW4gbWFya2V0cyBtaXNzaW5nIGJhY2tlbmQgbWV0YWRhdGEuIEF1dG8tc3luY2luZy4uLmApO1xuICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIGJhY2tlbmQgZW50cmllcyBmb3IgdGhlc2UgbWFya2V0cyAobm9uLWJsb2NraW5nKVxuICAgICAgICBQcm9taXNlLmFsbChtYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jLm1hcChhc3luYyAobWFya2V0KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFwaVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjMwMDFcIjtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGJhY2tlbmQgZW50cnkgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgIGNvbnN0IGJhY2tlbmRNYXJrZXRzID0gYXdhaXQgYXhpb3MuZ2V0KGAke2FwaVVybH0vYXBpL21hcmtldHNgKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IGJhY2tlbmRNYXJrZXRzLmRhdGEuc29tZSgobTogYW55KSA9PiBcbiAgICAgICAgICAgICAgbS5tYXJrZXRfYWRkcmVzcz8udG9Mb3dlckNhc2UoKSA9PT0gbWFya2V0LmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFleGlzdHMgJiYgbWFya2V0LnF1ZXN0aW9uICYmIG1hcmtldC5jcmVhdG9yQWRkcmVzcykge1xuICAgICAgICAgICAgICAvLyBDcmVhdGUgYmFja2VuZCBlbnRyeSB3aXRoIGNvbnRyYWN0IGRhdGFcbiAgICAgICAgICAgICAgYXdhaXQgYXhpb3MucG9zdChgJHthcGlVcmx9L2FwaS9tYXJrZXRzYCwge1xuICAgICAgICAgICAgICAgIHF1ZXN0aW9uOiBtYXJrZXQucXVlc3Rpb24sXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IG1hcmtldC5jYXRlZ29yeSB8fCBcIk90aGVyXCIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDcgKiAyNCAqIDYwICogNjAsIC8vIERlZmF1bHQgNyBkYXlzXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbkRlbGF5OiAyNCAqIDYwICogNjAsIC8vIERlZmF1bHQgMjQgaG91cnNcbiAgICAgICAgICAgICAgICBpbWFnZVVybDogbWFya2V0LmltYWdlVXJsIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgb3JhY2xlVHlwZTogXCJjaGFpbmxpbmtcIiwgLy8gRGVmYXVsdFxuICAgICAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzOiBtYXJrZXQuY3JlYXRvckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgbWFya2V0QWRkcmVzczogbWFya2V0LmFkZHJlc3MsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEF1dG8tY3JlYXRlZCBiYWNrZW5kIGVudHJ5IGZvciBtYXJrZXQgJHttYXJrZXQuYWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIFNpbGVudGx5IGZhaWwgLSB0aGlzIGlzIGp1c3QgYSBzeW5jIGF0dGVtcHRcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFt1c2VNYXJrZXRzXSBDb3VsZCBub3QgYXV0by1zeW5jIG1hcmtldCAke21hcmtldC5hZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIC0gdGhpcyBpcyBiZXN0IGVmZm9ydFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIG91dCBtYXJrZXRzIHdpdGggZW1wdHkvaW52YWxpZCBhZGRyZXNzZXMgLSBvbmx5IHNob3cgcmVhbCBvbi1jaGFpbiBtYXJrZXRzXG4gICAgICBjb25zdCB2YWxpZE1hcmtldHMgPSBtYXJrZXREYXRhLmZpbHRlcihtID0+IHtcbiAgICAgICAgLy8gTXVzdCBoYXZlIGEgdmFsaWQgYWRkcmVzc1xuICAgICAgICBpZiAoIW0uYWRkcmVzcyB8fCBtLmFkZHJlc3MgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVzdCBiZSBhIHZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XG4gICAgICAgIGlmICghL14weFthLWZBLUYwLTldezQwfSQvLnRlc3QobS5hZGRyZXNzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdXN0IGhhdmUgYmVlbiBmZXRjaGVkIGZyb20gZmFjdG9yeSAoZXhpc3RzIGluIG1hcmtldEFkZHJlc3NlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgbWFya2V0c1dpdGhDcmVhdG9ycyA9IHZhbGlkTWFya2V0cy5maWx0ZXIobSA9PiBtLmNyZWF0b3JBZGRyZXNzKS5sZW5ndGg7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFZhbGlkIG9uLWNoYWluIG1hcmtldHM6ICR7dmFsaWRNYXJrZXRzLmxlbmd0aH0sIE1hcmtldHMgd2l0aCBjcmVhdG9yczogJHttYXJrZXRzV2l0aENyZWF0b3JzfWApO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmVzIGFuZCBhZGQgdG8gbWFya2V0IGRhdGFcbiAgICAgIGNvbnN0IG1hcmtldHNXaXRoVHJlbmRpbmcgPSB2YWxpZE1hcmtldHMubWFwKG1hcmtldCA9PiAoe1xuICAgICAgICAuLi5tYXJrZXQsXG4gICAgICAgIHRyZW5kaW5nU2NvcmU6IGNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUobWFya2V0KSxcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGaW5hbCBtYXJrZXRzIHRvIGRpc3BsYXk6YCwgbWFya2V0c1dpdGhUcmVuZGluZy5tYXAobSA9PiAoeyBcbiAgICAgICAgYWRkcmVzczogbS5hZGRyZXNzLCBcbiAgICAgICAgcXVlc3Rpb246IG0ucXVlc3Rpb24gfHwgJ05vIHF1ZXN0aW9uJywgXG4gICAgICAgIGhhc0ltYWdlOiAhIW0uaW1hZ2VVcmwsXG4gICAgICAgIGltYWdlVXJsOiBtLmltYWdlVXJsID8gYCR7bS5pbWFnZVVybC5zdWJzdHJpbmcoMCwgNTApfS4uLmAgOiAnbm9uZSdcbiAgICAgIH0pKSk7XG4gICAgICBcbiAgICAgIHNldE1hcmtldHMobWFya2V0c1dpdGhUcmVuZGluZyk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0czpcIiwgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldHNcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hNYXJrZXRzKCk7XG4gIH0sIFtmZXRjaE1hcmtldHNdKTtcblxuICByZXR1cm4geyBtYXJrZXRzLCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXRzIH07XG59XG5cbi8qKlxuICogSG9vayB0byBmZXRjaCBhIHNpbmdsZSBtYXJrZXQncyBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXJrZXQobWFya2V0QWRkcmVzczogc3RyaW5nIHwgbnVsbCkge1xuICBjb25zdCBbbWFya2V0LCBzZXRNYXJrZXRdID0gdXNlU3RhdGU8TWFya2V0RGF0YSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2V0QWRkcmVzcykge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoTWFya2V0KCk7XG4gIH0sIFttYXJrZXRBZGRyZXNzXSk7XG5cbiAgY29uc3QgZmV0Y2hNYXJrZXQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAvLyBVc2UgQnJvd3NlclByb3ZpZGVyIGFuZCBDb250cmFjdCBkaXJlY3RseSB3aXRoIG5ldyBBQklcbiAgICAgIGxldCBwcm92aWRlckZvckNvbnRyYWN0OiBCcm93c2VyUHJvdmlkZXI7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IG5ldyBCcm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJhc2VQcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBiYXNlUHJvdmlkZXIgYXMgYW55IGFzIEJyb3dzZXJQcm92aWRlcjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbWFya2V0Q29udHJhY3QgPSBuZXcgQ29udHJhY3QobWFya2V0QWRkcmVzcywgTUFSS0VUX0FCSSwgcHJvdmlkZXJGb3JDb250cmFjdCk7XG5cbiAgICAgIC8vIFVzZSBuZXcgQUJJIG1ldGhvZHM6IHF1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVcbiAgICAgIGNvbnN0IFtxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgbWFya2V0Q29udHJhY3QucXVlc3Rpb24oKSxcbiAgICAgICAgbWFya2V0Q29udHJhY3QuZGVhZGxpbmUoKSxcbiAgICAgICAgbWFya2V0Q29udHJhY3QucmVzb2x2ZWQoKSxcbiAgICAgICAgbWFya2V0Q29udHJhY3Qub3V0Y29tZSgpLCAvLyBlbnVtOiAwLDEsMlxuICAgICAgXSk7XG5cbiAgICAgIC8vIFRyeSB0byBnZXQgYWRkaXRpb25hbCBkYXRhIGlmIG1ldGhvZHMgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgbGV0IGN1cnJlbnRQcmljZSA9IDBuO1xuICAgICAgbGV0IGxvY2tQcmljZSA9IDBuO1xuICAgICAgbGV0IHRvdGFsWWVzID0gMG47XG4gICAgICBsZXQgdG90YWxObyA9IDBuO1xuICAgICAgbGV0IGZlZWRJZCA9IFwiMHgwXCI7XG4gICAgICBsZXQgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG5cbiAgICAgIC8vIFRyeSB0byBnZXQgYWRkaXRpb25hbCBkYXRhIGlmIG1ldGhvZHMgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgLy8gV3JhcCBlYWNoIGNhbGwgaW4gYSBwcm9taXNlIHRoYXQgY2F0Y2hlcyBlcnJvcnNcbiAgICAgIGNvbnN0IHNhZmVDYWxsID0gYXN5bmMgKGZuOiAoKSA9PiBQcm9taXNlPGFueT4sIGRlZmF1bHRWYWx1ZTogYW55KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIFtjdXJyZW50UHJpY2UsIGxvY2tQcmljZSwgc3RhdGUsIHRvdGFsWWVzLCB0b3RhbE5vLCBmZWVkSWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpLCAwbiksXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QubG9ja1ByaWNlKCksIDBuKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5zdGF0ZSgpLCAwKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC50b3RhbFllcygpLCAwbiksXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QudG90YWxObygpLCAwbiksXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QuZmVlZElkKCksIFwiMHgwXCIpLFxuICAgICAgICBdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiBtZXRob2RzIGRvbid0IGV4aXN0LCBkZWZhdWx0cyBhcmUgYWxyZWFkeSBzZXQgYWJvdmVcbiAgICAgICAgY29uc29sZS53YXJuKGBTb21lIG9wdGlvbmFsIG1ldGhvZHMgbm90IGF2YWlsYWJsZSBmb3IgbWFya2V0ICR7bWFya2V0QWRkcmVzc30sIHVzaW5nIGRlZmF1bHRzYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCByZXNvbHZlZC9vdXRjb21lIHRvIE1hcmtldFN0YXRlXG4gICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5SZXNvbHZlZDtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyKGRlYWRsaW5lKSA8PSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkxvY2tlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IGZlZWRJZCBieXRlczMyIHRvIHN0cmluZyBpZiBhdmFpbGFibGVcbiAgICAgIGxldCBmZWVkSWRTdHIgPSBcIlwiO1xuICAgICAgbGV0IGZlZWRJZEhleCA9IFwiMHgwXCI7XG4gICAgICBpZiAoZmVlZElkICYmIGZlZWRJZCAhPT0gXCIweDBcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZlZWRJZFN0ciA9IGV0aGVycy50b1V0ZjhTdHJpbmcoZmVlZElkKS5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG4gICAgICAgICAgZmVlZElkSGV4ID0gZmVlZElkU3RyIHx8IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGZlZWRJZEhleCA9IHR5cGVvZiBmZWVkSWQgPT09IFwic3RyaW5nXCIgPyBmZWVkSWQgOiBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldE1hcmtldCh7XG4gICAgICAgIGFkZHJlc3M6IG1hcmtldEFkZHJlc3MsXG4gICAgICAgIGZlZWRJZDogZmVlZElkSGV4LFxuICAgICAgICBjdXJyZW50UHJpY2U6IGN1cnJlbnRQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSkgOiBcIjBcIixcbiAgICAgICAgbG9ja1ByaWNlOiBsb2NrUHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpIDogXCIwXCIsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSBhcyBNYXJrZXRTdGF0ZSxcbiAgICAgICAgdG90YWxZZXM6IHRvdGFsWWVzID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxZZXMpIDogXCIwXCIsXG4gICAgICAgIHRvdGFsTm86IHRvdGFsTm8gPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSA6IFwiMFwiLFxuICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXQ6XCIsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBtYXJrZXQsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldCB9O1xufVxuXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsImV0aGVycyIsIkJyb3dzZXJQcm92aWRlciIsIkNvbnRyYWN0IiwiYXhpb3MiLCJtYXJrZXRBcnRpZmFjdCIsImdldEZhY3RvcnlDb250cmFjdCIsImdldFByb3ZpZGVyIiwiTWFya2V0U3RhdGUiLCJGQUNUT1JZX0FERFJFU1MiLCJNQVJLRVRfQUJJIiwiYWJpIiwiY2FsY3VsYXRlVHJlbmRpbmdTY29yZSIsIm1hcmtldCIsInRvdGFsWWVzIiwicGFyc2VGbG9hdCIsInRvdGFsTm8iLCJ0b3RhbExpcXVpZGl0eSIsInNjb3JlIiwic3RhdGUiLCJBY3RpdmUiLCJiYWxhbmNlIiwiTWF0aCIsIm1pbiIsIm1heCIsInVzZU1hcmtldHMiLCJtYXJrZXRzIiwic2V0TWFya2V0cyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoTWFya2V0cyIsInByb3ZpZGVyIiwiZmFjdG9yeSIsIm1hcmtldEFkZHJlc3NlcyIsImdldE1hcmtldHMiLCJjcmVhdGlvblR4TWFwIiwiTWFwIiwiY3JlYXRvckJ5TWFya2V0IiwiTUFSS0VUX0NSRUFURURfVE9QSUMiLCJpZCIsImZpbHRlciIsImFkZHJlc3MiLCJ0b3BpY3MiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibG9ncyIsImdldExvZ3MiLCJsb2ciLCJwYXJzZWQiLCJpbnRlcmZhY2UiLCJwYXJzZUxvZyIsImRhdGEiLCJwYXJzZUVyciIsImxlbmd0aCIsIm1hcmtldEFkZHJlc3MiLCJnZXRBZGRyZXNzIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsImNyZWF0b3JBZGRyZXNzIiwic2V0IiwidHJhbnNhY3Rpb25IYXNoIiwiYXJncyIsImNyZWF0b3IiLCJjb25zb2xlIiwid2FybiIsImVyciIsImJhY2tlbmRNYXJrZXRzIiwiYXBpVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsImdldCIsImJhY2tlbmRNYXBCeUFkZHJlc3MiLCJiYWNrZW5kTWFwQnlGZWVkSWQiLCJmb3JFYWNoIiwibSIsIm1hcmtldF9hZGRyZXNzIiwiYWRkckxvd2VyIiwiZmVlZF9pZCIsImZlZWRJZExvd2VyIiwic3RhcnRzV2l0aCIsIm1hcmtldFByb21pc2VzIiwibWFwIiwicHJvdmlkZXJGb3JDb250cmFjdCIsIndpbmRvdyIsImV0aGVyZXVtIiwibWFya2V0Q29udHJhY3QiLCJzYWZlQ2FsbCIsImZuIiwiZGVmYXVsdFZhbHVlIiwicXVlc3Rpb24iLCJkZWFkbGluZSIsInJlc29sdmVkIiwib3V0Y29tZSIsIlByb21pc2UiLCJhbGwiLCJjcmVhdG9yRnJvbUNvbnRyYWN0IiwiY3VycmVudFByaWNlIiwibG9ja1ByaWNlIiwiZmVlZElkIiwiZ2V0Q3VycmVudFByaWNlIiwiUmVzb2x2ZWQiLCJOdW1iZXIiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJMb2NrZWQiLCJmZWVkSWRTdHIiLCJmZWVkSWRIZXgiLCJ0b1V0ZjhTdHJpbmciLCJyZXBsYWNlIiwiaGV4bGlmeSIsImFkZHJlc3NMb3dlciIsImJhY2tlbmRNYXJrZXQiLCJmZWVkSWROb1ByZWZpeCIsImNyZWF0aW9uVHhIYXNoIiwiY3JlYXRvcl9hZGRyZXNzIiwiaW1hZ2VVcmwiLCJpbWFnZV91cmwiLCJzdWJzdHJpbmciLCJkaXNwbGF5UXVlc3Rpb24iLCJkaXNwbGF5Q2F0ZWdvcnkiLCJjYXRlZ29yeSIsIm1hcmtldERhdGEiLCJmb3JtYXRFdGhlciIsImRlc2NyaXB0aW9uIiwiY3JlYXRlZEF0IiwiY3JlYXRlZF9hdCIsIm1hcmtldElkIiwibWFya2V0X2lkIiwidW5kZWZpbmVkIiwiYmFzaWNDb250cmFjdCIsInF1ZXN0aW9uRXJyIiwibWFya2V0c05lZWRpbmdDcmVhdG9ycyIsIm1hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMiLCJleGlzdHMiLCJzb21lIiwicG9zdCIsImR1cmF0aW9uIiwicmVzb2x1dGlvbkRlbGF5Iiwib3JhY2xlVHlwZSIsImRlYnVnIiwiY2F0Y2giLCJ2YWxpZE1hcmtldHMiLCJ0ZXN0IiwibWFya2V0c1dpdGhDcmVhdG9ycyIsIm1hcmtldHNXaXRoVHJlbmRpbmciLCJ0cmVuZGluZ1Njb3JlIiwiaGFzSW1hZ2UiLCJtZXNzYWdlIiwicmVmZXRjaCIsInVzZU1hcmtldCIsInNldE1hcmtldCIsImZldGNoTWFya2V0IiwiYmFzZVByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});