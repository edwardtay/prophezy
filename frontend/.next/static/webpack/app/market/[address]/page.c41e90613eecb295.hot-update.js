"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/market/[address]/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory (ONLY on-chain markets - no mocks)\n            const marketAddresses = await factory.getMarkets();\n            // Single getLogs call for all MarketCreated events (more efficient, avoids rate limits)\n            const creationTxMap = new Map();\n            const creatorByMarket = {};\n            try {\n                // Query all MarketCreated events from the factory contract in one call\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const MARKET_CREATED_TOPIC = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                // Use a reasonable fromBlock - you can adjust this or use deployment block\n                // For now, query from block 0 (or use a known deployment block if available)\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        MARKET_CREATED_TOPIC\n                    ],\n                    fromBlock: 0,\n                    toBlock: \"latest\"\n                };\n                const logs = await provider.getLogs(filter);\n                console.log(\"[useMarkets] Found \".concat(logs.length, \" MarketCreated events in single getLogs call\"));\n                // Build map: marketAddress -> creator (and also store tx hash)\n                for (const log of logs){\n                    try {\n                        // Parse the event log\n                        let parsed = null;\n                        try {\n                            parsed = factory.interface.parseLog({\n                                topics: log.topics,\n                                data: log.data\n                            });\n                        } catch (parseErr) {\n                            // Fallback: extract directly from topics if parsing fails\n                            if (log.topics && log.topics.length >= 3) {\n                                const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                                const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26)).toLowerCase();\n                                creatorByMarket[marketAddress] = creatorAddress;\n                                creationTxMap.set(marketAddress, log.transactionHash);\n                                continue;\n                            }\n                        }\n                        if (parsed && parsed.args) {\n                            var _parsed_args_market, _parsed_args_, _parsed_args_creator, _parsed_args_1;\n                            const market = ((_parsed_args_market = parsed.args.market) === null || _parsed_args_market === void 0 ? void 0 : _parsed_args_market.toLowerCase()) || ((_parsed_args_ = parsed.args[0]) === null || _parsed_args_ === void 0 ? void 0 : _parsed_args_.toLowerCase());\n                            const creator = ((_parsed_args_creator = parsed.args.creator) === null || _parsed_args_creator === void 0 ? void 0 : _parsed_args_creator.toLowerCase()) || ((_parsed_args_1 = parsed.args[1]) === null || _parsed_args_1 === void 0 ? void 0 : _parsed_args_1.toLowerCase());\n                            if (market && creator) {\n                                creatorByMarket[market] = creator;\n                                creationTxMap.set(market, log.transactionHash);\n                            }\n                        }\n                    } catch (parseErr) {\n                        console.warn(\"[useMarkets] Error parsing log \".concat(log.transactionHash, \":\"), parseErr);\n                    }\n                }\n                console.log(\"[useMarkets] Built creator map with \".concat(Object.keys(creatorByMarket).length, \" entries from single getLogs call\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API (ONLY for enriching on-chain markets with metadata - not for displaying)\n            // Backend markets are matched to on-chain markets by market_address\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" backend metadata entries (for enrichment only, not displayed separately)\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market using new ABI\n            const marketPromises = marketAddresses.map(async (address)=>{\n                // Use BrowserProvider and Contract directly with new ABI\n                let providerForContract;\n                if ( true && window.ethereum) {\n                    providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n                } else {\n                    providerForContract = provider;\n                }\n                const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                try {\n                    var _marketAddresses_;\n                    // Wrap each call in a promise that catches errors\n                    const safeCall = async (fn, defaultValue)=>{\n                        try {\n                            return await fn();\n                        } catch (e) {\n                            return defaultValue;\n                        }\n                    };\n                    // Use new ABI methods: question, deadline, resolved, outcome\n                    // Also try to read creator directly from contract if available\n                    const [question, deadline, resolved, outcome] = await Promise.all([\n                        marketContract.question(),\n                        marketContract.deadline(),\n                        marketContract.resolved(),\n                        marketContract.outcome()\n                    ]);\n                    // Try to read creator directly from contract (simplest method)\n                    let creatorFromContract = null;\n                    try {\n                        creatorFromContract = await marketContract.creator();\n                    } catch (err) {\n                        // Contract might not have creator() function, that's okay\n                        console.debug(\"[useMarkets] Market \".concat(address, \" does not have creator() function\"));\n                    }\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    let currentPrice = 0n;\n                    let lockPrice = 0n;\n                    let totalYes = 0n;\n                    let totalNo = 0n;\n                    let feedId = \"0x0\";\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    try {\n                        [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                            safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                            safeCall(()=>marketContract.lockPrice(), 0n),\n                            safeCall(()=>marketContract.state(), 0),\n                            safeCall(()=>marketContract.totalYes(), 0n),\n                            safeCall(()=>marketContract.totalNo(), 0n),\n                            safeCall(()=>marketContract.feedId(), \"0x0\")\n                        ]);\n                    } catch (err) {\n                        // If methods don't exist, defaults are already set above\n                        console.warn(\"Some optional methods not available for market \".concat(address, \", using defaults\"));\n                    }\n                    // Map resolved/outcome to MarketState\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    } else {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes) if it's a bytes32\n                    let feedIdStr = \"\";\n                    let feedIdHex = \"0x0\";\n                    if (feedId && feedId !== \"0x0\") {\n                        try {\n                            feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                            feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        } catch (e) {\n                            feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        }\n                    }\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    // Priority 1: Read creator directly from contract (simplest and most reliable)\n                    let creatorAddress = creatorFromContract ? creatorFromContract.toLowerCase() : null;\n                    // Priority 2: Use creator from event map (from single getLogs call)\n                    if (!creatorAddress) {\n                        creatorAddress = creatorByMarket[addressLower] || null;\n                    }\n                    // Priority 3: Use backend creator_address\n                    if (!creatorAddress && (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.creator_address)) {\n                        creatorAddress = backendMarket.creator_address.toLowerCase();\n                        console.log(\"[useMarkets] Using creator from backend: \".concat(creatorAddress, \" for market \").concat(address));\n                    }\n                    if (creatorAddress) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" creator: \").concat(creatorAddress, \" (from \").concat(creatorFromContract ? \"contract\" : creatorByMarket[addressLower] ? \"events\" : \"backend\", \")\"));\n                    }\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    // Ensure we always have a question - prioritize contract, then backend, then fallback\n                    const displayQuestion = question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question) || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6));\n                    // Category: use backend if available, otherwise try to infer or use \"Other\"\n                    const displayCategory = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category) || \"Other\";\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                        lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                        state: state,\n                        totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                        totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                        // Use question from contract first (most reliable), fallback to backend, then generic\n                        question: displayQuestion,\n                        category: displayCategory,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress,\n                        createdAt: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.created_at) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.createdAt),\n                        // Include backend market_id for API calls (MarketInfo, MarketChat)\n                        marketId: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.market_id) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.id) || undefined\n                    };\n                    // Log if market is missing backend metadata\n                    if (!backendMarket) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" is on-chain but missing backend metadata. Using contract data only.\"));\n                    }\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least basic data using new ABI if other calls fail\n                    let question = \"\";\n                    let deadline = 0;\n                    let resolved = false;\n                    let outcome = 0n;\n                    try {\n                        const basicContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                        [question, deadline, resolved, outcome] = await Promise.all([\n                            basicContract.question(),\n                            basicContract.deadline(),\n                            basicContract.resolved(),\n                            basicContract.outcome()\n                        ]);\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch basic data for market \".concat(address, \":\"), questionErr);\n                    }\n                    // Determine state from resolved/deadline\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (deadline > 0 && deadline <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: state,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // No need for batch fetching - we already have creators from the single getLogs call\n            // Just check if any markets are still missing creators (shouldn't happen if events were parsed correctly)\n            const marketsNeedingCreators = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.creatorAddress);\n            if (marketsNeedingCreators.length > 0) {\n                console.warn(\"[useMarkets] \".concat(marketsNeedingCreators.length, \" markets still missing creators after event parsing. This shouldn't happen if events were parsed correctly.\"));\n            }\n            // Auto-sync: Create backend entries for on-chain markets missing backend metadata\n            // This ensures all markets have complete data\n            const marketsNeedingBackendSync = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.marketId && // No backend ID means no backend entry\n                m.question && // Has question from contract\n                m.question !== \"Market \".concat(m.address.slice(0, 8), \"...\").concat(m.address.slice(-6)) // Not just fallback\n            );\n            if (marketsNeedingBackendSync.length > 0) {\n                console.log(\"[useMarkets] \".concat(marketsNeedingBackendSync.length, \" on-chain markets missing backend metadata. Auto-syncing...\"));\n                // Try to create backend entries for these markets (non-blocking)\n                Promise.all(marketsNeedingBackendSync.map(async (market)=>{\n                    try {\n                        const apiUrl = \"http://localhost:3001\" || 0;\n                        // Check if backend entry already exists\n                        const backendMarkets = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                        const exists = backendMarkets.data.some((m)=>{\n                            var _m_market_address;\n                            return ((_m_market_address = m.market_address) === null || _m_market_address === void 0 ? void 0 : _m_market_address.toLowerCase()) === market.address.toLowerCase();\n                        });\n                        if (!exists && market.question && market.creatorAddress) {\n                            // Create backend entry with contract data\n                            await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].post(\"\".concat(apiUrl, \"/api/markets\"), {\n                                question: market.question,\n                                category: market.category || \"Other\",\n                                duration: 7 * 24 * 60 * 60,\n                                resolutionDelay: 24 * 60 * 60,\n                                imageUrl: market.imageUrl || null,\n                                oracleType: \"chainlink\",\n                                creatorAddress: market.creatorAddress,\n                                marketAddress: market.address\n                            });\n                            console.log(\"[useMarkets] Auto-created backend entry for market \".concat(market.address));\n                        }\n                    } catch (err) {\n                        // Silently fail - this is just a sync attempt\n                        console.debug(\"[useMarkets] Could not auto-sync market \".concat(market.address, \":\"), err);\n                    }\n                })).catch(()=>{\n                // Ignore errors - this is best effort\n                });\n            }\n            // Filter out markets with empty/invalid addresses - only show real on-chain markets\n            const validMarkets = marketData.filter((m)=>{\n                // Must have a valid address\n                if (!m.address || m.address === \"0x0000000000000000000000000000000000000000\") {\n                    return false;\n                }\n                // Must be a valid Ethereum address format\n                if (!/^0x[a-fA-F0-9]{40}$/.test(m.address)) {\n                    return false;\n                }\n                // Must have been fetched from factory (exists in marketAddresses)\n                return true;\n            });\n            const marketsWithCreators = validMarkets.filter((m)=>m.creatorAddress).length;\n            console.log(\"[useMarkets] Valid on-chain markets: \".concat(validMarkets.length, \", Markets with creators: \").concat(marketsWithCreators));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            // Use BrowserProvider and Contract directly with new ABI\n            let providerForContract;\n            if ( true && window.ethereum) {\n                providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n            } else {\n                const baseProvider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n                providerForContract = baseProvider;\n            }\n            const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(marketAddress, MARKET_ABI, providerForContract);\n            // Use new ABI methods: question, deadline, resolved, outcome\n            const [question, deadline, resolved, outcome] = await Promise.all([\n                marketContract.question(),\n                marketContract.deadline(),\n                marketContract.resolved(),\n                marketContract.outcome()\n            ]);\n            // Try to get additional data if methods exist (for backward compatibility)\n            let currentPrice = 0n;\n            let lockPrice = 0n;\n            let totalYes = 0n;\n            let totalNo = 0n;\n            let feedId = \"0x0\";\n            let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            // Try to get additional data if methods exist (for backward compatibility)\n            // Wrap each call in a promise that catches errors\n            const safeCall = async (fn, defaultValue)=>{\n                try {\n                    return await fn();\n                } catch (e) {\n                    return defaultValue;\n                }\n            };\n            try {\n                [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                    safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                    safeCall(()=>marketContract.lockPrice(), 0n),\n                    safeCall(()=>marketContract.state(), 0),\n                    safeCall(()=>marketContract.totalYes(), 0n),\n                    safeCall(()=>marketContract.totalNo(), 0n),\n                    safeCall(()=>marketContract.feedId(), \"0x0\")\n                ]);\n            } catch (err) {\n                // If methods don't exist, defaults are already set above\n                console.warn(\"Some optional methods not available for market \".concat(marketAddress, \", using defaults\"));\n            }\n            // Map resolved/outcome to MarketState\n            if (resolved) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n            } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n            } else {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            }\n            // Convert feedId bytes32 to string if available\n            let feedIdStr = \"\";\n            let feedIdHex = \"0x0\";\n            if (feedId && feedId !== \"0x0\") {\n                try {\n                    feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                } catch (e) {\n                    feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                }\n            }\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdHex,\n                currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                state: state,\n                totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0U7QUFDakM7QUFDK0I7QUFPL0I7QUFFMUIsTUFBTVksYUFBYUwsMkRBQWtCO0FBRXJDOztDQUVDLEdBQ0QsU0FBU08sdUJBQXVCQyxNQUFrQjtJQUNoRCxNQUFNQyxXQUFXQyxXQUFXRixPQUFPQyxRQUFRO0lBQzNDLE1BQU1FLFVBQVVELFdBQVdGLE9BQU9HLE9BQU87SUFDekMsTUFBTUMsaUJBQWlCSCxXQUFXRTtJQUVsQyxxQ0FBcUM7SUFDckMsSUFBSUUsUUFBUUQ7SUFFWiwyQkFBMkI7SUFDM0IsSUFBSUosT0FBT00sS0FBSyxLQUFLWCx1REFBV0EsQ0FBQ1ksTUFBTSxFQUFFO1FBQ3ZDRixTQUFTO0lBQ1g7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTUksVUFBVUMsS0FBS0MsR0FBRyxDQUFDVCxVQUFVRSxXQUFXTSxLQUFLRSxHQUFHLENBQUNWLFVBQVVFO1FBQ2pFRSxTQUFVLElBQUlHLFVBQVUsS0FBTSx1Q0FBdUM7SUFDdkU7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTTztJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQWUsRUFBRTtJQUN2RCxNQUFNLENBQUM4QixTQUFTQyxXQUFXLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWtDLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQixJQUFJO1lBQ0Y2QixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxNQUFNRSxXQUFXMUIsMkRBQVdBO1lBQzVCLE1BQU0yQixVQUFVNUIsa0VBQWtCQSxDQUFDMkI7WUFFbkMsMkVBQTJFO1lBQzNFLE1BQU1FLGtCQUE0QixNQUFNRCxRQUFRRSxV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QyxPQUFPO29CQUN2REYsWUFBWUQsYUFBYWhILDJDQUFjLENBQUN3RztnQkFDMUMsRUFBRSxVQUFNO29CQUNOUyxZQUFZLE9BQU9ULFdBQVcsV0FBV0EsU0FBU3hHLDJDQUFjLENBQUN3RztnQkFDbkU7WUFDRjtZQUVBb0QsVUFBVTtnQkFDUmxILFNBQVNjO2dCQUNUZ0QsUUFBUVM7Z0JBQ1JYLGNBQWNBLGVBQWUsRUFBRSxHQUFHdEcsZ0RBQWtCLENBQUNzRyxnQkFBZ0I7Z0JBQ3JFQyxXQUFXQSxZQUFZLEVBQUUsR0FBR3ZHLGdEQUFrQixDQUFDdUcsYUFBYTtnQkFDNURyRixPQUFPQTtnQkFDUEwsVUFBVUEsV0FBVyxFQUFFLEdBQUdiLGdEQUFrQixDQUFDYSxZQUFZO2dCQUN6REUsU0FBU0EsVUFBVSxFQUFFLEdBQUdmLGdEQUFrQixDQUFDZSxXQUFXO2dCQUN0RCtFLFVBQVVBO1lBQ1o7UUFDRixFQUFFLE9BQU8xQixLQUFVO1lBQ2pCcEIsUUFBUW5CLEtBQUssQ0FBQywyQkFBMkJ1QztZQUN6Q3RDLFNBQVNzQyxJQUFJcUYsT0FBTyxJQUFJO1FBQzFCLFNBQVU7WUFDUjdILFdBQVc7UUFDYjtJQUNGO0lBRUEsT0FBTztRQUFFaEI7UUFBUWU7UUFBU0U7UUFBTzZILFNBQVNHO0lBQVk7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU1hcmtldHMudHM/ZDNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZXRoZXJzLCBCcm93c2VyUHJvdmlkZXIsIENvbnRyYWN0IH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IG1hcmtldEFydGlmYWN0IGZyb20gXCJAL2FiaS9QcmVkaWN0aW9uTWFya2V0Lmpzb25cIjtcbmltcG9ydCB7XG4gIGdldEZhY3RvcnlDb250cmFjdCxcbiAgZ2V0UHJvdmlkZXIsXG4gIE1hcmtldERhdGEsXG4gIE1hcmtldFN0YXRlLFxuICBGQUNUT1JZX0FERFJFU1MsXG59IGZyb20gXCIuLi9saWIvY29udHJhY3RzXCI7XG5cbmNvbnN0IE1BUktFVF9BQkkgPSBtYXJrZXRBcnRpZmFjdC5hYmk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRyZW5kaW5nIHNjb3JlIGJhc2VkIG9uIGxpcXVpZGl0eSBhbmQgYWN0aXZpdHlcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlVHJlbmRpbmdTY29yZShtYXJrZXQ6IE1hcmtldERhdGEpOiBudW1iZXIge1xuICBjb25zdCB0b3RhbFllcyA9IHBhcnNlRmxvYXQobWFya2V0LnRvdGFsWWVzKTtcbiAgY29uc3QgdG90YWxObyA9IHBhcnNlRmxvYXQobWFya2V0LnRvdGFsTm8pO1xuICBjb25zdCB0b3RhbExpcXVpZGl0eSA9IHRvdGFsWWVzICsgdG90YWxObztcbiAgXG4gIC8vIEJhc2Ugc2NvcmUgZnJvbSBsaXF1aWRpdHkgKHZvbHVtZSlcbiAgbGV0IHNjb3JlID0gdG90YWxMaXF1aWRpdHk7XG4gIFxuICAvLyBCb29zdCBmb3IgYWN0aXZlIG1hcmtldHNcbiAgaWYgKG1hcmtldC5zdGF0ZSA9PT0gTWFya2V0U3RhdGUuQWN0aXZlKSB7XG4gICAgc2NvcmUgKj0gMS4yO1xuICB9XG4gIFxuICAvLyBCb29zdCBmb3IgbWFya2V0cyB3aXRoIGJhbGFuY2VkIGxpcXVpZGl0eSAobW9yZSBpbnRlcmVzdGluZylcbiAgaWYgKHRvdGFsTGlxdWlkaXR5ID4gMCkge1xuICAgIGNvbnN0IGJhbGFuY2UgPSBNYXRoLm1pbih0b3RhbFllcywgdG90YWxObykgLyBNYXRoLm1heCh0b3RhbFllcywgdG90YWxObyk7XG4gICAgc2NvcmUgKj0gKDEgKyBiYWxhbmNlICogMC4zKTsgLy8gVXAgdG8gMzAlIGJvb3N0IGZvciBiYWxhbmNlZCBtYXJrZXRzXG4gIH1cbiAgXG4gIHJldHVybiBzY29yZTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGZldGNoIGFsbCBtYXJrZXRzIGZyb20gdGhlIGZhY3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcmtldHMoKSB7XG4gIGNvbnN0IFttYXJrZXRzLCBzZXRNYXJrZXRzXSA9IHVzZVN0YXRlPE1hcmtldERhdGFbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBmZXRjaE1hcmtldHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgZmFjdG9yeSA9IGdldEZhY3RvcnlDb250cmFjdChwcm92aWRlcik7XG5cbiAgICAgIC8vIEdldCBhbGwgbWFya2V0IGFkZHJlc3NlcyBmcm9tIGZhY3RvcnkgKE9OTFkgb24tY2hhaW4gbWFya2V0cyAtIG5vIG1vY2tzKVxuICAgICAgY29uc3QgbWFya2V0QWRkcmVzc2VzOiBzdHJpbmdbXSA9IGF3YWl0IGZhY3RvcnkuZ2V0TWFya2V0cygpO1xuICAgICAgXG4gICAgICAvLyBTaW5nbGUgZ2V0TG9ncyBjYWxsIGZvciBhbGwgTWFya2V0Q3JlYXRlZCBldmVudHMgKG1vcmUgZWZmaWNpZW50LCBhdm9pZHMgcmF0ZSBsaW1pdHMpXG4gICAgICBjb25zdCBjcmVhdGlvblR4TWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgIGNvbnN0IGNyZWF0b3JCeU1hcmtldDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUXVlcnkgYWxsIE1hcmtldENyZWF0ZWQgZXZlbnRzIGZyb20gdGhlIGZhY3RvcnkgY29udHJhY3QgaW4gb25lIGNhbGxcbiAgICAgICAgLy8gRXZlbnQgc2lnbmF0dXJlOiBNYXJrZXRDcmVhdGVkKGFkZHJlc3MgaW5kZXhlZCBtYXJrZXQsIGFkZHJlc3MgaW5kZXhlZCBjcmVhdG9yLCBhZGRyZXNzIGluZGV4ZWQgZmVlZEFkZHJlc3MpXG4gICAgICAgIGNvbnN0IE1BUktFVF9DUkVBVEVEX1RPUElDID0gZXRoZXJzLmlkKFwiTWFya2V0Q3JlYXRlZChhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcylcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgYSByZWFzb25hYmxlIGZyb21CbG9jayAtIHlvdSBjYW4gYWRqdXN0IHRoaXMgb3IgdXNlIGRlcGxveW1lbnQgYmxvY2tcbiAgICAgICAgLy8gRm9yIG5vdywgcXVlcnkgZnJvbSBibG9jayAwIChvciB1c2UgYSBrbm93biBkZXBsb3ltZW50IGJsb2NrIGlmIGF2YWlsYWJsZSlcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgIGFkZHJlc3M6IEZBQ1RPUllfQUREUkVTUyxcbiAgICAgICAgICB0b3BpY3M6IFtNQVJLRVRfQ1JFQVRFRF9UT1BJQ10sXG4gICAgICAgICAgZnJvbUJsb2NrOiAwLCAvLyBTdGFydCBmcm9tIGJlZ2lubmluZywgb3IgdXNlIGRlcGxveW1lbnQgYmxvY2sgaWYga25vd25cbiAgICAgICAgICB0b0Jsb2NrOiBcImxhdGVzdFwiLFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke2xvZ3MubGVuZ3RofSBNYXJrZXRDcmVhdGVkIGV2ZW50cyBpbiBzaW5nbGUgZ2V0TG9ncyBjYWxsYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBCdWlsZCBtYXA6IG1hcmtldEFkZHJlc3MgLT4gY3JlYXRvciAoYW5kIGFsc28gc3RvcmUgdHggaGFzaClcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXZlbnQgbG9nXG4gICAgICAgICAgICBsZXQgcGFyc2VkOiBhbnkgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gZmFjdG9yeS5pbnRlcmZhY2UucGFyc2VMb2coe1xuICAgICAgICAgICAgICAgIHRvcGljczogbG9nLnRvcGljcyxcbiAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycikge1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjazogZXh0cmFjdCBkaXJlY3RseSBmcm9tIHRvcGljcyBpZiBwYXJzaW5nIGZhaWxzXG4gICAgICAgICAgICAgIGlmIChsb2cudG9waWNzICYmIGxvZy50b3BpY3MubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1sxXS5zbGljZSgyNikpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRvckFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzJdLnNsaWNlKDI2KSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjcmVhdG9yQnlNYXJrZXRbbWFya2V0QWRkcmVzc10gPSBjcmVhdG9yQWRkcmVzcztcbiAgICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGFyc2VkICYmIHBhcnNlZC5hcmdzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtldCA9IHBhcnNlZC5hcmdzLm1hcmtldD8udG9Mb3dlckNhc2UoKSB8fCBwYXJzZWQuYXJnc1swXT8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgY29uc3QgY3JlYXRvciA9IHBhcnNlZC5hcmdzLmNyZWF0b3I/LnRvTG93ZXJDYXNlKCkgfHwgcGFyc2VkLmFyZ3NbMV0/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAobWFya2V0ICYmIGNyZWF0b3IpIHtcbiAgICAgICAgICAgICAgICBjcmVhdG9yQnlNYXJrZXRbbWFya2V0XSA9IGNyZWF0b3I7XG4gICAgICAgICAgICAgICAgY3JlYXRpb25UeE1hcC5zZXQobWFya2V0LCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt1c2VNYXJrZXRzXSBFcnJvciBwYXJzaW5nIGxvZyAke2xvZy50cmFuc2FjdGlvbkhhc2h9OmAsIHBhcnNlRXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gQnVpbHQgY3JlYXRvciBtYXAgd2l0aCAke09iamVjdC5rZXlzKGNyZWF0b3JCeU1hcmtldCkubGVuZ3RofSBlbnRyaWVzIGZyb20gc2luZ2xlIGdldExvZ3MgY2FsbGApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBNYXJrZXRDcmVhdGVkIGV2ZW50czpcIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHttYXJrZXRBZGRyZXNzZXMubGVuZ3RofSBtYXJrZXRzIGZyb20gZmFjdG9yeTpgLCBtYXJrZXRBZGRyZXNzZXMpO1xuXG4gICAgICAvLyBGZXRjaCBtZXRhZGF0YSBmcm9tIGJhY2tlbmQgQVBJIChPTkxZIGZvciBlbnJpY2hpbmcgb24tY2hhaW4gbWFya2V0cyB3aXRoIG1ldGFkYXRhIC0gbm90IGZvciBkaXNwbGF5aW5nKVxuICAgICAgLy8gQmFja2VuZCBtYXJrZXRzIGFyZSBtYXRjaGVkIHRvIG9uLWNoYWluIG1hcmtldHMgYnkgbWFya2V0X2FkZHJlc3NcbiAgICAgIGxldCBiYWNrZW5kTWFya2V0czogYW55W10gPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjMwMDFcIjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2ApO1xuICAgICAgICBiYWNrZW5kTWFya2V0cyA9IHJlc3BvbnNlLmRhdGEgfHwgW107XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHtiYWNrZW5kTWFya2V0cy5sZW5ndGh9IGJhY2tlbmQgbWV0YWRhdGEgZW50cmllcyAoZm9yIGVucmljaG1lbnQgb25seSwgbm90IGRpc3BsYXllZCBzZXBhcmF0ZWx5KWApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXQgbWV0YWRhdGEgZnJvbSBiYWNrZW5kOlwiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgYmFja2VuZCBtYXJrZXRzIGJ5IG1hcmtldF9hZGRyZXNzIChwcmltYXJ5KSBhbmQgZmVlZElkIChmYWxsYmFjaykgZm9yIHF1aWNrIGxvb2t1cFxuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5QWRkcmVzcyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICBjb25zdCBiYWNrZW5kTWFwQnlGZWVkSWQgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgYmFja2VuZE1hcmtldHMuZm9yRWFjaCgobTogYW55KSA9PiB7XG4gICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldF9hZGRyZXNzIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5tYXJrZXRfYWRkcmVzcykge1xuICAgICAgICAgIGNvbnN0IGFkZHJMb3dlciA9IG0ubWFya2V0X2FkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlBZGRyZXNzLnNldChhZGRyTG93ZXIsIG0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrOiBtYXRjaCBieSBmZWVkSWQgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtLmZlZWRfaWQpIHtcbiAgICAgICAgICBjb25zdCBmZWVkSWRMb3dlciA9IG0uZmVlZF9pZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIsIG0pO1xuICAgICAgICAgIC8vIEFsc28gdHJ5IHdpdGhvdXQgMHggcHJlZml4IGlmIHByZXNlbnRcbiAgICAgICAgICBpZiAoZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLnNldChmZWVkSWRMb3dlci5zbGljZSgyKSwgbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRmV0Y2ggZGF0YSBmb3IgZWFjaCBtYXJrZXQgdXNpbmcgbmV3IEFCSVxuICAgICAgY29uc3QgbWFya2V0UHJvbWlzZXMgPSBtYXJrZXRBZGRyZXNzZXMubWFwKGFzeW5jIChhZGRyZXNzKSA9PiB7XG4gICAgICAgIC8vIFVzZSBCcm93c2VyUHJvdmlkZXIgYW5kIENvbnRyYWN0IGRpcmVjdGx5IHdpdGggbmV3IEFCSVxuICAgICAgICBsZXQgcHJvdmlkZXJGb3JDb250cmFjdDogQnJvd3NlclByb3ZpZGVyO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBwcm92aWRlciBhcyBhbnkgYXMgQnJvd3NlclByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIE1BUktFVF9BQkksIHByb3ZpZGVyRm9yQ29udHJhY3QpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gV3JhcCBlYWNoIGNhbGwgaW4gYSBwcm9taXNlIHRoYXQgY2F0Y2hlcyBlcnJvcnNcbiAgICAgICAgICBjb25zdCBzYWZlQ2FsbCA9IGFzeW5jIChmbjogKCkgPT4gUHJvbWlzZTxhbnk+LCBkZWZhdWx0VmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVzZSBuZXcgQUJJIG1ldGhvZHM6IHF1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVcbiAgICAgICAgICAvLyBBbHNvIHRyeSB0byByZWFkIGNyZWF0b3IgZGlyZWN0bHkgZnJvbSBjb250cmFjdCBpZiBhdmFpbGFibGVcbiAgICAgICAgICBjb25zdCBbcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICAgICAgbWFya2V0Q29udHJhY3QuZGVhZGxpbmUoKSxcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LnJlc29sdmVkKCksXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5vdXRjb21lKCksIC8vIGVudW06IDAsMSwyXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHJlYWQgY3JlYXRvciBkaXJlY3RseSBmcm9tIGNvbnRyYWN0IChzaW1wbGVzdCBtZXRob2QpXG4gICAgICAgICAgbGV0IGNyZWF0b3JGcm9tQ29udHJhY3Q6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjcmVhdG9yRnJvbUNvbnRyYWN0ID0gYXdhaXQgbWFya2V0Q29udHJhY3QuY3JlYXRvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQ29udHJhY3QgbWlnaHQgbm90IGhhdmUgY3JlYXRvcigpIGZ1bmN0aW9uLCB0aGF0J3Mgb2theVxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW3VzZU1hcmtldHNdIE1hcmtldCAke2FkZHJlc3N9IGRvZXMgbm90IGhhdmUgY3JlYXRvcigpIGZ1bmN0aW9uYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICAgICAgbGV0IGN1cnJlbnRQcmljZSA9IDBuO1xuICAgICAgICAgIGxldCBsb2NrUHJpY2UgPSAwbjtcbiAgICAgICAgICBsZXQgdG90YWxZZXMgPSAwbjtcbiAgICAgICAgICBsZXQgdG90YWxObyA9IDBuO1xuICAgICAgICAgIGxldCBmZWVkSWQgPSBcIjB4MFwiO1xuICAgICAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QuZ2V0Q3VycmVudFByaWNlKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QubG9ja1ByaWNlKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3Quc3RhdGUoKSwgMCksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsWWVzKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QudG90YWxObygpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLCBcIjB4MFwiKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgbWV0aG9kcyBkb24ndCBleGlzdCwgZGVmYXVsdHMgYXJlIGFscmVhZHkgc2V0IGFib3ZlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNvbWUgb3B0aW9uYWwgbWV0aG9kcyBub3QgYXZhaWxhYmxlIGZvciBtYXJrZXQgJHthZGRyZXNzfSwgdXNpbmcgZGVmYXVsdHNgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNYXAgcmVzb2x2ZWQvb3V0Y29tZSB0byBNYXJrZXRTdGF0ZVxuICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5SZXNvbHZlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKE51bWJlcihkZWFkbGluZSkgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuTG9ja2VkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IGZlZWRJZCBieXRlczMyIHRvIHN0cmluZyAocmVtb3ZlIG51bGwgYnl0ZXMpIGlmIGl0J3MgYSBieXRlczMyXG4gICAgICAgICAgbGV0IGZlZWRJZFN0ciA9IFwiXCI7XG4gICAgICAgICAgbGV0IGZlZWRJZEhleCA9IFwiMHgwXCI7XG4gICAgICAgICAgaWYgKGZlZWRJZCAmJiBmZWVkSWQgIT09IFwiMHgwXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZlZWRJZFN0ciA9IGV0aGVycy50b1V0ZjhTdHJpbmcoZmVlZElkKS5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG4gICAgICAgICAgICAgIGZlZWRJZEhleCA9IGZlZWRJZFN0ciB8fCBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIGZlZWRJZEhleCA9IHR5cGVvZiBmZWVkSWQgPT09IFwic3RyaW5nXCIgPyBmZWVkSWQgOiBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBtYXRjaGluZyBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAgICAgLy8gUHJpbWFyeTogbWF0Y2ggYnkgbWFya2V0IGFkZHJlc3MgKG1vc3QgcmVsaWFibGUpXG4gICAgICAgICAgY29uc3QgYWRkcmVzc0xvd2VyID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxldCBiYWNrZW5kTWFya2V0ID0gYmFja2VuZE1hcEJ5QWRkcmVzcy5nZXQoYWRkcmVzc0xvd2VyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGYWxsYmFjazogbWF0Y2ggYnkgZmVlZElkIGlmIGFkZHJlc3MgbWF0Y2ggZmFpbGVkXG4gICAgICAgICAgaWYgKCFiYWNrZW5kTWFya2V0KSB7XG4gICAgICAgICAgICBjb25zdCBmZWVkSWRMb3dlciA9IGZlZWRJZEhleC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZmVlZElkTm9QcmVmaXggPSBmZWVkSWRMb3dlci5zdGFydHNXaXRoKCcweCcpID8gZmVlZElkTG93ZXIuc2xpY2UoMikgOiBmZWVkSWRMb3dlcjtcbiAgICAgICAgICAgIGJhY2tlbmRNYXJrZXQgPSBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZExvd2VyKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkTm9QcmVmaXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZFN0ci50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjcmVhdGlvblR4SGFzaCA9IGNyZWF0aW9uVHhNYXAuZ2V0KGFkZHJlc3NMb3dlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJpb3JpdHkgMTogUmVhZCBjcmVhdG9yIGRpcmVjdGx5IGZyb20gY29udHJhY3QgKHNpbXBsZXN0IGFuZCBtb3N0IHJlbGlhYmxlKVxuICAgICAgICAgIGxldCBjcmVhdG9yQWRkcmVzcyA9IGNyZWF0b3JGcm9tQ29udHJhY3QgPyBjcmVhdG9yRnJvbUNvbnRyYWN0LnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByaW9yaXR5IDI6IFVzZSBjcmVhdG9yIGZyb20gZXZlbnQgbWFwIChmcm9tIHNpbmdsZSBnZXRMb2dzIGNhbGwpXG4gICAgICAgICAgaWYgKCFjcmVhdG9yQWRkcmVzcykge1xuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3MgPSBjcmVhdG9yQnlNYXJrZXRbYWRkcmVzc0xvd2VyXSB8fCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcmlvcml0eSAzOiBVc2UgYmFja2VuZCBjcmVhdG9yX2FkZHJlc3NcbiAgICAgICAgICBpZiAoIWNyZWF0b3JBZGRyZXNzICYmIGJhY2tlbmRNYXJrZXQ/LmNyZWF0b3JfYWRkcmVzcykge1xuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3MgPSBiYWNrZW5kTWFya2V0LmNyZWF0b3JfYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBVc2luZyBjcmVhdG9yIGZyb20gYmFja2VuZDogJHtjcmVhdG9yQWRkcmVzc30gZm9yIG1hcmtldCAke2FkZHJlc3N9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjcmVhdG9yQWRkcmVzcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBNYXJrZXQgJHthZGRyZXNzfSBjcmVhdG9yOiAke2NyZWF0b3JBZGRyZXNzfSAoZnJvbSAke2NyZWF0b3JGcm9tQ29udHJhY3QgPyAnY29udHJhY3QnIDogY3JlYXRvckJ5TWFya2V0W2FkZHJlc3NMb3dlcl0gPyAnZXZlbnRzJyA6ICdiYWNrZW5kJ30pYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXh0cmFjdCBpbWFnZVVybCBmcm9tIGJhY2tlbmQgbWFya2V0IChzdXBwb3J0IGJvdGggc25ha2VfY2FzZSBhbmQgY2FtZWxDYXNlKVxuICAgICAgICAgIGNvbnN0IGltYWdlVXJsID0gYmFja2VuZE1hcmtldD8uaW1hZ2VfdXJsIHx8IGJhY2tlbmRNYXJrZXQ/LmltYWdlVXJsIHx8IG51bGw7XG4gICAgICAgICAgaWYgKGltYWdlVXJsICYmIGFkZHJlc3NMb3dlciA9PT0gbWFya2V0QWRkcmVzc2VzWzBdPy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIE1hcmtldCAke2FkZHJlc3N9IGhhcyBpbWFnZVVybDpgLCBpbWFnZVVybC5zdWJzdHJpbmcoMCwgMTAwKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcXVlc3Rpb24gLSBwcmlvcml0aXplIGNvbnRyYWN0LCB0aGVuIGJhY2tlbmQsIHRoZW4gZmFsbGJhY2tcbiAgICAgICAgICBjb25zdCBkaXNwbGF5UXVlc3Rpb24gPSBxdWVzdGlvbiB8fCBiYWNrZW5kTWFya2V0Py5xdWVzdGlvbiB8fCBgTWFya2V0ICR7YWRkcmVzcy5zbGljZSgwLCA4KX0uLi4ke2FkZHJlc3Muc2xpY2UoLTYpfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2F0ZWdvcnk6IHVzZSBiYWNrZW5kIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHRyeSB0byBpbmZlciBvciB1c2UgXCJPdGhlclwiXG4gICAgICAgICAgY29uc3QgZGlzcGxheUNhdGVnb3J5ID0gYmFja2VuZE1hcmtldD8uY2F0ZWdvcnkgfHwgXCJPdGhlclwiO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IG1hcmtldERhdGE6IE1hcmtldERhdGEgPSB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZmVlZElkOiBmZWVkSWRIZXgsXG4gICAgICAgICAgICBjdXJyZW50UHJpY2U6IGN1cnJlbnRQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSkgOiBcIjBcIixcbiAgICAgICAgICAgIGxvY2tQcmljZTogbG9ja1ByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIobG9ja1ByaWNlKSA6IFwiMFwiLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlIGFzIE1hcmtldFN0YXRlLFxuICAgICAgICAgICAgdG90YWxZZXM6IHRvdGFsWWVzID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxZZXMpIDogXCIwXCIsXG4gICAgICAgICAgICB0b3RhbE5vOiB0b3RhbE5vID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxObykgOiBcIjBcIixcbiAgICAgICAgICAgIC8vIFVzZSBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0IGZpcnN0IChtb3N0IHJlbGlhYmxlKSwgZmFsbGJhY2sgdG8gYmFja2VuZCwgdGhlbiBnZW5lcmljXG4gICAgICAgICAgICBxdWVzdGlvbjogZGlzcGxheVF1ZXN0aW9uLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGRpc3BsYXlDYXRlZ29yeSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBiYWNrZW5kTWFya2V0Py5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCwgLy8gU2V0IGltYWdlVXJsIGV4cGxpY2l0bHkgKGZyb20gYmFja2VuZCBpZiBhdmFpbGFibGUpXG4gICAgICAgICAgICBjcmVhdGlvblR4SGFzaDogY3JlYXRpb25UeEhhc2gsXG4gICAgICAgICAgICBjcmVhdG9yQWRkcmVzczogY3JlYXRvckFkZHJlc3MsIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0IGJ5IG5vdyAoZnJvbSBldmVudHMgb3IgYmFja2VuZClcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogYmFja2VuZE1hcmtldD8uY3JlYXRlZF9hdCB8fCBiYWNrZW5kTWFya2V0Py5jcmVhdGVkQXQsIC8vIFN1cHBvcnQgYm90aCBuYW1pbmcgY29udmVudGlvbnNcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgYmFja2VuZCBtYXJrZXRfaWQgZm9yIEFQSSBjYWxscyAoTWFya2V0SW5mbywgTWFya2V0Q2hhdClcbiAgICAgICAgICAgIG1hcmtldElkOiBiYWNrZW5kTWFya2V0Py5tYXJrZXRfaWQgfHwgYmFja2VuZE1hcmtldD8uaWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9nIGlmIG1hcmtldCBpcyBtaXNzaW5nIGJhY2tlbmQgbWV0YWRhdGFcbiAgICAgICAgICBpZiAoIWJhY2tlbmRNYXJrZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gaXMgb24tY2hhaW4gYnV0IG1pc3NpbmcgYmFja2VuZCBtZXRhZGF0YS4gVXNpbmcgY29udHJhY3QgZGF0YSBvbmx5LmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtYXJrZXREYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIG1hcmtldCAke2FkZHJlc3N9OmAsIGVycik7XG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBhdCBsZWFzdCBiYXNpYyBkYXRhIHVzaW5nIG5ldyBBQkkgaWYgb3RoZXIgY2FsbHMgZmFpbFxuICAgICAgICAgIGxldCBxdWVzdGlvbiA9IFwiXCI7XG4gICAgICAgICAgbGV0IGRlYWRsaW5lID0gMDtcbiAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgb3V0Y29tZSA9IDBuO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiYXNpY0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIE1BUktFVF9BQkksIHByb3ZpZGVyRm9yQ29udHJhY3QpO1xuICAgICAgICAgICAgW3F1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0LnF1ZXN0aW9uKCksXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3QuZGVhZGxpbmUoKSxcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5yZXNvbHZlZCgpLFxuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0Lm91dGNvbWUoKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gY2F0Y2ggKHF1ZXN0aW9uRXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmZXRjaCBiYXNpYyBkYXRhIGZvciBtYXJrZXQgJHthZGRyZXNzfTpgLCBxdWVzdGlvbkVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERldGVybWluZSBzdGF0ZSBmcm9tIHJlc29sdmVkL2RlYWRsaW5lXG4gICAgICAgICAgbGV0IHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5SZXNvbHZlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlYWRsaW5lID4gMCAmJiBkZWFkbGluZSA8PSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5Mb2NrZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJldHVybiBtaW5pbWFsIGRhdGEgaWYgY29udHJhY3QgY2FsbCBmYWlscywgYnV0IHN0aWxsIGluY2x1ZGUgdGhlIGFkZHJlc3NcbiAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgbWFya2V0cyBhcmUgc2hvd24gZXZlbiBpZiBzb21lIGNhbGxzIGZhaWxcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZWRJZDogXCJcIixcbiAgICAgICAgICAgIGN1cnJlbnRQcmljZTogXCIwXCIsXG4gICAgICAgICAgICBsb2NrUHJpY2U6IFwiMFwiLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgdG90YWxZZXM6IFwiMFwiLFxuICAgICAgICAgICAgdG90YWxObzogXCIwXCIsXG4gICAgICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24gfHwgYE1hcmtldCAke2FkZHJlc3Muc2xpY2UoMCwgOCl9Li4uJHthZGRyZXNzLnNsaWNlKC02KX1gLFxuICAgICAgICAgIH0gYXMgTWFya2V0RGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1hcmtldERhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChtYXJrZXRQcm9taXNlcyk7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFN1Y2Nlc3NmdWxseSBmZXRjaGVkIGRhdGEgZm9yICR7bWFya2V0RGF0YS5sZW5ndGh9IG1hcmtldHNgKTtcbiAgICAgIFxuICAgICAgLy8gTm8gbmVlZCBmb3IgYmF0Y2ggZmV0Y2hpbmcgLSB3ZSBhbHJlYWR5IGhhdmUgY3JlYXRvcnMgZnJvbSB0aGUgc2luZ2xlIGdldExvZ3MgY2FsbFxuICAgICAgLy8gSnVzdCBjaGVjayBpZiBhbnkgbWFya2V0cyBhcmUgc3RpbGwgbWlzc2luZyBjcmVhdG9ycyAoc2hvdWxkbid0IGhhcHBlbiBpZiBldmVudHMgd2VyZSBwYXJzZWQgY29ycmVjdGx5KVxuICAgICAgY29uc3QgbWFya2V0c05lZWRpbmdDcmVhdG9ycyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4gXG4gICAgICAgIG0uYWRkcmVzcyAmJiBcbiAgICAgICAgbS5hZGRyZXNzICE9PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiICYmXG4gICAgICAgICFtLmNyZWF0b3JBZGRyZXNzXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAobWFya2V0c05lZWRpbmdDcmVhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW3VzZU1hcmtldHNdICR7bWFya2V0c05lZWRpbmdDcmVhdG9ycy5sZW5ndGh9IG1hcmtldHMgc3RpbGwgbWlzc2luZyBjcmVhdG9ycyBhZnRlciBldmVudCBwYXJzaW5nLiBUaGlzIHNob3VsZG4ndCBoYXBwZW4gaWYgZXZlbnRzIHdlcmUgcGFyc2VkIGNvcnJlY3RseS5gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXV0by1zeW5jOiBDcmVhdGUgYmFja2VuZCBlbnRyaWVzIGZvciBvbi1jaGFpbiBtYXJrZXRzIG1pc3NpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgLy8gVGhpcyBlbnN1cmVzIGFsbCBtYXJrZXRzIGhhdmUgY29tcGxldGUgZGF0YVxuICAgICAgY29uc3QgbWFya2V0c05lZWRpbmdCYWNrZW5kU3luYyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4gXG4gICAgICAgIG0uYWRkcmVzcyAmJiBcbiAgICAgICAgbS5hZGRyZXNzICE9PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiICYmXG4gICAgICAgICFtLm1hcmtldElkICYmIC8vIE5vIGJhY2tlbmQgSUQgbWVhbnMgbm8gYmFja2VuZCBlbnRyeVxuICAgICAgICBtLnF1ZXN0aW9uICYmIC8vIEhhcyBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0XG4gICAgICAgIG0ucXVlc3Rpb24gIT09IGBNYXJrZXQgJHttLmFkZHJlc3Muc2xpY2UoMCwgOCl9Li4uJHttLmFkZHJlc3Muc2xpY2UoLTYpfWAgLy8gTm90IGp1c3QgZmFsbGJhY2tcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChtYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSAke21hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMubGVuZ3RofSBvbi1jaGFpbiBtYXJrZXRzIG1pc3NpbmcgYmFja2VuZCBtZXRhZGF0YS4gQXV0by1zeW5jaW5nLi4uYCk7XG4gICAgICAgIC8vIFRyeSB0byBjcmVhdGUgYmFja2VuZCBlbnRyaWVzIGZvciB0aGVzZSBtYXJrZXRzIChub24tYmxvY2tpbmcpXG4gICAgICAgIFByb21pc2UuYWxsKG1hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMubWFwKGFzeW5jIChtYXJrZXQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBpVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMVwiO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYmFja2VuZCBlbnRyeSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgY29uc3QgYmFja2VuZE1hcmtldHMgPSBhd2FpdCBheGlvcy5nZXQoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2ApO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gYmFja2VuZE1hcmtldHMuZGF0YS5zb21lKChtOiBhbnkpID0+IFxuICAgICAgICAgICAgICBtLm1hcmtldF9hZGRyZXNzPy50b0xvd2VyQ2FzZSgpID09PSBtYXJrZXQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWV4aXN0cyAmJiBtYXJrZXQucXVlc3Rpb24gJiYgbWFya2V0LmNyZWF0b3JBZGRyZXNzKSB7XG4gICAgICAgICAgICAgIC8vIENyZWF0ZSBiYWNrZW5kIGVudHJ5IHdpdGggY29udHJhY3QgZGF0YVxuICAgICAgICAgICAgICBhd2FpdCBheGlvcy5wb3N0KGAke2FwaVVybH0vYXBpL21hcmtldHNgLCB7XG4gICAgICAgICAgICAgICAgcXVlc3Rpb246IG1hcmtldC5xdWVzdGlvbixcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogbWFya2V0LmNhdGVnb3J5IHx8IFwiT3RoZXJcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNyAqIDI0ICogNjAgKiA2MCwgLy8gRGVmYXVsdCA3IGRheXNcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uRGVsYXk6IDI0ICogNjAgKiA2MCwgLy8gRGVmYXVsdCAyNCBob3Vyc1xuICAgICAgICAgICAgICAgIGltYWdlVXJsOiBtYXJrZXQuaW1hZ2VVcmwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBvcmFjbGVUeXBlOiBcImNoYWlubGlua1wiLCAvLyBEZWZhdWx0XG4gICAgICAgICAgICAgICAgY3JlYXRvckFkZHJlc3M6IG1hcmtldC5jcmVhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBtYXJrZXRBZGRyZXNzOiBtYXJrZXQuYWRkcmVzcyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gQXV0by1jcmVhdGVkIGJhY2tlbmQgZW50cnkgZm9yIG1hcmtldCAke21hcmtldC5hZGRyZXNzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gU2lsZW50bHkgZmFpbCAtIHRoaXMgaXMganVzdCBhIHN5bmMgYXR0ZW1wdFxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW3VzZU1hcmtldHNdIENvdWxkIG5vdCBhdXRvLXN5bmMgbWFya2V0ICR7bWFya2V0LmFkZHJlc3N9OmAsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgLSB0aGlzIGlzIGJlc3QgZWZmb3J0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgb3V0IG1hcmtldHMgd2l0aCBlbXB0eS9pbnZhbGlkIGFkZHJlc3NlcyAtIG9ubHkgc2hvdyByZWFsIG9uLWNoYWluIG1hcmtldHNcbiAgICAgIGNvbnN0IHZhbGlkTWFya2V0cyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4ge1xuICAgICAgICAvLyBNdXN0IGhhdmUgYSB2YWxpZCBhZGRyZXNzXG4gICAgICAgIGlmICghbS5hZGRyZXNzIHx8IG0uYWRkcmVzcyA9PT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdXN0IGJlIGEgdmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXRcbiAgICAgICAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChtLmFkZHJlc3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11c3QgaGF2ZSBiZWVuIGZldGNoZWQgZnJvbSBmYWN0b3J5IChleGlzdHMgaW4gbWFya2V0QWRkcmVzc2VzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBtYXJrZXRzV2l0aENyZWF0b3JzID0gdmFsaWRNYXJrZXRzLmZpbHRlcihtID0+IG0uY3JlYXRvckFkZHJlc3MpLmxlbmd0aDtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gVmFsaWQgb24tY2hhaW4gbWFya2V0czogJHt2YWxpZE1hcmtldHMubGVuZ3RofSwgTWFya2V0cyB3aXRoIGNyZWF0b3JzOiAke21hcmtldHNXaXRoQ3JlYXRvcnN9YCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZXMgYW5kIGFkZCB0byBtYXJrZXQgZGF0YVxuICAgICAgY29uc3QgbWFya2V0c1dpdGhUcmVuZGluZyA9IHZhbGlkTWFya2V0cy5tYXAobWFya2V0ID0+ICh7XG4gICAgICAgIC4uLm1hcmtldCxcbiAgICAgICAgdHJlbmRpbmdTY29yZTogY2FsY3VsYXRlVHJlbmRpbmdTY29yZShtYXJrZXQpLFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZpbmFsIG1hcmtldHMgdG8gZGlzcGxheTpgLCBtYXJrZXRzV2l0aFRyZW5kaW5nLm1hcChtID0+ICh7IFxuICAgICAgICBhZGRyZXNzOiBtLmFkZHJlc3MsIFxuICAgICAgICBxdWVzdGlvbjogbS5xdWVzdGlvbiB8fCAnTm8gcXVlc3Rpb24nLCBcbiAgICAgICAgaGFzSW1hZ2U6ICEhbS5pbWFnZVVybCxcbiAgICAgICAgaW1hZ2VVcmw6IG0uaW1hZ2VVcmwgPyBgJHttLmltYWdlVXJsLnN1YnN0cmluZygwLCA1MCl9Li4uYCA6ICdub25lJ1xuICAgICAgfSkpKTtcbiAgICAgIFxuICAgICAgc2V0TWFya2V0cyhtYXJrZXRzV2l0aFRyZW5kaW5nKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzOlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0c1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaE1hcmtldHMoKTtcbiAgfSwgW2ZldGNoTWFya2V0c10pO1xuXG4gIHJldHVybiB7IG1hcmtldHMsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldHMgfTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGZldGNoIGEgc2luZ2xlIG1hcmtldCdzIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcmtldChtYXJrZXRBZGRyZXNzOiBzdHJpbmcgfCBudWxsKSB7XG4gIGNvbnN0IFttYXJrZXQsIHNldE1hcmtldF0gPSB1c2VTdGF0ZTxNYXJrZXREYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmV0Y2hNYXJrZXQoKTtcbiAgfSwgW21hcmtldEFkZHJlc3NdKTtcblxuICBjb25zdCBmZXRjaE1hcmtldCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIC8vIFVzZSBCcm93c2VyUHJvdmlkZXIgYW5kIENvbnRyYWN0IGRpcmVjdGx5IHdpdGggbmV3IEFCSVxuICAgICAgbGV0IHByb3ZpZGVyRm9yQ29udHJhY3Q6IEJyb3dzZXJQcm92aWRlcjtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmFzZVByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IGJhc2VQcm92aWRlciBhcyBhbnkgYXMgQnJvd3NlclByb3ZpZGVyO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtYXJrZXRDb250cmFjdCA9IG5ldyBDb250cmFjdChtYXJrZXRBZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcblxuICAgICAgLy8gVXNlIG5ldyBBQkkgbWV0aG9kczogcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZVxuICAgICAgY29uc3QgW3F1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5kZWFkbGluZSgpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5yZXNvbHZlZCgpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5vdXRjb21lKCksIC8vIGVudW06IDAsMSwyXG4gICAgICBdKTtcblxuICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICBsZXQgY3VycmVudFByaWNlID0gMG47XG4gICAgICBsZXQgbG9ja1ByaWNlID0gMG47XG4gICAgICBsZXQgdG90YWxZZXMgPSAwbjtcbiAgICAgIGxldCB0b3RhbE5vID0gMG47XG4gICAgICBsZXQgZmVlZElkID0gXCIweDBcIjtcbiAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcblxuICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICAvLyBXcmFwIGVhY2ggY2FsbCBpbiBhIHByb21pc2UgdGhhdCBjYXRjaGVzIGVycm9yc1xuICAgICAgY29uc3Qgc2FmZUNhbGwgPSBhc3luYyAoZm46ICgpID0+IFByb21pc2U8YW55PiwgZGVmYXVsdFZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgW2N1cnJlbnRQcmljZSwgbG9ja1ByaWNlLCBzdGF0ZSwgdG90YWxZZXMsIHRvdGFsTm8sIGZlZWRJZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QuZ2V0Q3VycmVudFByaWNlKCksIDBuKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnN0YXRlKCksIDApLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsWWVzKCksIDBuKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC50b3RhbE5vKCksIDBuKSxcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5mZWVkSWQoKSwgXCIweDBcIiksXG4gICAgICAgIF0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElmIG1ldGhvZHMgZG9uJ3QgZXhpc3QsIGRlZmF1bHRzIGFyZSBhbHJlYWR5IHNldCBhYm92ZVxuICAgICAgICBjb25zb2xlLndhcm4oYFNvbWUgb3B0aW9uYWwgbWV0aG9kcyBub3QgYXZhaWxhYmxlIGZvciBtYXJrZXQgJHttYXJrZXRBZGRyZXNzfSwgdXNpbmcgZGVmYXVsdHNgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFwIHJlc29sdmVkL291dGNvbWUgdG8gTWFya2V0U3RhdGVcbiAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLlJlc29sdmVkO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIoZGVhZGxpbmUpIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuTG9ja2VkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgZmVlZElkIGJ5dGVzMzIgdG8gc3RyaW5nIGlmIGF2YWlsYWJsZVxuICAgICAgbGV0IGZlZWRJZFN0ciA9IFwiXCI7XG4gICAgICBsZXQgZmVlZElkSGV4ID0gXCIweDBcIjtcbiAgICAgIGlmIChmZWVkSWQgJiYgZmVlZElkICE9PSBcIjB4MFwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmVlZElkU3RyID0gZXRoZXJzLnRvVXRmOFN0cmluZyhmZWVkSWQpLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcbiAgICAgICAgICBmZWVkSWRIZXggPSBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZmVlZElkSGV4ID0gdHlwZW9mIGZlZWRJZCA9PT0gXCJzdHJpbmdcIiA/IGZlZWRJZCA6IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0TWFya2V0KHtcbiAgICAgICAgYWRkcmVzczogbWFya2V0QWRkcmVzcyxcbiAgICAgICAgZmVlZElkOiBmZWVkSWRIZXgsXG4gICAgICAgIGN1cnJlbnRQcmljZTogY3VycmVudFByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudFByaWNlKSA6IFwiMFwiLFxuICAgICAgICBsb2NrUHJpY2U6IGxvY2tQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGxvY2tQcmljZSkgOiBcIjBcIixcbiAgICAgICAgc3RhdGU6IHN0YXRlIGFzIE1hcmtldFN0YXRlLFxuICAgICAgICB0b3RhbFllczogdG90YWxZZXMgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbFllcykgOiBcIjBcIixcbiAgICAgICAgdG90YWxObzogdG90YWxObyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsTm8pIDogXCIwXCIsXG4gICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldDpcIiwgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldFwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IG1hcmtldCwgbG9hZGluZywgZXJyb3IsIHJlZmV0Y2g6IGZldGNoTWFya2V0IH07XG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZXRoZXJzIiwiQnJvd3NlclByb3ZpZGVyIiwiQ29udHJhY3QiLCJheGlvcyIsIm1hcmtldEFydGlmYWN0IiwiZ2V0RmFjdG9yeUNvbnRyYWN0IiwiZ2V0UHJvdmlkZXIiLCJNYXJrZXRTdGF0ZSIsIkZBQ1RPUllfQUREUkVTUyIsIk1BUktFVF9BQkkiLCJhYmkiLCJjYWxjdWxhdGVUcmVuZGluZ1Njb3JlIiwibWFya2V0IiwidG90YWxZZXMiLCJwYXJzZUZsb2F0IiwidG90YWxObyIsInRvdGFsTGlxdWlkaXR5Iiwic2NvcmUiLCJzdGF0ZSIsIkFjdGl2ZSIsImJhbGFuY2UiLCJNYXRoIiwibWluIiwibWF4IiwidXNlTWFya2V0cyIsIm1hcmtldHMiLCJzZXRNYXJrZXRzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiZmV0Y2hNYXJrZXRzIiwicHJvdmlkZXIiLCJmYWN0b3J5IiwibWFya2V0QWRkcmVzc2VzIiwiZ2V0TWFya2V0cyIsImNyZWF0aW9uVHhNYXAiLCJNYXAiLCJjcmVhdG9yQnlNYXJrZXQiLCJNQVJLRVRfQ1JFQVRFRF9UT1BJQyIsImlkIiwiZmlsdGVyIiwiYWRkcmVzcyIsInRvcGljcyIsImZyb21CbG9jayIsInRvQmxvY2siLCJsb2dzIiwiZ2V0TG9ncyIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJwYXJzZWQiLCJpbnRlcmZhY2UiLCJwYXJzZUxvZyIsImRhdGEiLCJwYXJzZUVyciIsIm1hcmtldEFkZHJlc3MiLCJnZXRBZGRyZXNzIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsImNyZWF0b3JBZGRyZXNzIiwic2V0IiwidHJhbnNhY3Rpb25IYXNoIiwiYXJncyIsImNyZWF0b3IiLCJ3YXJuIiwiT2JqZWN0Iiwia2V5cyIsImVyciIsImJhY2tlbmRNYXJrZXRzIiwiYXBpVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsImdldCIsImJhY2tlbmRNYXBCeUFkZHJlc3MiLCJiYWNrZW5kTWFwQnlGZWVkSWQiLCJmb3JFYWNoIiwibSIsIm1hcmtldF9hZGRyZXNzIiwiYWRkckxvd2VyIiwiZmVlZF9pZCIsImZlZWRJZExvd2VyIiwic3RhcnRzV2l0aCIsIm1hcmtldFByb21pc2VzIiwibWFwIiwicHJvdmlkZXJGb3JDb250cmFjdCIsIndpbmRvdyIsImV0aGVyZXVtIiwibWFya2V0Q29udHJhY3QiLCJzYWZlQ2FsbCIsImZuIiwiZGVmYXVsdFZhbHVlIiwicXVlc3Rpb24iLCJkZWFkbGluZSIsInJlc29sdmVkIiwib3V0Y29tZSIsIlByb21pc2UiLCJhbGwiLCJjcmVhdG9yRnJvbUNvbnRyYWN0IiwiZGVidWciLCJjdXJyZW50UHJpY2UiLCJsb2NrUHJpY2UiLCJmZWVkSWQiLCJnZXRDdXJyZW50UHJpY2UiLCJSZXNvbHZlZCIsIk51bWJlciIsImZsb29yIiwiRGF0ZSIsIm5vdyIsIkxvY2tlZCIsImZlZWRJZFN0ciIsImZlZWRJZEhleCIsInRvVXRmOFN0cmluZyIsInJlcGxhY2UiLCJoZXhsaWZ5IiwiYWRkcmVzc0xvd2VyIiwiYmFja2VuZE1hcmtldCIsImZlZWRJZE5vUHJlZml4IiwiY3JlYXRpb25UeEhhc2giLCJjcmVhdG9yX2FkZHJlc3MiLCJpbWFnZVVybCIsImltYWdlX3VybCIsInN1YnN0cmluZyIsImRpc3BsYXlRdWVzdGlvbiIsImRpc3BsYXlDYXRlZ29yeSIsImNhdGVnb3J5IiwibWFya2V0RGF0YSIsImZvcm1hdEV0aGVyIiwiZGVzY3JpcHRpb24iLCJjcmVhdGVkQXQiLCJjcmVhdGVkX2F0IiwibWFya2V0SWQiLCJtYXJrZXRfaWQiLCJ1bmRlZmluZWQiLCJiYXNpY0NvbnRyYWN0IiwicXVlc3Rpb25FcnIiLCJtYXJrZXRzTmVlZGluZ0NyZWF0b3JzIiwibWFya2V0c05lZWRpbmdCYWNrZW5kU3luYyIsImV4aXN0cyIsInNvbWUiLCJwb3N0IiwiZHVyYXRpb24iLCJyZXNvbHV0aW9uRGVsYXkiLCJvcmFjbGVUeXBlIiwiY2F0Y2giLCJ2YWxpZE1hcmtldHMiLCJ0ZXN0IiwibWFya2V0c1dpdGhDcmVhdG9ycyIsIm1hcmtldHNXaXRoVHJlbmRpbmciLCJ0cmVuZGluZ1Njb3JlIiwiaGFzSW1hZ2UiLCJtZXNzYWdlIiwicmVmZXRjaCIsInVzZU1hcmtldCIsInNldE1hcmtldCIsImZldGNoTWFya2V0IiwiYmFzZVByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});