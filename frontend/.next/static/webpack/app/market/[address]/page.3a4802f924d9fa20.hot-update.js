"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/market/[address]/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory (ONLY on-chain markets - no mocks)\n            const marketAddresses = await factory.getMarkets();\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" on-chain markets from factory contract\"));\n            // Fetch MarketCreated events to get creation transaction hashes and creator addresses\n            const creationTxMap = new Map();\n            const creatorMap = new Map();\n            try {\n                // Query MarketCreated events from the factory contract\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        eventTopic\n                    ]\n                };\n                const events = await provider.getLogs(filter);\n                console.log(\"[useMarkets] Found \".concat(events.length, \" MarketCreated events\"));\n                // Parse events\n                for (const log of events){\n                    try {\n                        // Get transaction to find sender (creator)\n                        let txSender = null;\n                        try {\n                            const tx = await provider.getTransaction(log.transactionHash);\n                            if (tx && tx.from) {\n                                txSender = tx.from.toLowerCase();\n                            }\n                        } catch (txErr) {\n                            console.warn(\"Failed to get transaction \".concat(log.transactionHash, \":\"), txErr);\n                        }\n                        // Try to decode using factory interface\n                        let decoded = null;\n                        try {\n                            decoded = factory.interface.parseLog({\n                                topics: log.topics,\n                                data: log.data\n                            });\n                        } catch (parseErr) {\n                            // Try alternative parsing - extract from topics directly\n                            if (log.topics && log.topics.length >= 3) {\n                                // topics[0] = event signature\n                                // topics[1] = market address (first indexed param)\n                                // topics[2] = creator address (second indexed param)\n                                const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                                const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26));\n                                creationTxMap.set(marketAddress, log.transactionHash);\n                                creatorMap.set(marketAddress, creatorAddress);\n                                console.log(\"[useMarkets] Extracted creator from topics: \".concat(creatorAddress, \" for market \").concat(marketAddress));\n                                continue;\n                            }\n                        }\n                        // If decoded successfully\n                        if (decoded && decoded.args) {\n                            var _decoded_args_market, _decoded_args_;\n                            const marketAddress = ((_decoded_args_market = decoded.args.market) === null || _decoded_args_market === void 0 ? void 0 : _decoded_args_market.toLowerCase()) || ((_decoded_args_ = decoded.args[0]) === null || _decoded_args_ === void 0 ? void 0 : _decoded_args_.toLowerCase());\n                            if (marketAddress) {\n                                var _decoded_args_creator, _decoded_args_1;\n                                creationTxMap.set(marketAddress, log.transactionHash);\n                                // Try multiple ways to get creator\n                                const creatorAddress = ((_decoded_args_creator = decoded.args.creator) === null || _decoded_args_creator === void 0 ? void 0 : _decoded_args_creator.toLowerCase()) || ((_decoded_args_1 = decoded.args[1]) === null || _decoded_args_1 === void 0 ? void 0 : _decoded_args_1.toLowerCase()) || txSender;\n                                if (creatorAddress) {\n                                    creatorMap.set(marketAddress, creatorAddress);\n                                    console.log(\"[useMarkets] Extracted creator: \".concat(creatorAddress, \" for market \").concat(marketAddress));\n                                } else {\n                                    console.warn(\"[useMarkets] Could not extract creator for market \".concat(marketAddress));\n                                }\n                            }\n                        } else if (txSender && log.topics && log.topics.length >= 2) {\n                            // Fallback: use transaction sender as creator\n                            const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            creatorMap.set(marketAddress, txSender);\n                            console.log(\"[useMarkets] Using tx sender as creator: \".concat(txSender, \" for market \").concat(marketAddress));\n                        }\n                    } catch (parseErr) {\n                        console.error(\"[useMarkets] Error parsing event log:\", parseErr);\n                    }\n                }\n                console.log(\"[useMarkets] Creator map size: \".concat(creatorMap.size, \", Creation tx map size: \").concat(creationTxMap.size));\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API (ONLY for enriching on-chain markets with metadata - not for displaying)\n            // Backend markets are matched to on-chain markets by market_address\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" backend metadata entries (for enrichment only, not displayed separately)\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market using new ABI\n            const marketPromises = marketAddresses.map(async (address)=>{\n                // Use BrowserProvider and Contract directly with new ABI\n                let providerForContract;\n                if ( true && window.ethereum) {\n                    providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n                } else {\n                    providerForContract = provider;\n                }\n                const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                try {\n                    var _marketAddresses_;\n                    // Wrap each call in a promise that catches errors\n                    const safeCall = async (fn, defaultValue)=>{\n                        try {\n                            return await fn();\n                        } catch (e) {\n                            return defaultValue;\n                        }\n                    };\n                    // Use new ABI methods: question, deadline, resolved, outcome\n                    // Also try to read creator directly from contract if available\n                    const [question, deadline, resolved, outcome] = await Promise.all([\n                        marketContract.question(),\n                        marketContract.deadline(),\n                        marketContract.resolved(),\n                        marketContract.outcome()\n                    ]);\n                    // Try to read creator directly from contract (simplest method)\n                    let creatorFromContract = null;\n                    try {\n                        creatorFromContract = await marketContract.creator();\n                    } catch (err) {\n                        // Contract might not have creator() function, that's okay\n                        console.debug(\"[useMarkets] Market \".concat(address, \" does not have creator() function\"));\n                    }\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    let currentPrice = 0n;\n                    let lockPrice = 0n;\n                    let totalYes = 0n;\n                    let totalNo = 0n;\n                    let feedId = \"0x0\";\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    try {\n                        [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                            safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                            safeCall(()=>marketContract.lockPrice(), 0n),\n                            safeCall(()=>marketContract.state(), 0),\n                            safeCall(()=>marketContract.totalYes(), 0n),\n                            safeCall(()=>marketContract.totalNo(), 0n),\n                            safeCall(()=>marketContract.feedId(), \"0x0\")\n                        ]);\n                    } catch (err) {\n                        // If methods don't exist, defaults are already set above\n                        console.warn(\"Some optional methods not available for market \".concat(address, \", using defaults\"));\n                    }\n                    // Map resolved/outcome to MarketState\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    } else {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes) if it's a bytes32\n                    let feedIdStr = \"\";\n                    let feedIdHex = \"0x0\";\n                    if (feedId && feedId !== \"0x0\") {\n                        try {\n                            feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                            feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        } catch (e) {\n                            feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        }\n                    }\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    // Priority 1: Read creator directly from contract (simplest and most reliable)\n                    let creatorAddress = creatorFromContract ? creatorFromContract.toLowerCase() : null;\n                    // Priority 2: Use creator from event map (from initial event parsing)\n                    if (!creatorAddress) {\n                        creatorAddress = creatorMap.get(addressLower);\n                    }\n                    // Priority 3: Use backend creator_address\n                    if (!creatorAddress && (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.creator_address)) {\n                        creatorAddress = backendMarket.creator_address.toLowerCase();\n                        console.log(\"[useMarkets] Using creator from backend: \".concat(creatorAddress, \" for market \").concat(address));\n                    }\n                    // Priority 4: Fetch from transaction if we have creationTxHash\n                    if (!creatorAddress && creationTxHash) {\n                        try {\n                            const tx = await provider.getTransaction(creationTxHash);\n                            if (tx && tx.from) {\n                                creatorAddress = tx.from.toLowerCase();\n                                creatorMap.set(addressLower, creatorAddress); // Cache it\n                                console.log(\"[useMarkets] Fetched creator from transaction: \".concat(creatorAddress, \" for market \").concat(address));\n                            }\n                        } catch (txErr) {\n                            console.warn(\"[useMarkets] Failed to fetch creator from tx \".concat(creationTxHash, \":\"), txErr);\n                        }\n                    }\n                    // Priority 5: Try to find creation transaction by searching for MarketCreated events for this specific market\n                    if (!creatorAddress) {\n                        try {\n                            // Query events filtered by this specific market address\n                            const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                            const marketTopic = ethers__WEBPACK_IMPORTED_MODULE_9__.zeroPadValue(address, 32); // Pad address to 32 bytes for topic\n                            const filter = {\n                                address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                                topics: [\n                                    eventTopic,\n                                    marketTopic\n                                ]\n                            };\n                            const marketEvents = await provider.getLogs(filter);\n                            if (marketEvents.length > 0) {\n                                const log = marketEvents[0];\n                                // Extract creator from topics[2]\n                                if (log.topics && log.topics.length >= 3) {\n                                    creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26)).toLowerCase();\n                                    creatorMap.set(addressLower, creatorAddress);\n                                    console.log(\"[useMarkets] Found creator from market-specific event: \".concat(creatorAddress, \" for market \").concat(address));\n                                }\n                            }\n                        } catch (eventErr) {\n                            console.warn(\"[useMarkets] Failed to fetch creator from events for market \".concat(address, \":\"), eventErr);\n                        }\n                    }\n                    if (creatorAddress) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" creator: \").concat(creatorAddress, \" (from \").concat(creatorFromContract ? \"contract\" : creatorMap.has(addressLower) ? \"events\" : (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.creator_address) ? \"backend\" : \"transaction\", \")\"));\n                    }\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    // Ensure we always have a question - prioritize contract, then backend, then fallback\n                    const displayQuestion = question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question) || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6));\n                    // Category: use backend if available, otherwise try to infer or use \"Other\"\n                    const displayCategory = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category) || \"Other\";\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                        lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                        state: state,\n                        totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                        totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                        // Use question from contract first (most reliable), fallback to backend, then generic\n                        question: displayQuestion,\n                        category: displayCategory,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress,\n                        createdAt: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.created_at) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.createdAt),\n                        // Include backend market_id for API calls (MarketInfo, MarketChat)\n                        marketId: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.market_id) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.id) || undefined\n                    };\n                    // Log if market is missing backend metadata\n                    if (!backendMarket) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" is on-chain but missing backend metadata. Using contract data only.\"));\n                    }\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least basic data using new ABI if other calls fail\n                    let question = \"\";\n                    let deadline = 0;\n                    let resolved = false;\n                    let outcome = 0n;\n                    try {\n                        const basicContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                        [question, deadline, resolved, outcome] = await Promise.all([\n                            basicContract.question(),\n                            basicContract.deadline(),\n                            basicContract.resolved(),\n                            basicContract.outcome()\n                        ]);\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch basic data for market \".concat(address, \":\"), questionErr);\n                    }\n                    // Determine state from resolved/deadline\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (deadline > 0 && deadline <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: state,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // Batch fetch creators for markets that are still missing them\n            const marketsNeedingCreators = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.creatorAddress);\n            if (marketsNeedingCreators.length > 0) {\n                console.log(\"[useMarkets] \".concat(marketsNeedingCreators.length, \" markets missing creators, attempting to fetch...\"));\n                // Try to fetch creators from their creation transactions in parallel\n                await Promise.all(marketsNeedingCreators.map(async (market)=>{\n                    const addressLower = market.address.toLowerCase();\n                    // Try to find MarketCreated event for this specific market\n                    try {\n                        const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                        const marketTopic = ethers__WEBPACK_IMPORTED_MODULE_9__.zeroPadValue(market.address, 32);\n                        const filter = {\n                            address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                            topics: [\n                                eventTopic,\n                                marketTopic\n                            ]\n                        };\n                        const events = await provider.getLogs(filter);\n                        if (events.length > 0) {\n                            const log = events[0];\n                            if (log.topics && log.topics.length >= 3) {\n                                const creator = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26)).toLowerCase();\n                                market.creatorAddress = creator;\n                                creatorMap.set(addressLower, creator);\n                                console.log(\"[useMarkets] Found creator for \".concat(market.address, \": \").concat(creator));\n                            }\n                        }\n                    } catch (err) {\n                        console.warn(\"[useMarkets] Could not fetch creator for \".concat(market.address, \":\"), err);\n                    }\n                }));\n            }\n            // Auto-sync: Create backend entries for on-chain markets missing backend metadata\n            // This ensures all markets have complete data\n            const marketsNeedingBackendSync = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.marketId && // No backend ID means no backend entry\n                m.question && // Has question from contract\n                m.question !== \"Market \".concat(m.address.slice(0, 8), \"...\").concat(m.address.slice(-6)) // Not just fallback\n            );\n            if (marketsNeedingBackendSync.length > 0) {\n                console.log(\"[useMarkets] \".concat(marketsNeedingBackendSync.length, \" on-chain markets missing backend metadata. Auto-syncing...\"));\n                // Try to create backend entries for these markets (non-blocking)\n                Promise.all(marketsNeedingBackendSync.map(async (market)=>{\n                    try {\n                        const apiUrl = \"http://localhost:3001\" || 0;\n                        // Check if backend entry already exists\n                        const backendMarkets = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                        const exists = backendMarkets.data.some((m)=>{\n                            var _m_market_address;\n                            return ((_m_market_address = m.market_address) === null || _m_market_address === void 0 ? void 0 : _m_market_address.toLowerCase()) === market.address.toLowerCase();\n                        });\n                        if (!exists && market.question && market.creatorAddress) {\n                            // Create backend entry with contract data\n                            await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].post(\"\".concat(apiUrl, \"/api/markets\"), {\n                                question: market.question,\n                                category: market.category || \"Other\",\n                                duration: 7 * 24 * 60 * 60,\n                                resolutionDelay: 24 * 60 * 60,\n                                imageUrl: market.imageUrl || null,\n                                oracleType: \"chainlink\",\n                                creatorAddress: market.creatorAddress,\n                                marketAddress: market.address\n                            });\n                            console.log(\"[useMarkets] Auto-created backend entry for market \".concat(market.address));\n                        }\n                    } catch (err) {\n                        // Silently fail - this is just a sync attempt\n                        console.debug(\"[useMarkets] Could not auto-sync market \".concat(market.address, \":\"), err);\n                    }\n                })).catch(()=>{\n                // Ignore errors - this is best effort\n                });\n            }\n            // Filter out markets with empty/invalid addresses - only show real on-chain markets\n            const validMarkets = marketData.filter((m)=>{\n                // Must have a valid address\n                if (!m.address || m.address === \"0x0000000000000000000000000000000000000000\") {\n                    return false;\n                }\n                // Must be a valid Ethereum address format\n                if (!/^0x[a-fA-F0-9]{40}$/.test(m.address)) {\n                    return false;\n                }\n                // Must have been fetched from factory (exists in marketAddresses)\n                return true;\n            });\n            const marketsWithCreators = validMarkets.filter((m)=>m.creatorAddress).length;\n            console.log(\"[useMarkets] Valid on-chain markets: \".concat(validMarkets.length, \", Markets with creators: \").concat(marketsWithCreators));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            // Use BrowserProvider and Contract directly with new ABI\n            let providerForContract;\n            if ( true && window.ethereum) {\n                providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n            } else {\n                const baseProvider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n                providerForContract = baseProvider;\n            }\n            const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(marketAddress, MARKET_ABI, providerForContract);\n            // Use new ABI methods: question, deadline, resolved, outcome\n            const [question, deadline, resolved, outcome] = await Promise.all([\n                marketContract.question(),\n                marketContract.deadline(),\n                marketContract.resolved(),\n                marketContract.outcome()\n            ]);\n            // Try to get additional data if methods exist (for backward compatibility)\n            let currentPrice = 0n;\n            let lockPrice = 0n;\n            let totalYes = 0n;\n            let totalNo = 0n;\n            let feedId = \"0x0\";\n            let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            // Try to get additional data if methods exist (for backward compatibility)\n            // Wrap each call in a promise that catches errors\n            const safeCall = async (fn, defaultValue)=>{\n                try {\n                    return await fn();\n                } catch (e) {\n                    return defaultValue;\n                }\n            };\n            try {\n                [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                    safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                    safeCall(()=>marketContract.lockPrice(), 0n),\n                    safeCall(()=>marketContract.state(), 0),\n                    safeCall(()=>marketContract.totalYes(), 0n),\n                    safeCall(()=>marketContract.totalNo(), 0n),\n                    safeCall(()=>marketContract.feedId(), \"0x0\")\n                ]);\n            } catch (err) {\n                // If methods don't exist, defaults are already set above\n                console.warn(\"Some optional methods not available for market \".concat(marketAddress, \", using defaults\"));\n            }\n            // Map resolved/outcome to MarketState\n            if (resolved) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n            } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n            } else {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            }\n            // Convert feedId bytes32 to string if available\n            let feedIdStr = \"\";\n            let feedIdHex = \"0x0\";\n            if (feedId && feedId !== \"0x0\") {\n                try {\n                    feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                } catch (e) {\n                    feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                }\n            }\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdHex,\n                currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                state: state,\n                totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0U7QUFDakM7QUFDK0I7QUFPL0I7QUFFMUIsTUFBTVksYUFBYUwsMkRBQWtCO0FBRXJDOztDQUVDLEdBQ0QsU0FBU08sdUJBQXVCQyxNQUFrQjtJQUNoRCxNQUFNQyxXQUFXQyxXQUFXRixPQUFPQyxRQUFRO0lBQzNDLE1BQU1FLFVBQVVELFdBQVdGLE9BQU9HLE9BQU87SUFDekMsTUFBTUMsaUJBQWlCSCxXQUFXRTtJQUVsQyxxQ0FBcUM7SUFDckMsSUFBSUUsUUFBUUQ7SUFFWiwyQkFBMkI7SUFDM0IsSUFBSUosT0FBT00sS0FBSyxLQUFLWCx1REFBV0EsQ0FBQ1ksTUFBTSxFQUFFO1FBQ3ZDRixTQUFTO0lBQ1g7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTUksVUFBVUMsS0FBS0MsR0FBRyxDQUFDVCxVQUFVRSxXQUFXTSxLQUFLRSxHQUFHLENBQUNWLFVBQVVFO1FBQ2pFRSxTQUFVLElBQUlHLFVBQVUsS0FBTSx1Q0FBdUM7SUFDdkU7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTTztJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQWUsRUFBRTtJQUN2RCxNQUFNLENBQUM4QixTQUFTQyxXQUFXLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWtDLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQixJQUFJO1lBQ0Y2QixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxNQUFNRSxXQUFXMUIsMkRBQVdBO1lBQzVCLE1BQU0yQixVQUFVNUIsa0VBQWtCQSxDQUFDMkI7WUFFbkMsMkVBQTJFO1lBQzNFLE1BQU1FLGtCQUE0QixNQUFNRCxRQUFRRSxV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USxZQUFZbEgsZ0RBQW1CLENBQUMwRyxRQUFRVyxPQUFPLENBQUMsT0FBTztvQkFDdkRGLFlBQVlELGFBQWFsSCwyQ0FBYyxDQUFDMEc7Z0JBQzFDLEVBQUUsVUFBTTtvQkFDTlMsWUFBWSxPQUFPVCxXQUFXLFdBQVdBLFNBQVMxRywyQ0FBYyxDQUFDMEc7Z0JBQ25FO1lBQ0Y7WUFFQXlELFVBQVU7Z0JBQ1J0SCxTQUFTaUI7Z0JBQ1Q0QyxRQUFRUztnQkFDUlgsY0FBY0EsZUFBZSxFQUFFLEdBQUd4RyxnREFBa0IsQ0FBQ3dHLGdCQUFnQjtnQkFDckVDLFdBQVdBLFlBQVksRUFBRSxHQUFHekcsZ0RBQWtCLENBQUN5RyxhQUFhO2dCQUM1RHZGLE9BQU9BO2dCQUNQTCxVQUFVQSxXQUFXLEVBQUUsR0FBR2IsZ0RBQWtCLENBQUNhLFlBQVk7Z0JBQ3pERSxTQUFTQSxVQUFVLEVBQUUsR0FBR2YsZ0RBQWtCLENBQUNlLFdBQVc7Z0JBQ3REaUYsVUFBVUE7WUFDWjtRQUNGLEVBQUUsT0FBTzFCLEtBQVU7WUFDakJsQyxRQUFRUCxLQUFLLENBQUMsMkJBQTJCeUM7WUFDekN4QyxTQUFTd0MsSUFBSTBGLE9BQU8sSUFBSTtRQUMxQixTQUFVO1lBQ1JwSSxXQUFXO1FBQ2I7SUFDRjtJQUVBLE9BQU87UUFBRWhCO1FBQVFlO1FBQVNFO1FBQU9vSSxTQUFTRztJQUFZO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzP2QzYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGV0aGVycywgQnJvd3NlclByb3ZpZGVyLCBDb250cmFjdCB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBtYXJrZXRBcnRpZmFjdCBmcm9tIFwiQC9hYmkvUHJlZGljdGlvbk1hcmtldC5qc29uXCI7XG5pbXBvcnQge1xuICBnZXRGYWN0b3J5Q29udHJhY3QsXG4gIGdldFByb3ZpZGVyLFxuICBNYXJrZXREYXRhLFxuICBNYXJrZXRTdGF0ZSxcbiAgRkFDVE9SWV9BRERSRVNTLFxufSBmcm9tIFwiLi4vbGliL2NvbnRyYWN0c1wiO1xuXG5jb25zdCBNQVJLRVRfQUJJID0gbWFya2V0QXJ0aWZhY3QuYWJpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZSBiYXNlZCBvbiBsaXF1aWRpdHkgYW5kIGFjdGl2aXR5XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUobWFya2V0OiBNYXJrZXREYXRhKTogbnVtYmVyIHtcbiAgY29uc3QgdG90YWxZZXMgPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbFllcyk7XG4gIGNvbnN0IHRvdGFsTm8gPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbE5vKTtcbiAgY29uc3QgdG90YWxMaXF1aWRpdHkgPSB0b3RhbFllcyArIHRvdGFsTm87XG4gIFxuICAvLyBCYXNlIHNjb3JlIGZyb20gbGlxdWlkaXR5ICh2b2x1bWUpXG4gIGxldCBzY29yZSA9IHRvdGFsTGlxdWlkaXR5O1xuICBcbiAgLy8gQm9vc3QgZm9yIGFjdGl2ZSBtYXJrZXRzXG4gIGlmIChtYXJrZXQuc3RhdGUgPT09IE1hcmtldFN0YXRlLkFjdGl2ZSkge1xuICAgIHNjb3JlICo9IDEuMjtcbiAgfVxuICBcbiAgLy8gQm9vc3QgZm9yIG1hcmtldHMgd2l0aCBiYWxhbmNlZCBsaXF1aWRpdHkgKG1vcmUgaW50ZXJlc3RpbmcpXG4gIGlmICh0b3RhbExpcXVpZGl0eSA+IDApIHtcbiAgICBjb25zdCBiYWxhbmNlID0gTWF0aC5taW4odG90YWxZZXMsIHRvdGFsTm8pIC8gTWF0aC5tYXgodG90YWxZZXMsIHRvdGFsTm8pO1xuICAgIHNjb3JlICo9ICgxICsgYmFsYW5jZSAqIDAuMyk7IC8vIFVwIHRvIDMwJSBib29zdCBmb3IgYmFsYW5jZWQgbWFya2V0c1xuICB9XG4gIFxuICByZXR1cm4gc2NvcmU7XG59XG5cbi8qKlxuICogSG9vayB0byBmZXRjaCBhbGwgbWFya2V0cyBmcm9tIHRoZSBmYWN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXJrZXRzKCkge1xuICBjb25zdCBbbWFya2V0cywgc2V0TWFya2V0c10gPSB1c2VTdGF0ZTxNYXJrZXREYXRhW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZmV0Y2hNYXJrZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IGZhY3RvcnkgPSBnZXRGYWN0b3J5Q29udHJhY3QocHJvdmlkZXIpO1xuXG4gICAgICAvLyBHZXQgYWxsIG1hcmtldCBhZGRyZXNzZXMgZnJvbSBmYWN0b3J5IChPTkxZIG9uLWNoYWluIG1hcmtldHMgLSBubyBtb2NrcylcbiAgICAgIGNvbnN0IG1hcmtldEFkZHJlc3Nlczogc3RyaW5nW10gPSBhd2FpdCBmYWN0b3J5LmdldE1hcmtldHMoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHttYXJrZXRBZGRyZXNzZXMubGVuZ3RofSBvbi1jaGFpbiBtYXJrZXRzIGZyb20gZmFjdG9yeSBjb250cmFjdGApO1xuICAgICAgXG4gICAgICAvLyBGZXRjaCBNYXJrZXRDcmVhdGVkIGV2ZW50cyB0byBnZXQgY3JlYXRpb24gdHJhbnNhY3Rpb24gaGFzaGVzIGFuZCBjcmVhdG9yIGFkZHJlc3Nlc1xuICAgICAgY29uc3QgY3JlYXRpb25UeE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICBjb25zdCBjcmVhdG9yTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFF1ZXJ5IE1hcmtldENyZWF0ZWQgZXZlbnRzIGZyb20gdGhlIGZhY3RvcnkgY29udHJhY3RcbiAgICAgICAgLy8gRXZlbnQgc2lnbmF0dXJlOiBNYXJrZXRDcmVhdGVkKGFkZHJlc3MgaW5kZXhlZCBtYXJrZXQsIGFkZHJlc3MgaW5kZXhlZCBjcmVhdG9yLCBhZGRyZXNzIGluZGV4ZWQgZmVlZEFkZHJlc3MpXG4gICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBldGhlcnMuaWQoXCJNYXJrZXRDcmVhdGVkKGFkZHJlc3MsYWRkcmVzcyxhZGRyZXNzKVwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgIGFkZHJlc3M6IEZBQ1RPUllfQUREUkVTUyxcbiAgICAgICAgICB0b3BpY3M6IFtldmVudFRvcGljXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke2V2ZW50cy5sZW5ndGh9IE1hcmtldENyZWF0ZWQgZXZlbnRzYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBQYXJzZSBldmVudHNcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCB0cmFuc2FjdGlvbiB0byBmaW5kIHNlbmRlciAoY3JlYXRvcilcbiAgICAgICAgICAgIGxldCB0eFNlbmRlcjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGxvZy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICBpZiAodHggJiYgdHguZnJvbSkge1xuICAgICAgICAgICAgICAgIHR4U2VuZGVyID0gdHguZnJvbS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoICh0eEVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gJHtsb2cudHJhbnNhY3Rpb25IYXNofTpgLCB0eEVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdXNpbmcgZmFjdG9yeSBpbnRlcmZhY2VcbiAgICAgICAgICAgIGxldCBkZWNvZGVkOiBhbnkgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZGVjb2RlZCA9IGZhY3RvcnkuaW50ZXJmYWNlLnBhcnNlTG9nKHtcbiAgICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3MsXG4gICAgICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnIpIHtcbiAgICAgICAgICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIHBhcnNpbmcgLSBleHRyYWN0IGZyb20gdG9waWNzIGRpcmVjdGx5XG4gICAgICAgICAgICAgIGlmIChsb2cudG9waWNzICYmIGxvZy50b3BpY3MubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAvLyB0b3BpY3NbMF0gPSBldmVudCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICAvLyB0b3BpY3NbMV0gPSBtYXJrZXQgYWRkcmVzcyAoZmlyc3QgaW5kZXhlZCBwYXJhbSlcbiAgICAgICAgICAgICAgICAvLyB0b3BpY3NbMl0gPSBjcmVhdG9yIGFkZHJlc3MgKHNlY29uZCBpbmRleGVkIHBhcmFtKVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtldEFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzFdLnNsaWNlKDI2KSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdG9yQWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKFwiMHhcIiArIGxvZy50b3BpY3NbMl0uc2xpY2UoMjYpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICBjcmVhdG9yTWFwLnNldChtYXJrZXRBZGRyZXNzLCBjcmVhdG9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBFeHRyYWN0ZWQgY3JlYXRvciBmcm9tIHRvcGljczogJHtjcmVhdG9yQWRkcmVzc30gZm9yIG1hcmtldCAke21hcmtldEFkZHJlc3N9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgZGVjb2RlZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgIGlmIChkZWNvZGVkICYmIGRlY29kZWQuYXJncykge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZGVjb2RlZC5hcmdzLm1hcmtldD8udG9Mb3dlckNhc2UoKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZC5hcmdzWzBdPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKG1hcmtldEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBUcnkgbXVsdGlwbGUgd2F5cyB0byBnZXQgY3JlYXRvclxuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0b3JBZGRyZXNzID0gZGVjb2RlZC5hcmdzLmNyZWF0b3I/LnRvTG93ZXJDYXNlKCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWQuYXJnc1sxXT8udG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eFNlbmRlcjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRvckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0b3JNYXAuc2V0KG1hcmtldEFkZHJlc3MsIGNyZWF0b3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRXh0cmFjdGVkIGNyZWF0b3I6ICR7Y3JlYXRvckFkZHJlc3N9IGZvciBtYXJrZXQgJHttYXJrZXRBZGRyZXNzfWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFt1c2VNYXJrZXRzXSBDb3VsZCBub3QgZXh0cmFjdCBjcmVhdG9yIGZvciBtYXJrZXQgJHttYXJrZXRBZGRyZXNzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eFNlbmRlciAmJiBsb2cudG9waWNzICYmIGxvZy50b3BpY3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSB0cmFuc2FjdGlvbiBzZW5kZXIgYXMgY3JlYXRvclxuICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1sxXS5zbGljZSgyNikpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGNyZWF0aW9uVHhNYXAuc2V0KG1hcmtldEFkZHJlc3MsIGxvZy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICBjcmVhdG9yTWFwLnNldChtYXJrZXRBZGRyZXNzLCB0eFNlbmRlcik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gVXNpbmcgdHggc2VuZGVyIGFzIGNyZWF0b3I6ICR7dHhTZW5kZXJ9IGZvciBtYXJrZXQgJHttYXJrZXRBZGRyZXNzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbdXNlTWFya2V0c10gRXJyb3IgcGFyc2luZyBldmVudCBsb2c6YCwgcGFyc2VFcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBDcmVhdG9yIG1hcCBzaXplOiAke2NyZWF0b3JNYXAuc2l6ZX0sIENyZWF0aW9uIHR4IG1hcCBzaXplOiAke2NyZWF0aW9uVHhNYXAuc2l6ZX1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZmV0Y2ggTWFya2V0Q3JlYXRlZCBldmVudHM6XCIsIGVycik7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kICR7bWFya2V0QWRkcmVzc2VzLmxlbmd0aH0gbWFya2V0cyBmcm9tIGZhY3Rvcnk6YCwgbWFya2V0QWRkcmVzc2VzKTtcblxuICAgICAgLy8gRmV0Y2ggbWV0YWRhdGEgZnJvbSBiYWNrZW5kIEFQSSAoT05MWSBmb3IgZW5yaWNoaW5nIG9uLWNoYWluIG1hcmtldHMgd2l0aCBtZXRhZGF0YSAtIG5vdCBmb3IgZGlzcGxheWluZylcbiAgICAgIC8vIEJhY2tlbmQgbWFya2V0cyBhcmUgbWF0Y2hlZCB0byBvbi1jaGFpbiBtYXJrZXRzIGJ5IG1hcmtldF9hZGRyZXNzXG4gICAgICBsZXQgYmFja2VuZE1hcmtldHM6IGFueVtdID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCI7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke2FwaVVybH0vYXBpL21hcmtldHNgKTtcbiAgICAgICAgYmFja2VuZE1hcmtldHMgPSByZXNwb25zZS5kYXRhIHx8IFtdO1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kICR7YmFja2VuZE1hcmtldHMubGVuZ3RofSBiYWNrZW5kIG1ldGFkYXRhIGVudHJpZXMgKGZvciBlbnJpY2htZW50IG9ubHksIG5vdCBkaXNwbGF5ZWQgc2VwYXJhdGVseSlgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0IG1ldGFkYXRhIGZyb20gYmFja2VuZDpcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGJhY2tlbmQgbWFya2V0cyBieSBtYXJrZXRfYWRkcmVzcyAocHJpbWFyeSkgYW5kIGZlZWRJZCAoZmFsbGJhY2spIGZvciBxdWljayBsb29rdXBcbiAgICAgIGNvbnN0IGJhY2tlbmRNYXBCeUFkZHJlc3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5RmVlZElkID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgIGJhY2tlbmRNYXJrZXRzLmZvckVhY2goKG06IGFueSkgPT4ge1xuICAgICAgICAvLyBQcmltYXJ5OiBtYXRjaCBieSBtYXJrZXRfYWRkcmVzcyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKG0ubWFya2V0X2FkZHJlc3MpIHtcbiAgICAgICAgICBjb25zdCBhZGRyTG93ZXIgPSBtLm1hcmtldF9hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYmFja2VuZE1hcEJ5QWRkcmVzcy5zZXQoYWRkckxvd2VyLCBtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjazogbWF0Y2ggYnkgZmVlZElkIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5mZWVkX2lkKSB7XG4gICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBtLmZlZWRfaWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuc2V0KGZlZWRJZExvd2VyLCBtKTtcbiAgICAgICAgICAvLyBBbHNvIHRyeSB3aXRob3V0IDB4IHByZWZpeCBpZiBwcmVzZW50XG4gICAgICAgICAgaWYgKGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIuc2xpY2UoMiksIG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZldGNoIGRhdGEgZm9yIGVhY2ggbWFya2V0IHVzaW5nIG5ldyBBQklcbiAgICAgIGNvbnN0IG1hcmtldFByb21pc2VzID0gbWFya2V0QWRkcmVzc2VzLm1hcChhc3luYyAoYWRkcmVzcykgPT4ge1xuICAgICAgICAvLyBVc2UgQnJvd3NlclByb3ZpZGVyIGFuZCBDb250cmFjdCBkaXJlY3RseSB3aXRoIG5ldyBBQklcbiAgICAgICAgbGV0IHByb3ZpZGVyRm9yQ29udHJhY3Q6IEJyb3dzZXJQcm92aWRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IG5ldyBCcm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gcHJvdmlkZXIgYXMgYW55IGFzIEJyb3dzZXJQcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXJrZXRDb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFdyYXAgZWFjaCBjYWxsIGluIGEgcHJvbWlzZSB0aGF0IGNhdGNoZXMgZXJyb3JzXG4gICAgICAgICAgY29uc3Qgc2FmZUNhbGwgPSBhc3luYyAoZm46ICgpID0+IFByb21pc2U8YW55PiwgZGVmYXVsdFZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVc2UgbmV3IEFCSSBtZXRob2RzOiBxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXG4gICAgICAgICAgLy8gQWxzbyB0cnkgdG8gcmVhZCBjcmVhdG9yIGRpcmVjdGx5IGZyb20gY29udHJhY3QgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgY29uc3QgW3F1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbWFya2V0Q29udHJhY3QucXVlc3Rpb24oKSxcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmRlYWRsaW5lKCksXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5yZXNvbHZlZCgpLFxuICAgICAgICAgICAgbWFya2V0Q29udHJhY3Qub3V0Y29tZSgpLCAvLyBlbnVtOiAwLDEsMlxuICAgICAgICAgIF0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byByZWFkIGNyZWF0b3IgZGlyZWN0bHkgZnJvbSBjb250cmFjdCAoc2ltcGxlc3QgbWV0aG9kKVxuICAgICAgICAgIGxldCBjcmVhdG9yRnJvbUNvbnRyYWN0OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3JlYXRvckZyb21Db250cmFjdCA9IGF3YWl0IG1hcmtldENvbnRyYWN0LmNyZWF0b3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIENvbnRyYWN0IG1pZ2h0IG5vdCBoYXZlIGNyZWF0b3IoKSBmdW5jdGlvbiwgdGhhdCdzIG9rYXlcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFt1c2VNYXJrZXRzXSBNYXJrZXQgJHthZGRyZXNzfSBkb2VzIG5vdCBoYXZlIGNyZWF0b3IoKSBmdW5jdGlvbmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgYWRkaXRpb25hbCBkYXRhIGlmIG1ldGhvZHMgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgICAgIGxldCBjdXJyZW50UHJpY2UgPSAwbjtcbiAgICAgICAgICBsZXQgbG9ja1ByaWNlID0gMG47XG4gICAgICAgICAgbGV0IHRvdGFsWWVzID0gMG47XG4gICAgICAgICAgbGV0IHRvdGFsTm8gPSAwbjtcbiAgICAgICAgICBsZXQgZmVlZElkID0gXCIweDBcIjtcbiAgICAgICAgICBsZXQgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgW2N1cnJlbnRQcmljZSwgbG9ja1ByaWNlLCBzdGF0ZSwgdG90YWxZZXMsIHRvdGFsTm8sIGZlZWRJZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnN0YXRlKCksIDApLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC50b3RhbFllcygpLCAwbiksXG4gICAgICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsTm8oKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5mZWVkSWQoKSwgXCIweDBcIiksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIG1ldGhvZHMgZG9uJ3QgZXhpc3QsIGRlZmF1bHRzIGFyZSBhbHJlYWR5IHNldCBhYm92ZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTb21lIG9wdGlvbmFsIG1ldGhvZHMgbm90IGF2YWlsYWJsZSBmb3IgbWFya2V0ICR7YWRkcmVzc30sIHVzaW5nIGRlZmF1bHRzYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTWFwIHJlc29sdmVkL291dGNvbWUgdG8gTWFya2V0U3RhdGVcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIoZGVhZGxpbmUpIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkxvY2tlZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgKHJlbW92ZSBudWxsIGJ5dGVzKSBpZiBpdCdzIGEgYnl0ZXMzMlxuICAgICAgICAgIGxldCBmZWVkSWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGxldCBmZWVkSWRIZXggPSBcIjB4MFwiO1xuICAgICAgICAgIGlmIChmZWVkSWQgJiYgZmVlZElkICE9PSBcIjB4MFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuICAgICAgICAgICAgICBmZWVkSWRIZXggPSBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBmZWVkSWRIZXggPSB0eXBlb2YgZmVlZElkID09PSBcInN0cmluZ1wiID8gZmVlZElkIDogZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgbWF0Y2hpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldCBhZGRyZXNzIChtb3N0IHJlbGlhYmxlKVxuICAgICAgICAgIGNvbnN0IGFkZHJlc3NMb3dlciA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsZXQgYmFja2VuZE1hcmtldCA9IGJhY2tlbmRNYXBCeUFkZHJlc3MuZ2V0KGFkZHJlc3NMb3dlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmFsbGJhY2s6IG1hdGNoIGJ5IGZlZWRJZCBpZiBhZGRyZXNzIG1hdGNoIGZhaWxlZFxuICAgICAgICAgIGlmICghYmFja2VuZE1hcmtldCkge1xuICAgICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBmZWVkSWRIZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRJZE5vUHJlZml4ID0gZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSA/IGZlZWRJZExvd2VyLnNsaWNlKDIpIDogZmVlZElkTG93ZXI7XG4gICAgICAgICAgICBiYWNrZW5kTWFya2V0ID0gYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRMb3dlcikgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZE5vUHJlZml4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRTdHIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY3JlYXRpb25UeEhhc2ggPSBjcmVhdGlvblR4TWFwLmdldChhZGRyZXNzTG93ZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByaW9yaXR5IDE6IFJlYWQgY3JlYXRvciBkaXJlY3RseSBmcm9tIGNvbnRyYWN0IChzaW1wbGVzdCBhbmQgbW9zdCByZWxpYWJsZSlcbiAgICAgICAgICBsZXQgY3JlYXRvckFkZHJlc3MgPSBjcmVhdG9yRnJvbUNvbnRyYWN0ID8gY3JlYXRvckZyb21Db250cmFjdC50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcmlvcml0eSAyOiBVc2UgY3JlYXRvciBmcm9tIGV2ZW50IG1hcCAoZnJvbSBpbml0aWFsIGV2ZW50IHBhcnNpbmcpXG4gICAgICAgICAgaWYgKCFjcmVhdG9yQWRkcmVzcykge1xuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3MgPSBjcmVhdG9yTWFwLmdldChhZGRyZXNzTG93ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcmlvcml0eSAzOiBVc2UgYmFja2VuZCBjcmVhdG9yX2FkZHJlc3NcbiAgICAgICAgICBpZiAoIWNyZWF0b3JBZGRyZXNzICYmIGJhY2tlbmRNYXJrZXQ/LmNyZWF0b3JfYWRkcmVzcykge1xuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3MgPSBiYWNrZW5kTWFya2V0LmNyZWF0b3JfYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBVc2luZyBjcmVhdG9yIGZyb20gYmFja2VuZDogJHtjcmVhdG9yQWRkcmVzc30gZm9yIG1hcmtldCAke2FkZHJlc3N9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByaW9yaXR5IDQ6IEZldGNoIGZyb20gdHJhbnNhY3Rpb24gaWYgd2UgaGF2ZSBjcmVhdGlvblR4SGFzaFxuICAgICAgICAgIGlmICghY3JlYXRvckFkZHJlc3MgJiYgY3JlYXRpb25UeEhhc2gpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oY3JlYXRpb25UeEhhc2gpO1xuICAgICAgICAgICAgICBpZiAodHggJiYgdHguZnJvbSkge1xuICAgICAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzID0gdHguZnJvbS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNyZWF0b3JNYXAuc2V0KGFkZHJlc3NMb3dlciwgY3JlYXRvckFkZHJlc3MpOyAvLyBDYWNoZSBpdFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRmV0Y2hlZCBjcmVhdG9yIGZyb20gdHJhbnNhY3Rpb246ICR7Y3JlYXRvckFkZHJlc3N9IGZvciBtYXJrZXQgJHthZGRyZXNzfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoICh0eEVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFt1c2VNYXJrZXRzXSBGYWlsZWQgdG8gZmV0Y2ggY3JlYXRvciBmcm9tIHR4ICR7Y3JlYXRpb25UeEhhc2h9OmAsIHR4RXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJpb3JpdHkgNTogVHJ5IHRvIGZpbmQgY3JlYXRpb24gdHJhbnNhY3Rpb24gYnkgc2VhcmNoaW5nIGZvciBNYXJrZXRDcmVhdGVkIGV2ZW50cyBmb3IgdGhpcyBzcGVjaWZpYyBtYXJrZXRcbiAgICAgICAgICBpZiAoIWNyZWF0b3JBZGRyZXNzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBRdWVyeSBldmVudHMgZmlsdGVyZWQgYnkgdGhpcyBzcGVjaWZpYyBtYXJrZXQgYWRkcmVzc1xuICAgICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0gZXRoZXJzLmlkKFwiTWFya2V0Q3JlYXRlZChhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcylcIik7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtldFRvcGljID0gZXRoZXJzLnplcm9QYWRWYWx1ZShhZGRyZXNzLCAzMik7IC8vIFBhZCBhZGRyZXNzIHRvIDMyIGJ5dGVzIGZvciB0b3BpY1xuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogRkFDVE9SWV9BRERSRVNTLFxuICAgICAgICAgICAgICAgIHRvcGljczogW2V2ZW50VG9waWMsIG1hcmtldFRvcGljXSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3QgbWFya2V0RXZlbnRzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKG1hcmtldEV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nID0gbWFya2V0RXZlbnRzWzBdO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgY3JlYXRvciBmcm9tIHRvcGljc1syXVxuICAgICAgICAgICAgICAgIGlmIChsb2cudG9waWNzICYmIGxvZy50b3BpY3MubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1syXS5zbGljZSgyNikpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICBjcmVhdG9yTWFwLnNldChhZGRyZXNzTG93ZXIsIGNyZWF0b3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgY3JlYXRvciBmcm9tIG1hcmtldC1zcGVjaWZpYyBldmVudDogJHtjcmVhdG9yQWRkcmVzc30gZm9yIG1hcmtldCAke2FkZHJlc3N9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChldmVudEVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFt1c2VNYXJrZXRzXSBGYWlsZWQgdG8gZmV0Y2ggY3JlYXRvciBmcm9tIGV2ZW50cyBmb3IgbWFya2V0ICR7YWRkcmVzc306YCwgZXZlbnRFcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY3JlYXRvckFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gY3JlYXRvcjogJHtjcmVhdG9yQWRkcmVzc30gKGZyb20gJHtjcmVhdG9yRnJvbUNvbnRyYWN0ID8gJ2NvbnRyYWN0JyA6IGNyZWF0b3JNYXAuaGFzKGFkZHJlc3NMb3dlcikgPyAnZXZlbnRzJyA6IGJhY2tlbmRNYXJrZXQ/LmNyZWF0b3JfYWRkcmVzcyA/ICdiYWNrZW5kJyA6ICd0cmFuc2FjdGlvbid9KWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4dHJhY3QgaW1hZ2VVcmwgZnJvbSBiYWNrZW5kIG1hcmtldCAoc3VwcG9ydCBib3RoIHNuYWtlX2Nhc2UgYW5kIGNhbWVsQ2FzZSlcbiAgICAgICAgICBjb25zdCBpbWFnZVVybCA9IGJhY2tlbmRNYXJrZXQ/LmltYWdlX3VybCB8fCBiYWNrZW5kTWFya2V0Py5pbWFnZVVybCB8fCBudWxsO1xuICAgICAgICAgIGlmIChpbWFnZVVybCAmJiBhZGRyZXNzTG93ZXIgPT09IG1hcmtldEFkZHJlc3Nlc1swXT8udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBNYXJrZXQgJHthZGRyZXNzfSBoYXMgaW1hZ2VVcmw6YCwgaW1hZ2VVcmwuc3Vic3RyaW5nKDAsIDEwMCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHF1ZXN0aW9uIC0gcHJpb3JpdGl6ZSBjb250cmFjdCwgdGhlbiBiYWNrZW5kLCB0aGVuIGZhbGxiYWNrXG4gICAgICAgICAgY29uc3QgZGlzcGxheVF1ZXN0aW9uID0gcXVlc3Rpb24gfHwgYmFja2VuZE1hcmtldD8ucXVlc3Rpb24gfHwgYE1hcmtldCAke2FkZHJlc3Muc2xpY2UoMCwgOCl9Li4uJHthZGRyZXNzLnNsaWNlKC02KX1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhdGVnb3J5OiB1c2UgYmFja2VuZCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB0cnkgdG8gaW5mZXIgb3IgdXNlIFwiT3RoZXJcIlxuICAgICAgICAgIGNvbnN0IGRpc3BsYXlDYXRlZ29yeSA9IGJhY2tlbmRNYXJrZXQ/LmNhdGVnb3J5IHx8IFwiT3RoZXJcIjtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBtYXJrZXREYXRhOiBNYXJrZXREYXRhID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZWRJZDogZmVlZElkSGV4LFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBjdXJyZW50UHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihjdXJyZW50UHJpY2UpIDogXCIwXCIsXG4gICAgICAgICAgICBsb2NrUHJpY2U6IGxvY2tQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGxvY2tQcmljZSkgOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSBhcyBNYXJrZXRTdGF0ZSxcbiAgICAgICAgICAgIHRvdGFsWWVzOiB0b3RhbFllcyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSA6IFwiMFwiLFxuICAgICAgICAgICAgdG90YWxObzogdG90YWxObyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsTm8pIDogXCIwXCIsXG4gICAgICAgICAgICAvLyBVc2UgcXVlc3Rpb24gZnJvbSBjb250cmFjdCBmaXJzdCAobW9zdCByZWxpYWJsZSksIGZhbGxiYWNrIHRvIGJhY2tlbmQsIHRoZW4gZ2VuZXJpY1xuICAgICAgICAgICAgcXVlc3Rpb246IGRpc3BsYXlRdWVzdGlvbixcbiAgICAgICAgICAgIGNhdGVnb3J5OiBkaXNwbGF5Q2F0ZWdvcnksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYmFja2VuZE1hcmtldD8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpbWFnZVVybDogaW1hZ2VVcmwsIC8vIFNldCBpbWFnZVVybCBleHBsaWNpdGx5IChmcm9tIGJhY2tlbmQgaWYgYXZhaWxhYmxlKVxuICAgICAgICAgICAgY3JlYXRpb25UeEhhc2g6IGNyZWF0aW9uVHhIYXNoLFxuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3M6IGNyZWF0b3JBZGRyZXNzLCAvLyBTaG91bGQgYWx3YXlzIGJlIHNldCBieSBub3cgKGZyb20gZXZlbnRzIG9yIGJhY2tlbmQpXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IGJhY2tlbmRNYXJrZXQ/LmNyZWF0ZWRfYXQgfHwgYmFja2VuZE1hcmtldD8uY3JlYXRlZEF0LCAvLyBTdXBwb3J0IGJvdGggbmFtaW5nIGNvbnZlbnRpb25zXG4gICAgICAgICAgICAvLyBJbmNsdWRlIGJhY2tlbmQgbWFya2V0X2lkIGZvciBBUEkgY2FsbHMgKE1hcmtldEluZm8sIE1hcmtldENoYXQpXG4gICAgICAgICAgICBtYXJrZXRJZDogYmFja2VuZE1hcmtldD8ubWFya2V0X2lkIHx8IGJhY2tlbmRNYXJrZXQ/LmlkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBpZiBtYXJrZXQgaXMgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAgICAgaWYgKCFiYWNrZW5kTWFya2V0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIE1hcmtldCAke2FkZHJlc3N9IGlzIG9uLWNoYWluIGJ1dCBtaXNzaW5nIGJhY2tlbmQgbWV0YWRhdGEuIFVzaW5nIGNvbnRyYWN0IGRhdGEgb25seS5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWFya2V0RGF0YTtcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBtYXJrZXQgJHthZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgICAgIC8vIFRyeSB0byBnZXQgYXQgbGVhc3QgYmFzaWMgZGF0YSB1c2luZyBuZXcgQUJJIGlmIG90aGVyIGNhbGxzIGZhaWxcbiAgICAgICAgICBsZXQgcXVlc3Rpb24gPSBcIlwiO1xuICAgICAgICAgIGxldCBkZWFkbGluZSA9IDA7XG4gICAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IG91dGNvbWUgPSAwbjtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFzaWNDb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcbiAgICAgICAgICAgIFtxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0LmRlYWRsaW5lKCksXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3QucmVzb2x2ZWQoKSxcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5vdXRjb21lKCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGNhdGNoIChxdWVzdGlvbkVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmV0Y2ggYmFzaWMgZGF0YSBmb3IgbWFya2V0ICR7YWRkcmVzc306YCwgcXVlc3Rpb25FcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgc3RhdGUgZnJvbSByZXNvbHZlZC9kZWFkbGluZVxuICAgICAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWFkbGluZSA+IDAgJiYgZGVhZGxpbmUgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuTG9ja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXR1cm4gbWluaW1hbCBkYXRhIGlmIGNvbnRyYWN0IGNhbGwgZmFpbHMsIGJ1dCBzdGlsbCBpbmNsdWRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIG1hcmtldHMgYXJlIHNob3duIGV2ZW4gaWYgc29tZSBjYWxscyBmYWlsXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IFwiXCIsXG4gICAgICAgICAgICBjdXJyZW50UHJpY2U6IFwiMFwiLFxuICAgICAgICAgICAgbG9ja1ByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIHRvdGFsWWVzOiBcIjBcIixcbiAgICAgICAgICAgIHRvdGFsTm86IFwiMFwiLFxuICAgICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uIHx8IGBNYXJrZXQgJHthZGRyZXNzLnNsaWNlKDAsIDgpfS4uLiR7YWRkcmVzcy5zbGljZSgtNil9YCxcbiAgICAgICAgICB9IGFzIE1hcmtldERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtYXJrZXREYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwobWFya2V0UHJvbWlzZXMpO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCBkYXRhIGZvciAke21hcmtldERhdGEubGVuZ3RofSBtYXJrZXRzYCk7XG4gICAgICBcbiAgICAgIC8vIEJhdGNoIGZldGNoIGNyZWF0b3JzIGZvciBtYXJrZXRzIHRoYXQgYXJlIHN0aWxsIG1pc3NpbmcgdGhlbVxuICAgICAgY29uc3QgbWFya2V0c05lZWRpbmdDcmVhdG9ycyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4gXG4gICAgICAgIG0uYWRkcmVzcyAmJiBcbiAgICAgICAgbS5hZGRyZXNzICE9PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiICYmXG4gICAgICAgICFtLmNyZWF0b3JBZGRyZXNzXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAobWFya2V0c05lZWRpbmdDcmVhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gJHttYXJrZXRzTmVlZGluZ0NyZWF0b3JzLmxlbmd0aH0gbWFya2V0cyBtaXNzaW5nIGNyZWF0b3JzLCBhdHRlbXB0aW5nIHRvIGZldGNoLi4uYCk7XG4gICAgICAgIC8vIFRyeSB0byBmZXRjaCBjcmVhdG9ycyBmcm9tIHRoZWlyIGNyZWF0aW9uIHRyYW5zYWN0aW9ucyBpbiBwYXJhbGxlbFxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChtYXJrZXRzTmVlZGluZ0NyZWF0b3JzLm1hcChhc3luYyAobWFya2V0KSA9PiB7XG4gICAgICAgICAgY29uc3QgYWRkcmVzc0xvd2VyID0gbWFya2V0LmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBNYXJrZXRDcmVhdGVkIGV2ZW50IGZvciB0aGlzIHNwZWNpZmljIG1hcmtldFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0gZXRoZXJzLmlkKFwiTWFya2V0Q3JlYXRlZChhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcylcIik7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXRUb3BpYyA9IGV0aGVycy56ZXJvUGFkVmFsdWUobWFya2V0LmFkZHJlc3MsIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgYWRkcmVzczogRkFDVE9SWV9BRERSRVNTLFxuICAgICAgICAgICAgICB0b3BpY3M6IFtldmVudFRvcGljLCBtYXJrZXRUb3BpY10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9nID0gZXZlbnRzWzBdO1xuICAgICAgICAgICAgICBpZiAobG9nLnRvcGljcyAmJiBsb2cudG9waWNzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRvciA9IGV0aGVycy5nZXRBZGRyZXNzKFwiMHhcIiArIGxvZy50b3BpY3NbMl0uc2xpY2UoMjYpKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIG1hcmtldC5jcmVhdG9yQWRkcmVzcyA9IGNyZWF0b3I7XG4gICAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQoYWRkcmVzc0xvd2VyLCBjcmVhdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kIGNyZWF0b3IgZm9yICR7bWFya2V0LmFkZHJlc3N9OiAke2NyZWF0b3J9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3VzZU1hcmtldHNdIENvdWxkIG5vdCBmZXRjaCBjcmVhdG9yIGZvciAke21hcmtldC5hZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBdXRvLXN5bmM6IENyZWF0ZSBiYWNrZW5kIGVudHJpZXMgZm9yIG9uLWNoYWluIG1hcmtldHMgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgYWxsIG1hcmtldHMgaGF2ZSBjb21wbGV0ZSBkYXRhXG4gICAgICBjb25zdCBtYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jID0gbWFya2V0RGF0YS5maWx0ZXIobSA9PiBcbiAgICAgICAgbS5hZGRyZXNzICYmIFxuICAgICAgICBtLmFkZHJlc3MgIT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIgJiZcbiAgICAgICAgIW0ubWFya2V0SWQgJiYgLy8gTm8gYmFja2VuZCBJRCBtZWFucyBubyBiYWNrZW5kIGVudHJ5XG4gICAgICAgIG0ucXVlc3Rpb24gJiYgLy8gSGFzIHF1ZXN0aW9uIGZyb20gY29udHJhY3RcbiAgICAgICAgbS5xdWVzdGlvbiAhPT0gYE1hcmtldCAke20uYWRkcmVzcy5zbGljZSgwLCA4KX0uLi4ke20uYWRkcmVzcy5zbGljZSgtNil9YCAvLyBOb3QganVzdCBmYWxsYmFja1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKG1hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdICR7bWFya2V0c05lZWRpbmdCYWNrZW5kU3luYy5sZW5ndGh9IG9uLWNoYWluIG1hcmtldHMgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhLiBBdXRvLXN5bmNpbmcuLi5gKTtcbiAgICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBiYWNrZW5kIGVudHJpZXMgZm9yIHRoZXNlIG1hcmtldHMgKG5vbi1ibG9ja2luZylcbiAgICAgICAgUHJvbWlzZS5hbGwobWFya2V0c05lZWRpbmdCYWNrZW5kU3luYy5tYXAoYXN5bmMgKG1hcmtldCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCI7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBiYWNrZW5kIGVudHJ5IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICBjb25zdCBiYWNrZW5kTWFya2V0cyA9IGF3YWl0IGF4aW9zLmdldChgJHthcGlVcmx9L2FwaS9tYXJrZXRzYCk7XG4gICAgICAgICAgICBjb25zdCBleGlzdHMgPSBiYWNrZW5kTWFya2V0cy5kYXRhLnNvbWUoKG06IGFueSkgPT4gXG4gICAgICAgICAgICAgIG0ubWFya2V0X2FkZHJlc3M/LnRvTG93ZXJDYXNlKCkgPT09IG1hcmtldC5hZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghZXhpc3RzICYmIG1hcmtldC5xdWVzdGlvbiAmJiBtYXJrZXQuY3JlYXRvckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIGJhY2tlbmQgZW50cnkgd2l0aCBjb250cmFjdCBkYXRhXG4gICAgICAgICAgICAgIGF3YWl0IGF4aW9zLnBvc3QoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2AsIHtcbiAgICAgICAgICAgICAgICBxdWVzdGlvbjogbWFya2V0LnF1ZXN0aW9uLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBtYXJrZXQuY2F0ZWdvcnkgfHwgXCJPdGhlclwiLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA3ICogMjQgKiA2MCAqIDYwLCAvLyBEZWZhdWx0IDcgZGF5c1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb25EZWxheTogMjQgKiA2MCAqIDYwLCAvLyBEZWZhdWx0IDI0IGhvdXJzXG4gICAgICAgICAgICAgICAgaW1hZ2VVcmw6IG1hcmtldC5pbWFnZVVybCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG9yYWNsZVR5cGU6IFwiY2hhaW5saW5rXCIsIC8vIERlZmF1bHRcbiAgICAgICAgICAgICAgICBjcmVhdG9yQWRkcmVzczogbWFya2V0LmNyZWF0b3JBZGRyZXNzLFxuICAgICAgICAgICAgICAgIG1hcmtldEFkZHJlc3M6IG1hcmtldC5hZGRyZXNzLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBBdXRvLWNyZWF0ZWQgYmFja2VuZCBlbnRyeSBmb3IgbWFya2V0ICR7bWFya2V0LmFkZHJlc3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBTaWxlbnRseSBmYWlsIC0gdGhpcyBpcyBqdXN0IGEgc3luYyBhdHRlbXB0XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbdXNlTWFya2V0c10gQ291bGQgbm90IGF1dG8tc3luYyBtYXJrZXQgJHttYXJrZXQuYWRkcmVzc306YCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9ycyAtIHRoaXMgaXMgYmVzdCBlZmZvcnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciBvdXQgbWFya2V0cyB3aXRoIGVtcHR5L2ludmFsaWQgYWRkcmVzc2VzIC0gb25seSBzaG93IHJlYWwgb24tY2hhaW4gbWFya2V0c1xuICAgICAgY29uc3QgdmFsaWRNYXJrZXRzID0gbWFya2V0RGF0YS5maWx0ZXIobSA9PiB7XG4gICAgICAgIC8vIE11c3QgaGF2ZSBhIHZhbGlkIGFkZHJlc3NcbiAgICAgICAgaWYgKCFtLmFkZHJlc3MgfHwgbS5hZGRyZXNzID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11c3QgYmUgYSB2YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFxuICAgICAgICBpZiAoIS9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KG0uYWRkcmVzcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVzdCBoYXZlIGJlZW4gZmV0Y2hlZCBmcm9tIGZhY3RvcnkgKGV4aXN0cyBpbiBtYXJrZXRBZGRyZXNzZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IG1hcmtldHNXaXRoQ3JlYXRvcnMgPSB2YWxpZE1hcmtldHMuZmlsdGVyKG0gPT4gbS5jcmVhdG9yQWRkcmVzcykubGVuZ3RoO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBWYWxpZCBvbi1jaGFpbiBtYXJrZXRzOiAke3ZhbGlkTWFya2V0cy5sZW5ndGh9LCBNYXJrZXRzIHdpdGggY3JlYXRvcnM6ICR7bWFya2V0c1dpdGhDcmVhdG9yc31gKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHRyZW5kaW5nIHNjb3JlcyBhbmQgYWRkIHRvIG1hcmtldCBkYXRhXG4gICAgICBjb25zdCBtYXJrZXRzV2l0aFRyZW5kaW5nID0gdmFsaWRNYXJrZXRzLm1hcChtYXJrZXQgPT4gKHtcbiAgICAgICAgLi4ubWFya2V0LFxuICAgICAgICB0cmVuZGluZ1Njb3JlOiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldCksXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRmluYWwgbWFya2V0cyB0byBkaXNwbGF5OmAsIG1hcmtldHNXaXRoVHJlbmRpbmcubWFwKG0gPT4gKHsgXG4gICAgICAgIGFkZHJlc3M6IG0uYWRkcmVzcywgXG4gICAgICAgIHF1ZXN0aW9uOiBtLnF1ZXN0aW9uIHx8ICdObyBxdWVzdGlvbicsIFxuICAgICAgICBoYXNJbWFnZTogISFtLmltYWdlVXJsLFxuICAgICAgICBpbWFnZVVybDogbS5pbWFnZVVybCA/IGAke20uaW1hZ2VVcmwuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogJ25vbmUnXG4gICAgICB9KSkpO1xuICAgICAgXG4gICAgICBzZXRNYXJrZXRzKG1hcmtldHNXaXRoVHJlbmRpbmcpO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldHM6XCIsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoTWFya2V0cygpO1xuICB9LCBbZmV0Y2hNYXJrZXRzXSk7XG5cbiAgcmV0dXJuIHsgbWFya2V0cywgbG9hZGluZywgZXJyb3IsIHJlZmV0Y2g6IGZldGNoTWFya2V0cyB9O1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYSBzaW5nbGUgbWFya2V0J3MgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0KG1hcmtldEFkZHJlc3M6IHN0cmluZyB8IG51bGwpIHtcbiAgY29uc3QgW21hcmtldCwgc2V0TWFya2V0XSA9IHVzZVN0YXRlPE1hcmtldERhdGEgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmZXRjaE1hcmtldCgpO1xuICB9LCBbbWFya2V0QWRkcmVzc10pO1xuXG4gIGNvbnN0IGZldGNoTWFya2V0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbWFya2V0QWRkcmVzcykgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgLy8gVXNlIEJyb3dzZXJQcm92aWRlciBhbmQgQ29udHJhY3QgZGlyZWN0bHkgd2l0aCBuZXcgQUJJXG4gICAgICBsZXQgcHJvdmlkZXJGb3JDb250cmFjdDogQnJvd3NlclByb3ZpZGVyO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBuZXcgQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBiYXNlUHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gYmFzZVByb3ZpZGVyIGFzIGFueSBhcyBCcm93c2VyUHJvdmlkZXI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KG1hcmtldEFkZHJlc3MsIE1BUktFVF9BQkksIHByb3ZpZGVyRm9yQ29udHJhY3QpO1xuXG4gICAgICAvLyBVc2UgbmV3IEFCSSBtZXRob2RzOiBxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXG4gICAgICBjb25zdCBbcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIG1hcmtldENvbnRyYWN0LnF1ZXN0aW9uKCksXG4gICAgICAgIG1hcmtldENvbnRyYWN0LmRlYWRsaW5lKCksXG4gICAgICAgIG1hcmtldENvbnRyYWN0LnJlc29sdmVkKCksXG4gICAgICAgIG1hcmtldENvbnRyYWN0Lm91dGNvbWUoKSwgLy8gZW51bTogMCwxLDJcbiAgICAgIF0pO1xuXG4gICAgICAvLyBUcnkgdG8gZ2V0IGFkZGl0aW9uYWwgZGF0YSBpZiBtZXRob2RzIGV4aXN0IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgIGxldCBjdXJyZW50UHJpY2UgPSAwbjtcbiAgICAgIGxldCBsb2NrUHJpY2UgPSAwbjtcbiAgICAgIGxldCB0b3RhbFllcyA9IDBuO1xuICAgICAgbGV0IHRvdGFsTm8gPSAwbjtcbiAgICAgIGxldCBmZWVkSWQgPSBcIjB4MFwiO1xuICAgICAgbGV0IHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuXG4gICAgICAvLyBUcnkgdG8gZ2V0IGFkZGl0aW9uYWwgZGF0YSBpZiBtZXRob2RzIGV4aXN0IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgIC8vIFdyYXAgZWFjaCBjYWxsIGluIGEgcHJvbWlzZSB0aGF0IGNhdGNoZXMgZXJyb3JzXG4gICAgICBjb25zdCBzYWZlQ2FsbCA9IGFzeW5jIChmbjogKCkgPT4gUHJvbWlzZTxhbnk+LCBkZWZhdWx0VmFsdWU6IGFueSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0cnkge1xuICAgICAgICBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5nZXRDdXJyZW50UHJpY2UoKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpLCAwbiksXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3Quc3RhdGUoKSwgMCksXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QudG90YWxZZXMoKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsTm8oKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLCBcIjB4MFwiKSxcbiAgICAgICAgXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWYgbWV0aG9kcyBkb24ndCBleGlzdCwgZGVmYXVsdHMgYXJlIGFscmVhZHkgc2V0IGFib3ZlXG4gICAgICAgIGNvbnNvbGUud2FybihgU29tZSBvcHRpb25hbCBtZXRob2RzIG5vdCBhdmFpbGFibGUgZm9yIG1hcmtldCAke21hcmtldEFkZHJlc3N9LCB1c2luZyBkZWZhdWx0c2ApO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXAgcmVzb2x2ZWQvb3V0Y29tZSB0byBNYXJrZXRTdGF0ZVxuICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICB9IGVsc2UgaWYgKE51bWJlcihkZWFkbGluZSkgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5Mb2NrZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgaWYgYXZhaWxhYmxlXG4gICAgICBsZXQgZmVlZElkU3RyID0gXCJcIjtcbiAgICAgIGxldCBmZWVkSWRIZXggPSBcIjB4MFwiO1xuICAgICAgaWYgKGZlZWRJZCAmJiBmZWVkSWQgIT09IFwiMHgwXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuICAgICAgICAgIGZlZWRJZEhleCA9IGZlZWRJZFN0ciB8fCBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBmZWVkSWRIZXggPSB0eXBlb2YgZmVlZElkID09PSBcInN0cmluZ1wiID8gZmVlZElkIDogZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRNYXJrZXQoe1xuICAgICAgICBhZGRyZXNzOiBtYXJrZXRBZGRyZXNzLFxuICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgY3VycmVudFByaWNlOiBjdXJyZW50UHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihjdXJyZW50UHJpY2UpIDogXCIwXCIsXG4gICAgICAgIGxvY2tQcmljZTogbG9ja1ByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIobG9ja1ByaWNlKSA6IFwiMFwiLFxuICAgICAgICBzdGF0ZTogc3RhdGUgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgIHRvdGFsWWVzOiB0b3RhbFllcyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSA6IFwiMFwiLFxuICAgICAgICB0b3RhbE5vOiB0b3RhbE5vID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxObykgOiBcIjBcIixcbiAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0OlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0XCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgbWFya2V0LCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXQgfTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJldGhlcnMiLCJCcm93c2VyUHJvdmlkZXIiLCJDb250cmFjdCIsImF4aW9zIiwibWFya2V0QXJ0aWZhY3QiLCJnZXRGYWN0b3J5Q29udHJhY3QiLCJnZXRQcm92aWRlciIsIk1hcmtldFN0YXRlIiwiRkFDVE9SWV9BRERSRVNTIiwiTUFSS0VUX0FCSSIsImFiaSIsImNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUiLCJtYXJrZXQiLCJ0b3RhbFllcyIsInBhcnNlRmxvYXQiLCJ0b3RhbE5vIiwidG90YWxMaXF1aWRpdHkiLCJzY29yZSIsInN0YXRlIiwiQWN0aXZlIiwiYmFsYW5jZSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1c2VNYXJrZXRzIiwibWFya2V0cyIsInNldE1hcmtldHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJmZXRjaE1hcmtldHMiLCJwcm92aWRlciIsImZhY3RvcnkiLCJtYXJrZXRBZGRyZXNzZXMiLCJnZXRNYXJrZXRzIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImNyZWF0aW9uVHhNYXAiLCJNYXAiLCJjcmVhdG9yTWFwIiwiZXZlbnRUb3BpYyIsImlkIiwiZmlsdGVyIiwiYWRkcmVzcyIsInRvcGljcyIsImV2ZW50cyIsImdldExvZ3MiLCJ0eFNlbmRlciIsInR4IiwiZ2V0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbkhhc2giLCJmcm9tIiwidG9Mb3dlckNhc2UiLCJ0eEVyciIsIndhcm4iLCJkZWNvZGVkIiwiaW50ZXJmYWNlIiwicGFyc2VMb2ciLCJkYXRhIiwicGFyc2VFcnIiLCJtYXJrZXRBZGRyZXNzIiwiZ2V0QWRkcmVzcyIsInNsaWNlIiwiY3JlYXRvckFkZHJlc3MiLCJzZXQiLCJhcmdzIiwiY3JlYXRvciIsInNpemUiLCJlcnIiLCJiYWNrZW5kTWFya2V0cyIsImFwaVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwicmVzcG9uc2UiLCJnZXQiLCJiYWNrZW5kTWFwQnlBZGRyZXNzIiwiYmFja2VuZE1hcEJ5RmVlZElkIiwiZm9yRWFjaCIsIm0iLCJtYXJrZXRfYWRkcmVzcyIsImFkZHJMb3dlciIsImZlZWRfaWQiLCJmZWVkSWRMb3dlciIsInN0YXJ0c1dpdGgiLCJtYXJrZXRQcm9taXNlcyIsIm1hcCIsInByb3ZpZGVyRm9yQ29udHJhY3QiLCJ3aW5kb3ciLCJldGhlcmV1bSIsIm1hcmtldENvbnRyYWN0Iiwic2FmZUNhbGwiLCJmbiIsImRlZmF1bHRWYWx1ZSIsInF1ZXN0aW9uIiwiZGVhZGxpbmUiLCJyZXNvbHZlZCIsIm91dGNvbWUiLCJQcm9taXNlIiwiYWxsIiwiY3JlYXRvckZyb21Db250cmFjdCIsImRlYnVnIiwiY3VycmVudFByaWNlIiwibG9ja1ByaWNlIiwiZmVlZElkIiwiZ2V0Q3VycmVudFByaWNlIiwiUmVzb2x2ZWQiLCJOdW1iZXIiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJMb2NrZWQiLCJmZWVkSWRTdHIiLCJmZWVkSWRIZXgiLCJ0b1V0ZjhTdHJpbmciLCJyZXBsYWNlIiwiaGV4bGlmeSIsImFkZHJlc3NMb3dlciIsImJhY2tlbmRNYXJrZXQiLCJmZWVkSWROb1ByZWZpeCIsImNyZWF0aW9uVHhIYXNoIiwiY3JlYXRvcl9hZGRyZXNzIiwibWFya2V0VG9waWMiLCJ6ZXJvUGFkVmFsdWUiLCJtYXJrZXRFdmVudHMiLCJldmVudEVyciIsImhhcyIsImltYWdlVXJsIiwiaW1hZ2VfdXJsIiwic3Vic3RyaW5nIiwiZGlzcGxheVF1ZXN0aW9uIiwiZGlzcGxheUNhdGVnb3J5IiwiY2F0ZWdvcnkiLCJtYXJrZXREYXRhIiwiZm9ybWF0RXRoZXIiLCJkZXNjcmlwdGlvbiIsImNyZWF0ZWRBdCIsImNyZWF0ZWRfYXQiLCJtYXJrZXRJZCIsIm1hcmtldF9pZCIsInVuZGVmaW5lZCIsImJhc2ljQ29udHJhY3QiLCJxdWVzdGlvbkVyciIsIm1hcmtldHNOZWVkaW5nQ3JlYXRvcnMiLCJtYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jIiwiZXhpc3RzIiwic29tZSIsInBvc3QiLCJkdXJhdGlvbiIsInJlc29sdXRpb25EZWxheSIsIm9yYWNsZVR5cGUiLCJjYXRjaCIsInZhbGlkTWFya2V0cyIsInRlc3QiLCJtYXJrZXRzV2l0aENyZWF0b3JzIiwibWFya2V0c1dpdGhUcmVuZGluZyIsInRyZW5kaW5nU2NvcmUiLCJoYXNJbWFnZSIsIm1lc3NhZ2UiLCJyZWZldGNoIiwidXNlTWFya2V0Iiwic2V0TWFya2V0IiwiZmV0Y2hNYXJrZXQiLCJiYXNlUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});