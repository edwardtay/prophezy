"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_1__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, []);\n    const fetchMarkets = async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getFactoryContract)(provider);\n            // Get all market addresses from factory\n            const marketAddresses = await factory.getMarkets();\n            // Fetch metadata from backend API\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market\n            const marketPromises = marketAddresses.map(async (address)=>{\n                const marketContract = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getMarketContract)(address, provider);\n                try {\n                    const [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                        marketContract.getCurrentPrice(),\n                        marketContract.lockPrice(),\n                        marketContract.state(),\n                        marketContract.totalYes(),\n                        marketContract.totalNo(),\n                        marketContract.feedId()\n                    ]);\n                    // Convert feedId bytes32 to string (remove null bytes)\n                    const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_3__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    const feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(feedId);\n                    // Try to find matching backend metadata\n                    // Try multiple variations of the feedId for matching\n                    const feedIdLower = feedIdHex.toLowerCase();\n                    const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                    const backendMarket = backendMap.get(feedIdLower) || backendMap.get(feedIdNoPrefix) || backendMap.get(feedIdStr.toLowerCase());\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(currentPrice),\n                        lockPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(lockPrice),\n                        state: Number(state),\n                        totalYes: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalYes),\n                        totalNo: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalNo),\n                        // Merge metadata from backend if available\n                        question: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question,\n                        category: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description\n                    };\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Return minimal data if contract call fails\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: _lib_contracts__WEBPACK_IMPORTED_MODULE_1__.MarketState.Active,\n                        totalYes: \"0\",\n                        totalNo: \"0\"\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = marketData.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n            const marketContract = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getMarketContract)(marketAddress, provider);\n            const [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                marketContract.getCurrentPrice(),\n                marketContract.lockPrice(),\n                marketContract.state(),\n                marketContract.totalYes(),\n                marketContract.totalNo(),\n                marketContract.feedId()\n            ]);\n            const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_3__.toUtf8String(feedId).replace(/\\0/g, \"\");\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(feedId),\n                currentPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(currentPrice),\n                lockPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(lockPrice),\n                state: Number(state),\n                totalYes: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalYes),\n                totalNo: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalNo)\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE0QztBQUNaO0FBQ047QUFPQTtBQUUxQjs7Q0FFQyxHQUNELFNBQVNRLHVCQUF1QkMsTUFBa0I7SUFDaEQsTUFBTUMsV0FBV0MsV0FBV0YsT0FBT0MsUUFBUTtJQUMzQyxNQUFNRSxVQUFVRCxXQUFXRixPQUFPRyxPQUFPO0lBQ3pDLE1BQU1DLGlCQUFpQkgsV0FBV0U7SUFFbEMscUNBQXFDO0lBQ3JDLElBQUlFLFFBQVFEO0lBRVosMkJBQTJCO0lBQzNCLElBQUlKLE9BQU9NLEtBQUssS0FBS1IsdURBQVdBLENBQUNTLE1BQU0sRUFBRTtRQUN2Q0YsU0FBUztJQUNYO0lBRUEsK0RBQStEO0lBQy9ELElBQUlELGlCQUFpQixHQUFHO1FBQ3RCLE1BQU1JLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQ1QsVUFBVUUsV0FBV00sS0FBS0UsR0FBRyxDQUFDVixVQUFVRTtRQUNqRUUsU0FBVSxJQUFJRyxVQUFVLEtBQU0sdUNBQXVDO0lBQ3ZFO0lBRUEsT0FBT0g7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU087SUFDZCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR3ZCLCtDQUFRQSxDQUFlLEVBQUU7SUFDdkQsTUFBTSxDQUFDd0IsU0FBU0MsV0FBVyxHQUFHekIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDMEIsT0FBT0MsU0FBUyxHQUFHM0IsK0NBQVFBLENBQWdCO0lBRWxEQyxnREFBU0EsQ0FBQztRQUNSMkI7SUFDRixHQUFHLEVBQUU7SUFFTCxNQUFNQSxlQUFlO1FBQ25CLElBQUk7WUFDRkgsV0FBVztZQUNYRSxTQUFTO1lBRVQsTUFBTUUsV0FBV3ZCLDJEQUFXQTtZQUM1QixNQUFNd0IsVUFBVTFCLGtFQUFrQkEsQ0FBQ3lCO1lBRW5DLHdDQUF3QztZQUN4QyxNQUFNRSxrQkFBNEIsTUFBTUQsUUFBUUUsVUFBVTtZQUUxRCxrQ0FB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bUQsT0FBTyxHQUMvRCxNQUFNQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ2hCTCxlQUFlTSxlQUFlO2dCQUM5Qk4sZUFBZUUsU0FBUztnQkFDeEJGLGVBQWU3QyxLQUFLO2dCQUNwQjZDLGVBQWVsRCxRQUFRO2dCQUN2QmtELGVBQWVoRCxPQUFPO2dCQUN0QmdELGVBQWVHLE1BQU07YUFDdEI7WUFFSCxNQUFNSSxZQUFZakUsZ0RBQW1CLENBQUM2RCxRQUFRTSxPQUFPLENBQUMsT0FBTztZQUU3RGtCLFVBQVU7Z0JBQ1I1QixTQUFTMkI7Z0JBQ1R2QixRQUFRSSxhQUFhakUsMkNBQWMsQ0FBQzZEO2dCQUNwQ0YsY0FBYzNELCtDQUFrQixDQUFDMkQ7Z0JBQ2pDQyxXQUFXNUQsK0NBQWtCLENBQUM0RDtnQkFDOUIvQyxPQUFPOEQsT0FBTzlEO2dCQUNkTCxVQUFVUiwrQ0FBa0IsQ0FBQ1E7Z0JBQzdCRSxTQUFTViwrQ0FBa0IsQ0FBQ1U7WUFDOUI7UUFDRixFQUFFLE9BQU82QixLQUFVO1lBQ2pCQyxRQUFRaEIsS0FBSyxDQUFDLDJCQUEyQmU7WUFDekNkLFNBQVNjLElBQUkwQyxPQUFPLElBQUk7UUFDMUIsU0FBVTtZQUNSMUQsV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPO1FBQUVoQjtRQUFRZTtRQUFTRTtRQUFPMEQsU0FBU0k7SUFBWTtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlTWFya2V0cy50cz9kM2MzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7XG4gIGdldEZhY3RvcnlDb250cmFjdCxcbiAgZ2V0TWFya2V0Q29udHJhY3QsXG4gIGdldFByb3ZpZGVyLFxuICBNYXJrZXREYXRhLFxuICBNYXJrZXRTdGF0ZSxcbn0gZnJvbSBcIi4uL2xpYi9jb250cmFjdHNcIjtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmUgYmFzZWQgb24gbGlxdWlkaXR5IGFuZCBhY3Rpdml0eVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldDogTWFya2V0RGF0YSk6IG51bWJlciB7XG4gIGNvbnN0IHRvdGFsWWVzID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxZZXMpO1xuICBjb25zdCB0b3RhbE5vID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxObyk7XG4gIGNvbnN0IHRvdGFsTGlxdWlkaXR5ID0gdG90YWxZZXMgKyB0b3RhbE5vO1xuICBcbiAgLy8gQmFzZSBzY29yZSBmcm9tIGxpcXVpZGl0eSAodm9sdW1lKVxuICBsZXQgc2NvcmUgPSB0b3RhbExpcXVpZGl0eTtcbiAgXG4gIC8vIEJvb3N0IGZvciBhY3RpdmUgbWFya2V0c1xuICBpZiAobWFya2V0LnN0YXRlID09PSBNYXJrZXRTdGF0ZS5BY3RpdmUpIHtcbiAgICBzY29yZSAqPSAxLjI7XG4gIH1cbiAgXG4gIC8vIEJvb3N0IGZvciBtYXJrZXRzIHdpdGggYmFsYW5jZWQgbGlxdWlkaXR5IChtb3JlIGludGVyZXN0aW5nKVxuICBpZiAodG90YWxMaXF1aWRpdHkgPiAwKSB7XG4gICAgY29uc3QgYmFsYW5jZSA9IE1hdGgubWluKHRvdGFsWWVzLCB0b3RhbE5vKSAvIE1hdGgubWF4KHRvdGFsWWVzLCB0b3RhbE5vKTtcbiAgICBzY29yZSAqPSAoMSArIGJhbGFuY2UgKiAwLjMpOyAvLyBVcCB0byAzMCUgYm9vc3QgZm9yIGJhbGFuY2VkIG1hcmtldHNcbiAgfVxuICBcbiAgcmV0dXJuIHNjb3JlO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYWxsIG1hcmtldHMgZnJvbSB0aGUgZmFjdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0cygpIHtcbiAgY29uc3QgW21hcmtldHMsIHNldE1hcmtldHNdID0gdXNlU3RhdGU8TWFya2V0RGF0YVtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hNYXJrZXRzKCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBmZXRjaE1hcmtldHMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgZmFjdG9yeSA9IGdldEZhY3RvcnlDb250cmFjdChwcm92aWRlcik7XG5cbiAgICAgIC8vIEdldCBhbGwgbWFya2V0IGFkZHJlc3NlcyBmcm9tIGZhY3RvcnlcbiAgICAgIGNvbnN0IG1hcmtldEFkZHJlc3Nlczogc3RyaW5nW10gPSBhd2FpdCBmYWN0b3J5LmdldE1hcmtldHMoKTtcblxuICAgICAgLy8gRmV0Y2ggbWV0YWRhdGEgZnJvbSBiYWNrZW5kIEFQSVxuICAgICAgbGV0IGJhY2tlbmRNYXJrZXRzOiBhbnlbXSA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMVwiO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHthcGlVcmx9L2FwaS9tYXJrZXRzYCk7XG4gICAgICAgIGJhY2tlbmRNYXJrZXRzID0gcmVzcG9uc2UuZGF0YSB8fCBbXTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0IG1ldGFkYXRhIGZyb20gYmFja2VuZDpcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGJhY2tlbmQgbWFya2V0cyBieSBtYXJrZXRfYWRkcmVzcyAocHJpbWFyeSkgYW5kIGZlZWRJZCAoZmFsbGJhY2spIGZvciBxdWljayBsb29rdXBcbiAgICAgIGNvbnN0IGJhY2tlbmRNYXBCeUFkZHJlc3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5RmVlZElkID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgIGJhY2tlbmRNYXJrZXRzLmZvckVhY2goKG06IGFueSkgPT4ge1xuICAgICAgICAvLyBQcmltYXJ5OiBtYXRjaCBieSBtYXJrZXRfYWRkcmVzcyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKG0ubWFya2V0X2FkZHJlc3MpIHtcbiAgICAgICAgICBjb25zdCBhZGRyTG93ZXIgPSBtLm1hcmtldF9hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYmFja2VuZE1hcEJ5QWRkcmVzcy5zZXQoYWRkckxvd2VyLCBtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjazogbWF0Y2ggYnkgZmVlZElkIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5mZWVkX2lkKSB7XG4gICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBtLmZlZWRfaWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuc2V0KGZlZWRJZExvd2VyLCBtKTtcbiAgICAgICAgICAvLyBBbHNvIHRyeSB3aXRob3V0IDB4IHByZWZpeCBpZiBwcmVzZW50XG4gICAgICAgICAgaWYgKGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIuc2xpY2UoMiksIG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZldGNoIGRhdGEgZm9yIGVhY2ggbWFya2V0XG4gICAgICBjb25zdCBtYXJrZXRQcm9taXNlcyA9IG1hcmtldEFkZHJlc3Nlcy5tYXAoYXN5bmMgKGFkZHJlc3MpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2V0Q29udHJhY3QgPSBnZXRNYXJrZXRDb250cmFjdChhZGRyZXNzLCBwcm92aWRlcik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSxcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3Quc3RhdGUoKSxcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3QudG90YWxZZXMoKSxcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3QudG90YWxObygpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC5mZWVkSWQoKSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgKHJlbW92ZSBudWxsIGJ5dGVzKVxuICAgICAgICAgIGNvbnN0IGZlZWRJZFN0ciA9IGV0aGVycy50b1V0ZjhTdHJpbmcoZmVlZElkKS5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG4gICAgICAgICAgY29uc3QgZmVlZElkSGV4ID0gZmVlZElkU3RyIHx8IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgbWF0Y2hpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgICAgIC8vIFRyeSBtdWx0aXBsZSB2YXJpYXRpb25zIG9mIHRoZSBmZWVkSWQgZm9yIG1hdGNoaW5nXG4gICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBmZWVkSWRIZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBjb25zdCBmZWVkSWROb1ByZWZpeCA9IGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykgPyBmZWVkSWRMb3dlci5zbGljZSgyKSA6IGZlZWRJZExvd2VyO1xuICAgICAgICAgIGNvbnN0IGJhY2tlbmRNYXJrZXQgPSBiYWNrZW5kTWFwLmdldChmZWVkSWRMb3dlcikgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcC5nZXQoZmVlZElkTm9QcmVmaXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcC5nZXQoZmVlZElkU3RyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgY29uc3QgbWFya2V0RGF0YTogTWFya2V0RGF0YSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgICAgIGN1cnJlbnRQcmljZTogZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSksXG4gICAgICAgICAgICBsb2NrUHJpY2U6IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpLFxuICAgICAgICAgICAgc3RhdGU6IE51bWJlcihzdGF0ZSkgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgICAgICB0b3RhbFllczogZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSxcbiAgICAgICAgICAgIHRvdGFsTm86IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSxcbiAgICAgICAgICAgIC8vIE1lcmdlIG1ldGFkYXRhIGZyb20gYmFja2VuZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBiYWNrZW5kTWFya2V0Py5xdWVzdGlvbixcbiAgICAgICAgICAgIGNhdGVnb3J5OiBiYWNrZW5kTWFya2V0Py5jYXRlZ29yeSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBiYWNrZW5kTWFya2V0Py5kZXNjcmlwdGlvbixcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIG1hcmtldERhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIG1hcmtldCAke2FkZHJlc3N9OmAsIGVycik7XG4gICAgICAgICAgLy8gUmV0dXJuIG1pbmltYWwgZGF0YSBpZiBjb250cmFjdCBjYWxsIGZhaWxzXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IFwiXCIsXG4gICAgICAgICAgICBjdXJyZW50UHJpY2U6IFwiMFwiLFxuICAgICAgICAgICAgbG9ja1ByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBNYXJrZXRTdGF0ZS5BY3RpdmUsXG4gICAgICAgICAgICB0b3RhbFllczogXCIwXCIsXG4gICAgICAgICAgICB0b3RhbE5vOiBcIjBcIixcbiAgICAgICAgICB9IGFzIE1hcmtldERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtYXJrZXREYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwobWFya2V0UHJvbWlzZXMpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmVzIGFuZCBhZGQgdG8gbWFya2V0IGRhdGFcbiAgICAgIGNvbnN0IG1hcmtldHNXaXRoVHJlbmRpbmcgPSBtYXJrZXREYXRhLm1hcChtYXJrZXQgPT4gKHtcbiAgICAgICAgLi4ubWFya2V0LFxuICAgICAgICB0cmVuZGluZ1Njb3JlOiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldCksXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIHNldE1hcmtldHMobWFya2V0c1dpdGhUcmVuZGluZyk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0czpcIiwgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldHNcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBtYXJrZXRzLCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXRzIH07XG59XG5cbi8qKlxuICogSG9vayB0byBmZXRjaCBhIHNpbmdsZSBtYXJrZXQncyBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXJrZXQobWFya2V0QWRkcmVzczogc3RyaW5nIHwgbnVsbCkge1xuICBjb25zdCBbbWFya2V0LCBzZXRNYXJrZXRdID0gdXNlU3RhdGU8TWFya2V0RGF0YSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2V0QWRkcmVzcykge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoTWFya2V0KCk7XG4gIH0sIFttYXJrZXRBZGRyZXNzXSk7XG5cbiAgY29uc3QgZmV0Y2hNYXJrZXQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICBjb25zdCBtYXJrZXRDb250cmFjdCA9IGdldE1hcmtldENvbnRyYWN0KG1hcmtldEFkZHJlc3MsIHByb3ZpZGVyKTtcblxuICAgICAgY29uc3QgW2N1cnJlbnRQcmljZSwgbG9ja1ByaWNlLCBzdGF0ZSwgdG90YWxZZXMsIHRvdGFsTm8sIGZlZWRJZF0gPVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgbWFya2V0Q29udHJhY3QuZ2V0Q3VycmVudFByaWNlKCksXG4gICAgICAgICAgbWFya2V0Q29udHJhY3QubG9ja1ByaWNlKCksXG4gICAgICAgICAgbWFya2V0Q29udHJhY3Quc3RhdGUoKSxcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC50b3RhbFllcygpLFxuICAgICAgICAgIG1hcmtldENvbnRyYWN0LnRvdGFsTm8oKSxcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC5mZWVkSWQoKSxcbiAgICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IGZlZWRJZFN0ciA9IGV0aGVycy50b1V0ZjhTdHJpbmcoZmVlZElkKS5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG5cbiAgICAgIHNldE1hcmtldCh7XG4gICAgICAgIGFkZHJlc3M6IG1hcmtldEFkZHJlc3MsXG4gICAgICAgIGZlZWRJZDogZmVlZElkU3RyIHx8IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCksXG4gICAgICAgIGN1cnJlbnRQcmljZTogZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSksXG4gICAgICAgIGxvY2tQcmljZTogZXRoZXJzLmZvcm1hdEV0aGVyKGxvY2tQcmljZSksXG4gICAgICAgIHN0YXRlOiBOdW1iZXIoc3RhdGUpIGFzIE1hcmtldFN0YXRlLFxuICAgICAgICB0b3RhbFllczogZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSxcbiAgICAgICAgdG90YWxObzogZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsTm8pLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0OlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0XCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgbWFya2V0LCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXQgfTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZXRoZXJzIiwiYXhpb3MiLCJnZXRGYWN0b3J5Q29udHJhY3QiLCJnZXRNYXJrZXRDb250cmFjdCIsImdldFByb3ZpZGVyIiwiTWFya2V0U3RhdGUiLCJjYWxjdWxhdGVUcmVuZGluZ1Njb3JlIiwibWFya2V0IiwidG90YWxZZXMiLCJwYXJzZUZsb2F0IiwidG90YWxObyIsInRvdGFsTGlxdWlkaXR5Iiwic2NvcmUiLCJzdGF0ZSIsIkFjdGl2ZSIsImJhbGFuY2UiLCJNYXRoIiwibWluIiwibWF4IiwidXNlTWFya2V0cyIsIm1hcmtldHMiLCJzZXRNYXJrZXRzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiZmV0Y2hNYXJrZXRzIiwicHJvdmlkZXIiLCJmYWN0b3J5IiwibWFya2V0QWRkcmVzc2VzIiwiZ2V0TWFya2V0cyIsImJhY2tlbmRNYXJrZXRzIiwiYXBpVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsImdldCIsImRhdGEiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsImJhY2tlbmRNYXBCeUFkZHJlc3MiLCJNYXAiLCJiYWNrZW5kTWFwQnlGZWVkSWQiLCJmb3JFYWNoIiwibSIsIm1hcmtldF9hZGRyZXNzIiwiYWRkckxvd2VyIiwidG9Mb3dlckNhc2UiLCJzZXQiLCJmZWVkX2lkIiwiZmVlZElkTG93ZXIiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJtYXJrZXRQcm9taXNlcyIsIm1hcCIsImFkZHJlc3MiLCJtYXJrZXRDb250cmFjdCIsImN1cnJlbnRQcmljZSIsImxvY2tQcmljZSIsImZlZWRJZCIsIlByb21pc2UiLCJhbGwiLCJnZXRDdXJyZW50UHJpY2UiLCJmZWVkSWRTdHIiLCJ0b1V0ZjhTdHJpbmciLCJyZXBsYWNlIiwiZmVlZElkSGV4IiwiaGV4bGlmeSIsImZlZWRJZE5vUHJlZml4IiwiYmFja2VuZE1hcmtldCIsImJhY2tlbmRNYXAiLCJtYXJrZXREYXRhIiwiZm9ybWF0RXRoZXIiLCJOdW1iZXIiLCJxdWVzdGlvbiIsImNhdGVnb3J5IiwiZGVzY3JpcHRpb24iLCJtYXJrZXRzV2l0aFRyZW5kaW5nIiwidHJlbmRpbmdTY29yZSIsIm1lc3NhZ2UiLCJyZWZldGNoIiwidXNlTWFya2V0IiwibWFya2V0QWRkcmVzcyIsInNldE1hcmtldCIsImZldGNoTWFya2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});