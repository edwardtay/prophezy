"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory (ONLY on-chain markets - no mocks)\n            const marketAddresses = await factory.getMarkets();\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" on-chain markets from factory contract\"));\n            // Single getLogs call for all MarketCreated events (more efficient, avoids rate limits)\n            const creationTxMap = new Map();\n            const creatorByMarket = {};\n            try {\n                // Query all MarketCreated events from the factory contract in one call\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const MARKET_CREATED_TOPIC = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                // Use a reasonable fromBlock - you can adjust this or use deployment block\n                // For now, query from block 0 (or use a known deployment block if available)\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        MARKET_CREATED_TOPIC\n                    ],\n                    fromBlock: 0,\n                    toBlock: \"latest\"\n                };\n                const logs = await provider.getLogs(filter);\n                console.log(\"[useMarkets] Found \".concat(logs.length, \" MarketCreated events in single getLogs call\"));\n                // Build map: marketAddress -> creator (and also store tx hash)\n                for (const log of logs){\n                    try {\n                        // Parse the event log\n                        let parsed = null;\n                        try {\n                            parsed = factory.interface.parseLog({\n                                topics: log.topics,\n                                data: log.data\n                            });\n                        } catch (parseErr) {\n                            // Fallback: extract directly from topics if parsing fails\n                            if (log.topics && log.topics.length >= 3) {\n                                const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                                const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26)).toLowerCase();\n                                creatorByMarket[marketAddress] = creatorAddress;\n                                creationTxMap.set(marketAddress, log.transactionHash);\n                                continue;\n                            }\n                        }\n                        if (parsed && parsed.args) {\n                            var _parsed_args_market, _parsed_args_, _parsed_args_creator, _parsed_args_1;\n                            const market = ((_parsed_args_market = parsed.args.market) === null || _parsed_args_market === void 0 ? void 0 : _parsed_args_market.toLowerCase()) || ((_parsed_args_ = parsed.args[0]) === null || _parsed_args_ === void 0 ? void 0 : _parsed_args_.toLowerCase());\n                            const creator = ((_parsed_args_creator = parsed.args.creator) === null || _parsed_args_creator === void 0 ? void 0 : _parsed_args_creator.toLowerCase()) || ((_parsed_args_1 = parsed.args[1]) === null || _parsed_args_1 === void 0 ? void 0 : _parsed_args_1.toLowerCase());\n                            if (market && creator) {\n                                creatorByMarket[market] = creator;\n                                creationTxMap.set(market, log.transactionHash);\n                            }\n                        }\n                    } catch (parseErr) {\n                        console.warn(\"[useMarkets] Error parsing log \".concat(log.transactionHash, \":\"), parseErr);\n                    }\n                }\n                console.log(\"[useMarkets] Built creator map with \".concat(Object.keys(creatorByMarket).length, \" entries from single getLogs call\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API (ONLY for enriching on-chain markets with metadata - not for displaying)\n            // Backend markets are matched to on-chain markets by market_address\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" backend metadata entries (for enrichment only, not displayed separately)\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market using new ABI\n            const marketPromises = marketAddresses.map(async (address)=>{\n                // Use BrowserProvider and Contract directly with new ABI\n                let providerForContract;\n                if ( true && window.ethereum) {\n                    providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n                } else {\n                    providerForContract = provider;\n                }\n                const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                try {\n                    var _marketAddresses_;\n                    // Wrap each call in a promise that catches errors\n                    const safeCall = async (fn, defaultValue)=>{\n                        try {\n                            return await fn();\n                        } catch (e) {\n                            return defaultValue;\n                        }\n                    };\n                    // Use new ABI methods: question, deadline, resolved, outcome\n                    // Also try to read creator directly from contract if available\n                    const [question, deadline, resolved, outcome] = await Promise.all([\n                        marketContract.question(),\n                        marketContract.deadline(),\n                        marketContract.resolved(),\n                        marketContract.outcome()\n                    ]);\n                    // Try to read creator directly from contract (simplest method)\n                    let creatorFromContract = null;\n                    try {\n                        creatorFromContract = await marketContract.creator();\n                    } catch (err) {\n                        // Contract might not have creator() function, that's okay\n                        console.debug(\"[useMarkets] Market \".concat(address, \" does not have creator() function\"));\n                    }\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    let currentPrice = 0n;\n                    let lockPrice = 0n;\n                    let totalYes = 0n;\n                    let totalNo = 0n;\n                    let feedId = \"0x0\";\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    try {\n                        [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                            safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                            safeCall(()=>marketContract.lockPrice(), 0n),\n                            safeCall(()=>marketContract.state(), 0),\n                            safeCall(()=>marketContract.totalYes(), 0n),\n                            safeCall(()=>marketContract.totalNo(), 0n),\n                            safeCall(()=>marketContract.feedId(), \"0x0\")\n                        ]);\n                    } catch (err) {\n                        // If methods don't exist, defaults are already set above\n                        console.warn(\"Some optional methods not available for market \".concat(address, \", using defaults\"));\n                    }\n                    // Map resolved/outcome to MarketState\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    } else {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes) if it's a bytes32\n                    let feedIdStr = \"\";\n                    let feedIdHex = \"0x0\";\n                    if (feedId && feedId !== \"0x0\") {\n                        try {\n                            feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                            feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        } catch (e) {\n                            feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        }\n                    }\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    // Priority 1: Read creator directly from contract (simplest and most reliable)\n                    let creatorAddress = creatorFromContract ? creatorFromContract.toLowerCase() : null;\n                    // Priority 2: Use creator from event map (from single getLogs call)\n                    if (!creatorAddress) {\n                        creatorAddress = creatorByMarket[addressLower] || null;\n                    }\n                    // Priority 3: Use backend creator_address\n                    if (!creatorAddress && (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.creator_address)) {\n                        creatorAddress = backendMarket.creator_address.toLowerCase();\n                        console.log(\"[useMarkets] Using creator from backend: \".concat(creatorAddress, \" for market \").concat(address));\n                    }\n                    if (creatorAddress) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" creator: \").concat(creatorAddress, \" (from \").concat(creatorFromContract ? \"contract\" : creatorByMarket[addressLower] ? \"events\" : \"backend\", \")\"));\n                    }\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    // Ensure we always have a question - prioritize contract, then backend, then fallback\n                    const displayQuestion = question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question) || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6));\n                    // Category: use backend if available, otherwise try to infer or use \"Other\"\n                    const displayCategory = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category) || \"Other\";\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                        lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                        state: state,\n                        totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                        totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                        // Use question from contract first (most reliable), fallback to backend, then generic\n                        question: displayQuestion,\n                        category: displayCategory,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress,\n                        createdAt: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.created_at) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.createdAt),\n                        // Include backend market_id for API calls (MarketInfo, MarketChat)\n                        marketId: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.market_id) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.id) || undefined\n                    };\n                    // Log if market is missing backend metadata\n                    if (!backendMarket) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" is on-chain but missing backend metadata. Using contract data only.\"));\n                    }\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least basic data using new ABI if other calls fail\n                    let question = \"\";\n                    let deadline = 0;\n                    let resolved = false;\n                    let outcome = 0n;\n                    try {\n                        const basicContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                        [question, deadline, resolved, outcome] = await Promise.all([\n                            basicContract.question(),\n                            basicContract.deadline(),\n                            basicContract.resolved(),\n                            basicContract.outcome()\n                        ]);\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch basic data for market \".concat(address, \":\"), questionErr);\n                    }\n                    // Determine state from resolved/deadline\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (deadline > 0 && deadline <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: state,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // No need for batch fetching - we already have creators from the single getLogs call\n            // Just check if any markets are still missing creators (shouldn't happen if events were parsed correctly)\n            const marketsNeedingCreators = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.creatorAddress);\n            if (marketsNeedingCreators.length > 0) {\n                console.warn(\"[useMarkets] \".concat(marketsNeedingCreators.length, \" markets still missing creators after event parsing. This shouldn't happen if events were parsed correctly.\"));\n            }\n            // Auto-sync: Create backend entries for on-chain markets missing backend metadata\n            // This ensures all markets have complete data\n            const marketsNeedingBackendSync = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\" && !m.marketId && // No backend ID means no backend entry\n                m.question && // Has question from contract\n                m.question !== \"Market \".concat(m.address.slice(0, 8), \"...\").concat(m.address.slice(-6)) // Not just fallback\n            );\n            if (marketsNeedingBackendSync.length > 0) {\n                console.log(\"[useMarkets] \".concat(marketsNeedingBackendSync.length, \" on-chain markets missing backend metadata. Auto-syncing...\"));\n                // Try to create backend entries for these markets (non-blocking)\n                Promise.all(marketsNeedingBackendSync.map(async (market)=>{\n                    try {\n                        const apiUrl = \"http://localhost:3001\" || 0;\n                        // Check if backend entry already exists\n                        const backendMarkets = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                        const exists = backendMarkets.data.some((m)=>{\n                            var _m_market_address;\n                            return ((_m_market_address = m.market_address) === null || _m_market_address === void 0 ? void 0 : _m_market_address.toLowerCase()) === market.address.toLowerCase();\n                        });\n                        if (!exists && market.question && market.creatorAddress) {\n                            // Create backend entry with contract data\n                            await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].post(\"\".concat(apiUrl, \"/api/markets\"), {\n                                question: market.question,\n                                category: market.category || \"Other\",\n                                duration: 7 * 24 * 60 * 60,\n                                resolutionDelay: 24 * 60 * 60,\n                                imageUrl: market.imageUrl || null,\n                                oracleType: \"chainlink\",\n                                creatorAddress: market.creatorAddress,\n                                marketAddress: market.address\n                            });\n                            console.log(\"[useMarkets] Auto-created backend entry for market \".concat(market.address));\n                        }\n                    } catch (err) {\n                        // Silently fail - this is just a sync attempt\n                        console.debug(\"[useMarkets] Could not auto-sync market \".concat(market.address, \":\"), err);\n                    }\n                })).catch(()=>{\n                // Ignore errors - this is best effort\n                });\n            }\n            // Filter out markets with empty/invalid addresses - only show real on-chain markets\n            const validMarkets = marketData.filter((m)=>{\n                // Must have a valid address\n                if (!m.address || m.address === \"0x0000000000000000000000000000000000000000\") {\n                    return false;\n                }\n                // Must be a valid Ethereum address format\n                if (!/^0x[a-fA-F0-9]{40}$/.test(m.address)) {\n                    return false;\n                }\n                // Must have been fetched from factory (exists in marketAddresses)\n                return true;\n            });\n            const marketsWithCreators = validMarkets.filter((m)=>m.creatorAddress).length;\n            console.log(\"[useMarkets] Valid on-chain markets: \".concat(validMarkets.length, \", Markets with creators: \").concat(marketsWithCreators));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            // Use BrowserProvider and Contract directly with new ABI\n            let providerForContract;\n            if ( true && window.ethereum) {\n                providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n            } else {\n                const baseProvider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n                providerForContract = baseProvider;\n            }\n            const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(marketAddress, MARKET_ABI, providerForContract);\n            // Use new ABI methods: question, deadline, resolved, outcome\n            const [question, deadline, resolved, outcome] = await Promise.all([\n                marketContract.question(),\n                marketContract.deadline(),\n                marketContract.resolved(),\n                marketContract.outcome()\n            ]);\n            // Try to get additional data if methods exist (for backward compatibility)\n            let currentPrice = 0n;\n            let lockPrice = 0n;\n            let totalYes = 0n;\n            let totalNo = 0n;\n            let feedId = \"0x0\";\n            let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            // Try to get additional data if methods exist (for backward compatibility)\n            // Wrap each call in a promise that catches errors\n            const safeCall = async (fn, defaultValue)=>{\n                try {\n                    return await fn();\n                } catch (e) {\n                    return defaultValue;\n                }\n            };\n            try {\n                [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                    safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                    safeCall(()=>marketContract.lockPrice(), 0n),\n                    safeCall(()=>marketContract.state(), 0),\n                    safeCall(()=>marketContract.totalYes(), 0n),\n                    safeCall(()=>marketContract.totalNo(), 0n),\n                    safeCall(()=>marketContract.feedId(), \"0x0\")\n                ]);\n            } catch (err) {\n                // If methods don't exist, defaults are already set above\n                console.warn(\"Some optional methods not available for market \".concat(marketAddress, \", using defaults\"));\n            }\n            // Map resolved/outcome to MarketState\n            if (resolved) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n            } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n            } else {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            }\n            // Convert feedId bytes32 to string if available\n            let feedIdStr = \"\";\n            let feedIdHex = \"0x0\";\n            if (feedId && feedId !== \"0x0\") {\n                try {\n                    feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                } catch (e) {\n                    feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                }\n            }\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdHex,\n                currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                state: state,\n                totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0U7QUFDakM7QUFDK0I7QUFPL0I7QUFFMUIsTUFBTVksYUFBYUwsMkRBQWtCO0FBRXJDOztDQUVDLEdBQ0QsU0FBU08sdUJBQXVCQyxNQUFrQjtJQUNoRCxNQUFNQyxXQUFXQyxXQUFXRixPQUFPQyxRQUFRO0lBQzNDLE1BQU1FLFVBQVVELFdBQVdGLE9BQU9HLE9BQU87SUFDekMsTUFBTUMsaUJBQWlCSCxXQUFXRTtJQUVsQyxxQ0FBcUM7SUFDckMsSUFBSUUsUUFBUUQ7SUFFWiwyQkFBMkI7SUFDM0IsSUFBSUosT0FBT00sS0FBSyxLQUFLWCx1REFBV0EsQ0FBQ1ksTUFBTSxFQUFFO1FBQ3ZDRixTQUFTO0lBQ1g7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTUksVUFBVUMsS0FBS0MsR0FBRyxDQUFDVCxVQUFVRSxXQUFXTSxLQUFLRSxHQUFHLENBQUNWLFVBQVVFO1FBQ2pFRSxTQUFVLElBQUlHLFVBQVUsS0FBTSx1Q0FBdUM7SUFDdkU7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTTztJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQWUsRUFBRTtJQUN2RCxNQUFNLENBQUM4QixTQUFTQyxXQUFXLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWtDLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQixJQUFJO1lBQ0Y2QixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxNQUFNRSxXQUFXMUIsMkRBQVdBO1lBQzVCLE1BQU0yQixVQUFVNUIsa0VBQWtCQSxDQUFDMkI7WUFFbkMsMkVBQTJFO1lBQzNFLE1BQU1FLGtCQUE0QixNQUFNRCxRQUFRRSxV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O2dCQUM5QixJQUFJO29CQUNGUSxZQUFZaEgsZ0RBQW1CLENBQUN3RyxRQUFRVyxPQUFPLENBQUMsT0FBTztvQkFDdkRGLFlBQVlELGFBQWFoSCwyQ0FBYyxDQUFDd0c7Z0JBQzFDLEVBQUUsVUFBTTtvQkFDTlMsWUFBWSxPQUFPVCxXQUFXLFdBQVdBLFNBQVN4RywyQ0FBYyxDQUFDd0c7Z0JBQ25FO1lBQ0Y7WUFFQW9ELFVBQVU7Z0JBQ1IvRyxTQUFTVztnQkFDVGdELFFBQVFTO2dCQUNSWCxjQUFjQSxlQUFlLEVBQUUsR0FBR3RHLGdEQUFrQixDQUFDc0csZ0JBQWdCO2dCQUNyRUMsV0FBV0EsWUFBWSxFQUFFLEdBQUd2RyxnREFBa0IsQ0FBQ3VHLGFBQWE7Z0JBQzVEckYsT0FBT0E7Z0JBQ1BMLFVBQVVBLFdBQVcsRUFBRSxHQUFHYixnREFBa0IsQ0FBQ2EsWUFBWTtnQkFDekRFLFNBQVNBLFVBQVUsRUFBRSxHQUFHZixnREFBa0IsQ0FBQ2UsV0FBVztnQkFDdEQrRSxVQUFVQTtZQUNaO1FBQ0YsRUFBRSxPQUFPMUIsS0FBVTtZQUNqQmhDLFFBQVFQLEtBQUssQ0FBQywyQkFBMkJ1QztZQUN6Q3RDLFNBQVNzQyxJQUFJcUYsT0FBTyxJQUFJO1FBQzFCLFNBQVU7WUFDUjdILFdBQVc7UUFDYjtJQUNGO0lBRUEsT0FBTztRQUFFaEI7UUFBUWU7UUFBU0U7UUFBTzZILFNBQVNHO0lBQVk7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU1hcmtldHMudHM/ZDNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZXRoZXJzLCBCcm93c2VyUHJvdmlkZXIsIENvbnRyYWN0IH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IG1hcmtldEFydGlmYWN0IGZyb20gXCJAL2FiaS9QcmVkaWN0aW9uTWFya2V0Lmpzb25cIjtcbmltcG9ydCB7XG4gIGdldEZhY3RvcnlDb250cmFjdCxcbiAgZ2V0UHJvdmlkZXIsXG4gIE1hcmtldERhdGEsXG4gIE1hcmtldFN0YXRlLFxuICBGQUNUT1JZX0FERFJFU1MsXG59IGZyb20gXCIuLi9saWIvY29udHJhY3RzXCI7XG5cbmNvbnN0IE1BUktFVF9BQkkgPSBtYXJrZXRBcnRpZmFjdC5hYmk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRyZW5kaW5nIHNjb3JlIGJhc2VkIG9uIGxpcXVpZGl0eSBhbmQgYWN0aXZpdHlcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlVHJlbmRpbmdTY29yZShtYXJrZXQ6IE1hcmtldERhdGEpOiBudW1iZXIge1xuICBjb25zdCB0b3RhbFllcyA9IHBhcnNlRmxvYXQobWFya2V0LnRvdGFsWWVzKTtcbiAgY29uc3QgdG90YWxObyA9IHBhcnNlRmxvYXQobWFya2V0LnRvdGFsTm8pO1xuICBjb25zdCB0b3RhbExpcXVpZGl0eSA9IHRvdGFsWWVzICsgdG90YWxObztcbiAgXG4gIC8vIEJhc2Ugc2NvcmUgZnJvbSBsaXF1aWRpdHkgKHZvbHVtZSlcbiAgbGV0IHNjb3JlID0gdG90YWxMaXF1aWRpdHk7XG4gIFxuICAvLyBCb29zdCBmb3IgYWN0aXZlIG1hcmtldHNcbiAgaWYgKG1hcmtldC5zdGF0ZSA9PT0gTWFya2V0U3RhdGUuQWN0aXZlKSB7XG4gICAgc2NvcmUgKj0gMS4yO1xuICB9XG4gIFxuICAvLyBCb29zdCBmb3IgbWFya2V0cyB3aXRoIGJhbGFuY2VkIGxpcXVpZGl0eSAobW9yZSBpbnRlcmVzdGluZylcbiAgaWYgKHRvdGFsTGlxdWlkaXR5ID4gMCkge1xuICAgIGNvbnN0IGJhbGFuY2UgPSBNYXRoLm1pbih0b3RhbFllcywgdG90YWxObykgLyBNYXRoLm1heCh0b3RhbFllcywgdG90YWxObyk7XG4gICAgc2NvcmUgKj0gKDEgKyBiYWxhbmNlICogMC4zKTsgLy8gVXAgdG8gMzAlIGJvb3N0IGZvciBiYWxhbmNlZCBtYXJrZXRzXG4gIH1cbiAgXG4gIHJldHVybiBzY29yZTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGZldGNoIGFsbCBtYXJrZXRzIGZyb20gdGhlIGZhY3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcmtldHMoKSB7XG4gIGNvbnN0IFttYXJrZXRzLCBzZXRNYXJrZXRzXSA9IHVzZVN0YXRlPE1hcmtldERhdGFbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBmZXRjaE1hcmtldHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgZmFjdG9yeSA9IGdldEZhY3RvcnlDb250cmFjdChwcm92aWRlcik7XG5cbiAgICAgIC8vIEdldCBhbGwgbWFya2V0IGFkZHJlc3NlcyBmcm9tIGZhY3RvcnkgKE9OTFkgb24tY2hhaW4gbWFya2V0cyAtIG5vIG1vY2tzKVxuICAgICAgY29uc3QgbWFya2V0QWRkcmVzc2VzOiBzdHJpbmdbXSA9IGF3YWl0IGZhY3RvcnkuZ2V0TWFya2V0cygpO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke21hcmtldEFkZHJlc3Nlcy5sZW5ndGh9IG9uLWNoYWluIG1hcmtldHMgZnJvbSBmYWN0b3J5IGNvbnRyYWN0YCk7XG4gICAgICBcbiAgICAgIC8vIFNpbmdsZSBnZXRMb2dzIGNhbGwgZm9yIGFsbCBNYXJrZXRDcmVhdGVkIGV2ZW50cyAobW9yZSBlZmZpY2llbnQsIGF2b2lkcyByYXRlIGxpbWl0cylcbiAgICAgIGNvbnN0IGNyZWF0aW9uVHhNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgY29uc3QgY3JlYXRvckJ5TWFya2V0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICB0cnkge1xuICAgICAgICAvLyBRdWVyeSBhbGwgTWFya2V0Q3JlYXRlZCBldmVudHMgZnJvbSB0aGUgZmFjdG9yeSBjb250cmFjdCBpbiBvbmUgY2FsbFxuICAgICAgICAvLyBFdmVudCBzaWduYXR1cmU6IE1hcmtldENyZWF0ZWQoYWRkcmVzcyBpbmRleGVkIG1hcmtldCwgYWRkcmVzcyBpbmRleGVkIGNyZWF0b3IsIGFkZHJlc3MgaW5kZXhlZCBmZWVkQWRkcmVzcylcbiAgICAgICAgY29uc3QgTUFSS0VUX0NSRUFURURfVE9QSUMgPSBldGhlcnMuaWQoXCJNYXJrZXRDcmVhdGVkKGFkZHJlc3MsYWRkcmVzcyxhZGRyZXNzKVwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBhIHJlYXNvbmFibGUgZnJvbUJsb2NrIC0geW91IGNhbiBhZGp1c3QgdGhpcyBvciB1c2UgZGVwbG95bWVudCBibG9ja1xuICAgICAgICAvLyBGb3Igbm93LCBxdWVyeSBmcm9tIGJsb2NrIDAgKG9yIHVzZSBhIGtub3duIGRlcGxveW1lbnQgYmxvY2sgaWYgYXZhaWxhYmxlKVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgYWRkcmVzczogRkFDVE9SWV9BRERSRVNTLFxuICAgICAgICAgIHRvcGljczogW01BUktFVF9DUkVBVEVEX1RPUElDXSxcbiAgICAgICAgICBmcm9tQmxvY2s6IDAsIC8vIFN0YXJ0IGZyb20gYmVnaW5uaW5nLCBvciB1c2UgZGVwbG95bWVudCBibG9jayBpZiBrbm93blxuICAgICAgICAgIHRvQmxvY2s6IFwibGF0ZXN0XCIsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kICR7bG9ncy5sZW5ndGh9IE1hcmtldENyZWF0ZWQgZXZlbnRzIGluIHNpbmdsZSBnZXRMb2dzIGNhbGxgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEJ1aWxkIG1hcDogbWFya2V0QWRkcmVzcyAtPiBjcmVhdG9yIChhbmQgYWxzbyBzdG9yZSB0eCBoYXNoKVxuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBldmVudCBsb2dcbiAgICAgICAgICAgIGxldCBwYXJzZWQ6IGFueSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwYXJzZWQgPSBmYWN0b3J5LmludGVyZmFjZS5wYXJzZUxvZyh7XG4gICAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyKSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBleHRyYWN0IGRpcmVjdGx5IGZyb20gdG9waWNzIGlmIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgICAgICAgaWYgKGxvZy50b3BpY3MgJiYgbG9nLnRvcGljcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtldEFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzFdLnNsaWNlKDI2KSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdG9yQWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKFwiMHhcIiArIGxvZy50b3BpY3NbMl0uc2xpY2UoMjYpKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNyZWF0b3JCeU1hcmtldFttYXJrZXRBZGRyZXNzXSA9IGNyZWF0b3JBZGRyZXNzO1xuICAgICAgICAgICAgICAgIGNyZWF0aW9uVHhNYXAuc2V0KG1hcmtldEFkZHJlc3MsIGxvZy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwYXJzZWQgJiYgcGFyc2VkLmFyZ3MpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya2V0ID0gcGFyc2VkLmFyZ3MubWFya2V0Py50b0xvd2VyQ2FzZSgpIHx8IHBhcnNlZC5hcmdzWzBdPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBjb25zdCBjcmVhdG9yID0gcGFyc2VkLmFyZ3MuY3JlYXRvcj8udG9Mb3dlckNhc2UoKSB8fCBwYXJzZWQuYXJnc1sxXT8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChtYXJrZXQgJiYgY3JlYXRvcikge1xuICAgICAgICAgICAgICAgIGNyZWF0b3JCeU1hcmtldFttYXJrZXRdID0gY3JlYXRvcjtcbiAgICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXQsIGxvZy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3VzZU1hcmtldHNdIEVycm9yIHBhcnNpbmcgbG9nICR7bG9nLnRyYW5zYWN0aW9uSGFzaH06YCwgcGFyc2VFcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBCdWlsdCBjcmVhdG9yIG1hcCB3aXRoICR7T2JqZWN0LmtleXMoY3JlYXRvckJ5TWFya2V0KS5sZW5ndGh9IGVudHJpZXMgZnJvbSBzaW5nbGUgZ2V0TG9ncyBjYWxsYCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGZldGNoIE1hcmtldENyZWF0ZWQgZXZlbnRzOlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke21hcmtldEFkZHJlc3Nlcy5sZW5ndGh9IG1hcmtldHMgZnJvbSBmYWN0b3J5OmAsIG1hcmtldEFkZHJlc3Nlcyk7XG5cbiAgICAgIC8vIEZldGNoIG1ldGFkYXRhIGZyb20gYmFja2VuZCBBUEkgKE9OTFkgZm9yIGVucmljaGluZyBvbi1jaGFpbiBtYXJrZXRzIHdpdGggbWV0YWRhdGEgLSBub3QgZm9yIGRpc3BsYXlpbmcpXG4gICAgICAvLyBCYWNrZW5kIG1hcmtldHMgYXJlIG1hdGNoZWQgdG8gb24tY2hhaW4gbWFya2V0cyBieSBtYXJrZXRfYWRkcmVzc1xuICAgICAgbGV0IGJhY2tlbmRNYXJrZXRzOiBhbnlbXSA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMVwiO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHthcGlVcmx9L2FwaS9tYXJrZXRzYCk7XG4gICAgICAgIGJhY2tlbmRNYXJrZXRzID0gcmVzcG9uc2UuZGF0YSB8fCBbXTtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke2JhY2tlbmRNYXJrZXRzLmxlbmd0aH0gYmFja2VuZCBtZXRhZGF0YSBlbnRyaWVzIChmb3IgZW5yaWNobWVudCBvbmx5LCBub3QgZGlzcGxheWVkIHNlcGFyYXRlbHkpYCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldCBtZXRhZGF0YSBmcm9tIGJhY2tlbmQ6XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBiYWNrZW5kIG1hcmtldHMgYnkgbWFya2V0X2FkZHJlc3MgKHByaW1hcnkpIGFuZCBmZWVkSWQgKGZhbGxiYWNrKSBmb3IgcXVpY2sgbG9va3VwXG4gICAgICBjb25zdCBiYWNrZW5kTWFwQnlBZGRyZXNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgIGNvbnN0IGJhY2tlbmRNYXBCeUZlZWRJZCA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICBiYWNrZW5kTWFya2V0cy5mb3JFYWNoKChtOiBhbnkpID0+IHtcbiAgICAgICAgLy8gUHJpbWFyeTogbWF0Y2ggYnkgbWFya2V0X2FkZHJlc3MgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtLm1hcmtldF9hZGRyZXNzKSB7XG4gICAgICAgICAgY29uc3QgYWRkckxvd2VyID0gbS5tYXJrZXRfYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJhY2tlbmRNYXBCeUFkZHJlc3Muc2V0KGFkZHJMb3dlciwgbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2s6IG1hdGNoIGJ5IGZlZWRJZCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKG0uZmVlZF9pZCkge1xuICAgICAgICAgIGNvbnN0IGZlZWRJZExvd2VyID0gbS5mZWVkX2lkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLnNldChmZWVkSWRMb3dlciwgbSk7XG4gICAgICAgICAgLy8gQWxzbyB0cnkgd2l0aG91dCAweCBwcmVmaXggaWYgcHJlc2VudFxuICAgICAgICAgIGlmIChmZWVkSWRMb3dlci5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuc2V0KGZlZWRJZExvd2VyLnNsaWNlKDIpLCBtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGZXRjaCBkYXRhIGZvciBlYWNoIG1hcmtldCB1c2luZyBuZXcgQUJJXG4gICAgICBjb25zdCBtYXJrZXRQcm9taXNlcyA9IG1hcmtldEFkZHJlc3Nlcy5tYXAoYXN5bmMgKGFkZHJlc3MpID0+IHtcbiAgICAgICAgLy8gVXNlIEJyb3dzZXJQcm92aWRlciBhbmQgQ29udHJhY3QgZGlyZWN0bHkgd2l0aCBuZXcgQUJJXG4gICAgICAgIGxldCBwcm92aWRlckZvckNvbnRyYWN0OiBCcm93c2VyUHJvdmlkZXI7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBuZXcgQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IHByb3ZpZGVyIGFzIGFueSBhcyBCcm93c2VyUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2V0Q29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgTUFSS0VUX0FCSSwgcHJvdmlkZXJGb3JDb250cmFjdCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXcmFwIGVhY2ggY2FsbCBpbiBhIHByb21pc2UgdGhhdCBjYXRjaGVzIGVycm9yc1xuICAgICAgICAgIGNvbnN0IHNhZmVDYWxsID0gYXN5bmMgKGZuOiAoKSA9PiBQcm9taXNlPGFueT4sIGRlZmF1bHRWYWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXNlIG5ldyBBQkkgbWV0aG9kczogcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZVxuICAgICAgICAgIC8vIEFsc28gdHJ5IHRvIHJlYWQgY3JlYXRvciBkaXJlY3RseSBmcm9tIGNvbnRyYWN0IGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGNvbnN0IFtxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LnF1ZXN0aW9uKCksXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5kZWFkbGluZSgpLFxuICAgICAgICAgICAgbWFya2V0Q29udHJhY3QucmVzb2x2ZWQoKSxcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0Lm91dGNvbWUoKSwgLy8gZW51bTogMCwxLDJcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gcmVhZCBjcmVhdG9yIGRpcmVjdGx5IGZyb20gY29udHJhY3QgKHNpbXBsZXN0IG1ldGhvZClcbiAgICAgICAgICBsZXQgY3JlYXRvckZyb21Db250cmFjdDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNyZWF0b3JGcm9tQ29udHJhY3QgPSBhd2FpdCBtYXJrZXRDb250cmFjdC5jcmVhdG9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBDb250cmFjdCBtaWdodCBub3QgaGF2ZSBjcmVhdG9yKCkgZnVuY3Rpb24sIHRoYXQncyBva2F5XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gZG9lcyBub3QgaGF2ZSBjcmVhdG9yKCkgZnVuY3Rpb25gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGFkZGl0aW9uYWwgZGF0YSBpZiBtZXRob2RzIGV4aXN0IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgICAgICBsZXQgY3VycmVudFByaWNlID0gMG47XG4gICAgICAgICAgbGV0IGxvY2tQcmljZSA9IDBuO1xuICAgICAgICAgIGxldCB0b3RhbFllcyA9IDBuO1xuICAgICAgICAgIGxldCB0b3RhbE5vID0gMG47XG4gICAgICAgICAgbGV0IGZlZWRJZCA9IFwiMHgwXCI7XG4gICAgICAgICAgbGV0IHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFtjdXJyZW50UHJpY2UsIGxvY2tQcmljZSwgc3RhdGUsIHRvdGFsWWVzLCB0b3RhbE5vLCBmZWVkSWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5nZXRDdXJyZW50UHJpY2UoKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5zdGF0ZSgpLCAwKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QudG90YWxZZXMoKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC50b3RhbE5vKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QuZmVlZElkKCksIFwiMHgwXCIpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiBtZXRob2RzIGRvbid0IGV4aXN0LCBkZWZhdWx0cyBhcmUgYWxyZWFkeSBzZXQgYWJvdmVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU29tZSBvcHRpb25hbCBtZXRob2RzIG5vdCBhdmFpbGFibGUgZm9yIG1hcmtldCAke2FkZHJlc3N9LCB1c2luZyBkZWZhdWx0c2ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hcCByZXNvbHZlZC9vdXRjb21lIHRvIE1hcmtldFN0YXRlXG4gICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLlJlc29sdmVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyKGRlYWRsaW5lKSA8PSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5Mb2NrZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnZlcnQgZmVlZElkIGJ5dGVzMzIgdG8gc3RyaW5nIChyZW1vdmUgbnVsbCBieXRlcykgaWYgaXQncyBhIGJ5dGVzMzJcbiAgICAgICAgICBsZXQgZmVlZElkU3RyID0gXCJcIjtcbiAgICAgICAgICBsZXQgZmVlZElkSGV4ID0gXCIweDBcIjtcbiAgICAgICAgICBpZiAoZmVlZElkICYmIGZlZWRJZCAhPT0gXCIweDBcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmVlZElkU3RyID0gZXRoZXJzLnRvVXRmOFN0cmluZyhmZWVkSWQpLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgZmVlZElkSGV4ID0gZmVlZElkU3RyIHx8IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgZmVlZElkSGV4ID0gdHlwZW9mIGZlZWRJZCA9PT0gXCJzdHJpbmdcIiA/IGZlZWRJZCA6IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIG1hdGNoaW5nIGJhY2tlbmQgbWV0YWRhdGFcbiAgICAgICAgICAvLyBQcmltYXJ5OiBtYXRjaCBieSBtYXJrZXQgYWRkcmVzcyAobW9zdCByZWxpYWJsZSlcbiAgICAgICAgICBjb25zdCBhZGRyZXNzTG93ZXIgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbGV0IGJhY2tlbmRNYXJrZXQgPSBiYWNrZW5kTWFwQnlBZGRyZXNzLmdldChhZGRyZXNzTG93ZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZhbGxiYWNrOiBtYXRjaCBieSBmZWVkSWQgaWYgYWRkcmVzcyBtYXRjaCBmYWlsZWRcbiAgICAgICAgICBpZiAoIWJhY2tlbmRNYXJrZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRJZExvd2VyID0gZmVlZElkSGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBmZWVkSWROb1ByZWZpeCA9IGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykgPyBmZWVkSWRMb3dlci5zbGljZSgyKSA6IGZlZWRJZExvd2VyO1xuICAgICAgICAgICAgYmFja2VuZE1hcmtldCA9IGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkTG93ZXIpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWROb1ByZWZpeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkU3RyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNyZWF0aW9uVHhIYXNoID0gY3JlYXRpb25UeE1hcC5nZXQoYWRkcmVzc0xvd2VyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcmlvcml0eSAxOiBSZWFkIGNyZWF0b3IgZGlyZWN0bHkgZnJvbSBjb250cmFjdCAoc2ltcGxlc3QgYW5kIG1vc3QgcmVsaWFibGUpXG4gICAgICAgICAgbGV0IGNyZWF0b3JBZGRyZXNzID0gY3JlYXRvckZyb21Db250cmFjdCA/IGNyZWF0b3JGcm9tQ29udHJhY3QudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJpb3JpdHkgMjogVXNlIGNyZWF0b3IgZnJvbSBldmVudCBtYXAgKGZyb20gc2luZ2xlIGdldExvZ3MgY2FsbClcbiAgICAgICAgICBpZiAoIWNyZWF0b3JBZGRyZXNzKSB7XG4gICAgICAgICAgICBjcmVhdG9yQWRkcmVzcyA9IGNyZWF0b3JCeU1hcmtldFthZGRyZXNzTG93ZXJdIHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByaW9yaXR5IDM6IFVzZSBiYWNrZW5kIGNyZWF0b3JfYWRkcmVzc1xuICAgICAgICAgIGlmICghY3JlYXRvckFkZHJlc3MgJiYgYmFja2VuZE1hcmtldD8uY3JlYXRvcl9hZGRyZXNzKSB7XG4gICAgICAgICAgICBjcmVhdG9yQWRkcmVzcyA9IGJhY2tlbmRNYXJrZXQuY3JlYXRvcl9hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFVzaW5nIGNyZWF0b3IgZnJvbSBiYWNrZW5kOiAke2NyZWF0b3JBZGRyZXNzfSBmb3IgbWFya2V0ICR7YWRkcmVzc31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNyZWF0b3JBZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIE1hcmtldCAke2FkZHJlc3N9IGNyZWF0b3I6ICR7Y3JlYXRvckFkZHJlc3N9IChmcm9tICR7Y3JlYXRvckZyb21Db250cmFjdCA/ICdjb250cmFjdCcgOiBjcmVhdG9yQnlNYXJrZXRbYWRkcmVzc0xvd2VyXSA/ICdldmVudHMnIDogJ2JhY2tlbmQnfSlgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IGltYWdlVXJsIGZyb20gYmFja2VuZCBtYXJrZXQgKHN1cHBvcnQgYm90aCBzbmFrZV9jYXNlIGFuZCBjYW1lbENhc2UpXG4gICAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSBiYWNrZW5kTWFya2V0Py5pbWFnZV91cmwgfHwgYmFja2VuZE1hcmtldD8uaW1hZ2VVcmwgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoaW1hZ2VVcmwgJiYgYWRkcmVzc0xvd2VyID09PSBtYXJrZXRBZGRyZXNzZXNbMF0/LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gaGFzIGltYWdlVXJsOmAsIGltYWdlVXJsLnN1YnN0cmluZygwLCAxMDApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBxdWVzdGlvbiAtIHByaW9yaXRpemUgY29udHJhY3QsIHRoZW4gYmFja2VuZCwgdGhlbiBmYWxsYmFja1xuICAgICAgICAgIGNvbnN0IGRpc3BsYXlRdWVzdGlvbiA9IHF1ZXN0aW9uIHx8IGJhY2tlbmRNYXJrZXQ/LnF1ZXN0aW9uIHx8IGBNYXJrZXQgJHthZGRyZXNzLnNsaWNlKDAsIDgpfS4uLiR7YWRkcmVzcy5zbGljZSgtNil9YDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYXRlZ29yeTogdXNlIGJhY2tlbmQgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdHJ5IHRvIGluZmVyIG9yIHVzZSBcIk90aGVyXCJcbiAgICAgICAgICBjb25zdCBkaXNwbGF5Q2F0ZWdvcnkgPSBiYWNrZW5kTWFya2V0Py5jYXRlZ29yeSB8fCBcIk90aGVyXCI7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbWFya2V0RGF0YTogTWFya2V0RGF0YSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgICAgIGN1cnJlbnRQcmljZTogY3VycmVudFByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudFByaWNlKSA6IFwiMFwiLFxuICAgICAgICAgICAgbG9ja1ByaWNlOiBsb2NrUHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpIDogXCIwXCIsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgICAgICB0b3RhbFllczogdG90YWxZZXMgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbFllcykgOiBcIjBcIixcbiAgICAgICAgICAgIHRvdGFsTm86IHRvdGFsTm8gPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSA6IFwiMFwiLFxuICAgICAgICAgICAgLy8gVXNlIHF1ZXN0aW9uIGZyb20gY29udHJhY3QgZmlyc3QgKG1vc3QgcmVsaWFibGUpLCBmYWxsYmFjayB0byBiYWNrZW5kLCB0aGVuIGdlbmVyaWNcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBkaXNwbGF5UXVlc3Rpb24sXG4gICAgICAgICAgICBjYXRlZ29yeTogZGlzcGxheUNhdGVnb3J5LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGJhY2tlbmRNYXJrZXQ/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaW1hZ2VVcmw6IGltYWdlVXJsLCAvLyBTZXQgaW1hZ2VVcmwgZXhwbGljaXRseSAoZnJvbSBiYWNrZW5kIGlmIGF2YWlsYWJsZSlcbiAgICAgICAgICAgIGNyZWF0aW9uVHhIYXNoOiBjcmVhdGlvblR4SGFzaCxcbiAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzOiBjcmVhdG9yQWRkcmVzcywgLy8gU2hvdWxkIGFsd2F5cyBiZSBzZXQgYnkgbm93IChmcm9tIGV2ZW50cyBvciBiYWNrZW5kKVxuICAgICAgICAgICAgY3JlYXRlZEF0OiBiYWNrZW5kTWFya2V0Py5jcmVhdGVkX2F0IHx8IGJhY2tlbmRNYXJrZXQ/LmNyZWF0ZWRBdCwgLy8gU3VwcG9ydCBib3RoIG5hbWluZyBjb252ZW50aW9uc1xuICAgICAgICAgICAgLy8gSW5jbHVkZSBiYWNrZW5kIG1hcmtldF9pZCBmb3IgQVBJIGNhbGxzIChNYXJrZXRJbmZvLCBNYXJrZXRDaGF0KVxuICAgICAgICAgICAgbWFya2V0SWQ6IGJhY2tlbmRNYXJrZXQ/Lm1hcmtldF9pZCB8fCBiYWNrZW5kTWFya2V0Py5pZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2cgaWYgbWFya2V0IGlzIG1pc3NpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgICAgIGlmICghYmFja2VuZE1hcmtldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBNYXJrZXQgJHthZGRyZXNzfSBpcyBvbi1jaGFpbiBidXQgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhLiBVc2luZyBjb250cmFjdCBkYXRhIG9ubHkuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1hcmtldERhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbWFya2V0ICR7YWRkcmVzc306YCwgZXJyKTtcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGF0IGxlYXN0IGJhc2ljIGRhdGEgdXNpbmcgbmV3IEFCSSBpZiBvdGhlciBjYWxscyBmYWlsXG4gICAgICAgICAgbGV0IHF1ZXN0aW9uID0gXCJcIjtcbiAgICAgICAgICBsZXQgZGVhZGxpbmUgPSAwO1xuICAgICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgIGxldCBvdXRjb21lID0gMG47XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2ljQ29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgTUFSS0VUX0FCSSwgcHJvdmlkZXJGb3JDb250cmFjdCk7XG4gICAgICAgICAgICBbcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3QucXVlc3Rpb24oKSxcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5kZWFkbGluZSgpLFxuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0LnJlc29sdmVkKCksXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3Qub3V0Y29tZSgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBjYXRjaCAocXVlc3Rpb25FcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZldGNoIGJhc2ljIGRhdGEgZm9yIG1hcmtldCAke2FkZHJlc3N9OmAsIHF1ZXN0aW9uRXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHN0YXRlIGZyb20gcmVzb2x2ZWQvZGVhZGxpbmVcbiAgICAgICAgICBsZXQgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLlJlc29sdmVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVhZGxpbmUgPiAwICYmIGRlYWRsaW5lIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkxvY2tlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmV0dXJuIG1pbmltYWwgZGF0YSBpZiBjb250cmFjdCBjYWxsIGZhaWxzLCBidXQgc3RpbGwgaW5jbHVkZSB0aGUgYWRkcmVzc1xuICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBtYXJrZXRzIGFyZSBzaG93biBldmVuIGlmIHNvbWUgY2FsbHMgZmFpbFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZmVlZElkOiBcIlwiLFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIGxvY2tQcmljZTogXCIwXCIsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICB0b3RhbFllczogXCIwXCIsXG4gICAgICAgICAgICB0b3RhbE5vOiBcIjBcIixcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbiB8fCBgTWFya2V0ICR7YWRkcmVzcy5zbGljZSgwLCA4KX0uLi4ke2FkZHJlc3Muc2xpY2UoLTYpfWAsXG4gICAgICAgICAgfSBhcyBNYXJrZXREYXRhO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWFya2V0RGF0YSA9IGF3YWl0IFByb21pc2UuYWxsKG1hcmtldFByb21pc2VzKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gU3VjY2Vzc2Z1bGx5IGZldGNoZWQgZGF0YSBmb3IgJHttYXJrZXREYXRhLmxlbmd0aH0gbWFya2V0c2ApO1xuICAgICAgXG4gICAgICAvLyBObyBuZWVkIGZvciBiYXRjaCBmZXRjaGluZyAtIHdlIGFscmVhZHkgaGF2ZSBjcmVhdG9ycyBmcm9tIHRoZSBzaW5nbGUgZ2V0TG9ncyBjYWxsXG4gICAgICAvLyBKdXN0IGNoZWNrIGlmIGFueSBtYXJrZXRzIGFyZSBzdGlsbCBtaXNzaW5nIGNyZWF0b3JzIChzaG91bGRuJ3QgaGFwcGVuIGlmIGV2ZW50cyB3ZXJlIHBhcnNlZCBjb3JyZWN0bHkpXG4gICAgICBjb25zdCBtYXJrZXRzTmVlZGluZ0NyZWF0b3JzID0gbWFya2V0RGF0YS5maWx0ZXIobSA9PiBcbiAgICAgICAgbS5hZGRyZXNzICYmIFxuICAgICAgICBtLmFkZHJlc3MgIT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIgJiZcbiAgICAgICAgIW0uY3JlYXRvckFkZHJlc3NcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChtYXJrZXRzTmVlZGluZ0NyZWF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbdXNlTWFya2V0c10gJHttYXJrZXRzTmVlZGluZ0NyZWF0b3JzLmxlbmd0aH0gbWFya2V0cyBzdGlsbCBtaXNzaW5nIGNyZWF0b3JzIGFmdGVyIGV2ZW50IHBhcnNpbmcuIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBpZiBldmVudHMgd2VyZSBwYXJzZWQgY29ycmVjdGx5LmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBdXRvLXN5bmM6IENyZWF0ZSBiYWNrZW5kIGVudHJpZXMgZm9yIG9uLWNoYWluIG1hcmtldHMgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgYWxsIG1hcmtldHMgaGF2ZSBjb21wbGV0ZSBkYXRhXG4gICAgICBjb25zdCBtYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jID0gbWFya2V0RGF0YS5maWx0ZXIobSA9PiBcbiAgICAgICAgbS5hZGRyZXNzICYmIFxuICAgICAgICBtLmFkZHJlc3MgIT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIgJiZcbiAgICAgICAgIW0ubWFya2V0SWQgJiYgLy8gTm8gYmFja2VuZCBJRCBtZWFucyBubyBiYWNrZW5kIGVudHJ5XG4gICAgICAgIG0ucXVlc3Rpb24gJiYgLy8gSGFzIHF1ZXN0aW9uIGZyb20gY29udHJhY3RcbiAgICAgICAgbS5xdWVzdGlvbiAhPT0gYE1hcmtldCAke20uYWRkcmVzcy5zbGljZSgwLCA4KX0uLi4ke20uYWRkcmVzcy5zbGljZSgtNil9YCAvLyBOb3QganVzdCBmYWxsYmFja1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKG1hcmtldHNOZWVkaW5nQmFja2VuZFN5bmMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdICR7bWFya2V0c05lZWRpbmdCYWNrZW5kU3luYy5sZW5ndGh9IG9uLWNoYWluIG1hcmtldHMgbWlzc2luZyBiYWNrZW5kIG1ldGFkYXRhLiBBdXRvLXN5bmNpbmcuLi5gKTtcbiAgICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBiYWNrZW5kIGVudHJpZXMgZm9yIHRoZXNlIG1hcmtldHMgKG5vbi1ibG9ja2luZylcbiAgICAgICAgUHJvbWlzZS5hbGwobWFya2V0c05lZWRpbmdCYWNrZW5kU3luYy5tYXAoYXN5bmMgKG1hcmtldCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCI7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBiYWNrZW5kIGVudHJ5IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICBjb25zdCBiYWNrZW5kTWFya2V0cyA9IGF3YWl0IGF4aW9zLmdldChgJHthcGlVcmx9L2FwaS9tYXJrZXRzYCk7XG4gICAgICAgICAgICBjb25zdCBleGlzdHMgPSBiYWNrZW5kTWFya2V0cy5kYXRhLnNvbWUoKG06IGFueSkgPT4gXG4gICAgICAgICAgICAgIG0ubWFya2V0X2FkZHJlc3M/LnRvTG93ZXJDYXNlKCkgPT09IG1hcmtldC5hZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghZXhpc3RzICYmIG1hcmtldC5xdWVzdGlvbiAmJiBtYXJrZXQuY3JlYXRvckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIGJhY2tlbmQgZW50cnkgd2l0aCBjb250cmFjdCBkYXRhXG4gICAgICAgICAgICAgIGF3YWl0IGF4aW9zLnBvc3QoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2AsIHtcbiAgICAgICAgICAgICAgICBxdWVzdGlvbjogbWFya2V0LnF1ZXN0aW9uLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBtYXJrZXQuY2F0ZWdvcnkgfHwgXCJPdGhlclwiLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA3ICogMjQgKiA2MCAqIDYwLCAvLyBEZWZhdWx0IDcgZGF5c1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb25EZWxheTogMjQgKiA2MCAqIDYwLCAvLyBEZWZhdWx0IDI0IGhvdXJzXG4gICAgICAgICAgICAgICAgaW1hZ2VVcmw6IG1hcmtldC5pbWFnZVVybCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG9yYWNsZVR5cGU6IFwiY2hhaW5saW5rXCIsIC8vIERlZmF1bHRcbiAgICAgICAgICAgICAgICBjcmVhdG9yQWRkcmVzczogbWFya2V0LmNyZWF0b3JBZGRyZXNzLFxuICAgICAgICAgICAgICAgIG1hcmtldEFkZHJlc3M6IG1hcmtldC5hZGRyZXNzLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBBdXRvLWNyZWF0ZWQgYmFja2VuZCBlbnRyeSBmb3IgbWFya2V0ICR7bWFya2V0LmFkZHJlc3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBTaWxlbnRseSBmYWlsIC0gdGhpcyBpcyBqdXN0IGEgc3luYyBhdHRlbXB0XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbdXNlTWFya2V0c10gQ291bGQgbm90IGF1dG8tc3luYyBtYXJrZXQgJHttYXJrZXQuYWRkcmVzc306YCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9ycyAtIHRoaXMgaXMgYmVzdCBlZmZvcnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciBvdXQgbWFya2V0cyB3aXRoIGVtcHR5L2ludmFsaWQgYWRkcmVzc2VzIC0gb25seSBzaG93IHJlYWwgb24tY2hhaW4gbWFya2V0c1xuICAgICAgY29uc3QgdmFsaWRNYXJrZXRzID0gbWFya2V0RGF0YS5maWx0ZXIobSA9PiB7XG4gICAgICAgIC8vIE11c3QgaGF2ZSBhIHZhbGlkIGFkZHJlc3NcbiAgICAgICAgaWYgKCFtLmFkZHJlc3MgfHwgbS5hZGRyZXNzID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11c3QgYmUgYSB2YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFxuICAgICAgICBpZiAoIS9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KG0uYWRkcmVzcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVzdCBoYXZlIGJlZW4gZmV0Y2hlZCBmcm9tIGZhY3RvcnkgKGV4aXN0cyBpbiBtYXJrZXRBZGRyZXNzZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IG1hcmtldHNXaXRoQ3JlYXRvcnMgPSB2YWxpZE1hcmtldHMuZmlsdGVyKG0gPT4gbS5jcmVhdG9yQWRkcmVzcykubGVuZ3RoO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBWYWxpZCBvbi1jaGFpbiBtYXJrZXRzOiAke3ZhbGlkTWFya2V0cy5sZW5ndGh9LCBNYXJrZXRzIHdpdGggY3JlYXRvcnM6ICR7bWFya2V0c1dpdGhDcmVhdG9yc31gKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHRyZW5kaW5nIHNjb3JlcyBhbmQgYWRkIHRvIG1hcmtldCBkYXRhXG4gICAgICBjb25zdCBtYXJrZXRzV2l0aFRyZW5kaW5nID0gdmFsaWRNYXJrZXRzLm1hcChtYXJrZXQgPT4gKHtcbiAgICAgICAgLi4ubWFya2V0LFxuICAgICAgICB0cmVuZGluZ1Njb3JlOiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldCksXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRmluYWwgbWFya2V0cyB0byBkaXNwbGF5OmAsIG1hcmtldHNXaXRoVHJlbmRpbmcubWFwKG0gPT4gKHsgXG4gICAgICAgIGFkZHJlc3M6IG0uYWRkcmVzcywgXG4gICAgICAgIHF1ZXN0aW9uOiBtLnF1ZXN0aW9uIHx8ICdObyBxdWVzdGlvbicsIFxuICAgICAgICBoYXNJbWFnZTogISFtLmltYWdlVXJsLFxuICAgICAgICBpbWFnZVVybDogbS5pbWFnZVVybCA/IGAke20uaW1hZ2VVcmwuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogJ25vbmUnXG4gICAgICB9KSkpO1xuICAgICAgXG4gICAgICBzZXRNYXJrZXRzKG1hcmtldHNXaXRoVHJlbmRpbmcpO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldHM6XCIsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoTWFya2V0cygpO1xuICB9LCBbZmV0Y2hNYXJrZXRzXSk7XG5cbiAgcmV0dXJuIHsgbWFya2V0cywgbG9hZGluZywgZXJyb3IsIHJlZmV0Y2g6IGZldGNoTWFya2V0cyB9O1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYSBzaW5nbGUgbWFya2V0J3MgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0KG1hcmtldEFkZHJlc3M6IHN0cmluZyB8IG51bGwpIHtcbiAgY29uc3QgW21hcmtldCwgc2V0TWFya2V0XSA9IHVzZVN0YXRlPE1hcmtldERhdGEgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmZXRjaE1hcmtldCgpO1xuICB9LCBbbWFya2V0QWRkcmVzc10pO1xuXG4gIGNvbnN0IGZldGNoTWFya2V0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbWFya2V0QWRkcmVzcykgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgLy8gVXNlIEJyb3dzZXJQcm92aWRlciBhbmQgQ29udHJhY3QgZGlyZWN0bHkgd2l0aCBuZXcgQUJJXG4gICAgICBsZXQgcHJvdmlkZXJGb3JDb250cmFjdDogQnJvd3NlclByb3ZpZGVyO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBuZXcgQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBiYXNlUHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gYmFzZVByb3ZpZGVyIGFzIGFueSBhcyBCcm93c2VyUHJvdmlkZXI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KG1hcmtldEFkZHJlc3MsIE1BUktFVF9BQkksIHByb3ZpZGVyRm9yQ29udHJhY3QpO1xuXG4gICAgICAvLyBVc2UgbmV3IEFCSSBtZXRob2RzOiBxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXG4gICAgICBjb25zdCBbcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIG1hcmtldENvbnRyYWN0LnF1ZXN0aW9uKCksXG4gICAgICAgIG1hcmtldENvbnRyYWN0LmRlYWRsaW5lKCksXG4gICAgICAgIG1hcmtldENvbnRyYWN0LnJlc29sdmVkKCksXG4gICAgICAgIG1hcmtldENvbnRyYWN0Lm91dGNvbWUoKSwgLy8gZW51bTogMCwxLDJcbiAgICAgIF0pO1xuXG4gICAgICAvLyBUcnkgdG8gZ2V0IGFkZGl0aW9uYWwgZGF0YSBpZiBtZXRob2RzIGV4aXN0IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgIGxldCBjdXJyZW50UHJpY2UgPSAwbjtcbiAgICAgIGxldCBsb2NrUHJpY2UgPSAwbjtcbiAgICAgIGxldCB0b3RhbFllcyA9IDBuO1xuICAgICAgbGV0IHRvdGFsTm8gPSAwbjtcbiAgICAgIGxldCBmZWVkSWQgPSBcIjB4MFwiO1xuICAgICAgbGV0IHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuXG4gICAgICAvLyBUcnkgdG8gZ2V0IGFkZGl0aW9uYWwgZGF0YSBpZiBtZXRob2RzIGV4aXN0IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgIC8vIFdyYXAgZWFjaCBjYWxsIGluIGEgcHJvbWlzZSB0aGF0IGNhdGNoZXMgZXJyb3JzXG4gICAgICBjb25zdCBzYWZlQ2FsbCA9IGFzeW5jIChmbjogKCkgPT4gUHJvbWlzZTxhbnk+LCBkZWZhdWx0VmFsdWU6IGFueSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0cnkge1xuICAgICAgICBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5nZXRDdXJyZW50UHJpY2UoKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpLCAwbiksXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3Quc3RhdGUoKSwgMCksXG4gICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QudG90YWxZZXMoKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LnRvdGFsTm8oKSwgMG4pLFxuICAgICAgICAgIHNhZmVDYWxsKCgpID0+IG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLCBcIjB4MFwiKSxcbiAgICAgICAgXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWYgbWV0aG9kcyBkb24ndCBleGlzdCwgZGVmYXVsdHMgYXJlIGFscmVhZHkgc2V0IGFib3ZlXG4gICAgICAgIGNvbnNvbGUud2FybihgU29tZSBvcHRpb25hbCBtZXRob2RzIG5vdCBhdmFpbGFibGUgZm9yIG1hcmtldCAke21hcmtldEFkZHJlc3N9LCB1c2luZyBkZWZhdWx0c2ApO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXAgcmVzb2x2ZWQvb3V0Y29tZSB0byBNYXJrZXRTdGF0ZVxuICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICB9IGVsc2UgaWYgKE51bWJlcihkZWFkbGluZSkgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5Mb2NrZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgaWYgYXZhaWxhYmxlXG4gICAgICBsZXQgZmVlZElkU3RyID0gXCJcIjtcbiAgICAgIGxldCBmZWVkSWRIZXggPSBcIjB4MFwiO1xuICAgICAgaWYgKGZlZWRJZCAmJiBmZWVkSWQgIT09IFwiMHgwXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuICAgICAgICAgIGZlZWRJZEhleCA9IGZlZWRJZFN0ciB8fCBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBmZWVkSWRIZXggPSB0eXBlb2YgZmVlZElkID09PSBcInN0cmluZ1wiID8gZmVlZElkIDogZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRNYXJrZXQoe1xuICAgICAgICBhZGRyZXNzOiBtYXJrZXRBZGRyZXNzLFxuICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgY3VycmVudFByaWNlOiBjdXJyZW50UHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihjdXJyZW50UHJpY2UpIDogXCIwXCIsXG4gICAgICAgIGxvY2tQcmljZTogbG9ja1ByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIobG9ja1ByaWNlKSA6IFwiMFwiLFxuICAgICAgICBzdGF0ZTogc3RhdGUgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgIHRvdGFsWWVzOiB0b3RhbFllcyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSA6IFwiMFwiLFxuICAgICAgICB0b3RhbE5vOiB0b3RhbE5vID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxObykgOiBcIjBcIixcbiAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0OlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0XCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgbWFya2V0LCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXQgfTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJldGhlcnMiLCJCcm93c2VyUHJvdmlkZXIiLCJDb250cmFjdCIsImF4aW9zIiwibWFya2V0QXJ0aWZhY3QiLCJnZXRGYWN0b3J5Q29udHJhY3QiLCJnZXRQcm92aWRlciIsIk1hcmtldFN0YXRlIiwiRkFDVE9SWV9BRERSRVNTIiwiTUFSS0VUX0FCSSIsImFiaSIsImNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUiLCJtYXJrZXQiLCJ0b3RhbFllcyIsInBhcnNlRmxvYXQiLCJ0b3RhbE5vIiwidG90YWxMaXF1aWRpdHkiLCJzY29yZSIsInN0YXRlIiwiQWN0aXZlIiwiYmFsYW5jZSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1c2VNYXJrZXRzIiwibWFya2V0cyIsInNldE1hcmtldHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJmZXRjaE1hcmtldHMiLCJwcm92aWRlciIsImZhY3RvcnkiLCJtYXJrZXRBZGRyZXNzZXMiLCJnZXRNYXJrZXRzIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImNyZWF0aW9uVHhNYXAiLCJNYXAiLCJjcmVhdG9yQnlNYXJrZXQiLCJNQVJLRVRfQ1JFQVRFRF9UT1BJQyIsImlkIiwiZmlsdGVyIiwiYWRkcmVzcyIsInRvcGljcyIsImZyb21CbG9jayIsInRvQmxvY2siLCJsb2dzIiwiZ2V0TG9ncyIsInBhcnNlZCIsImludGVyZmFjZSIsInBhcnNlTG9nIiwiZGF0YSIsInBhcnNlRXJyIiwibWFya2V0QWRkcmVzcyIsImdldEFkZHJlc3MiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwiY3JlYXRvckFkZHJlc3MiLCJzZXQiLCJ0cmFuc2FjdGlvbkhhc2giLCJhcmdzIiwiY3JlYXRvciIsIndhcm4iLCJPYmplY3QiLCJrZXlzIiwiZXJyIiwiYmFja2VuZE1hcmtldHMiLCJhcGlVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInJlc3BvbnNlIiwiZ2V0IiwiYmFja2VuZE1hcEJ5QWRkcmVzcyIsImJhY2tlbmRNYXBCeUZlZWRJZCIsImZvckVhY2giLCJtIiwibWFya2V0X2FkZHJlc3MiLCJhZGRyTG93ZXIiLCJmZWVkX2lkIiwiZmVlZElkTG93ZXIiLCJzdGFydHNXaXRoIiwibWFya2V0UHJvbWlzZXMiLCJtYXAiLCJwcm92aWRlckZvckNvbnRyYWN0Iiwid2luZG93IiwiZXRoZXJldW0iLCJtYXJrZXRDb250cmFjdCIsInNhZmVDYWxsIiwiZm4iLCJkZWZhdWx0VmFsdWUiLCJxdWVzdGlvbiIsImRlYWRsaW5lIiwicmVzb2x2ZWQiLCJvdXRjb21lIiwiUHJvbWlzZSIsImFsbCIsImNyZWF0b3JGcm9tQ29udHJhY3QiLCJkZWJ1ZyIsImN1cnJlbnRQcmljZSIsImxvY2tQcmljZSIsImZlZWRJZCIsImdldEN1cnJlbnRQcmljZSIsIlJlc29sdmVkIiwiTnVtYmVyIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiTG9ja2VkIiwiZmVlZElkU3RyIiwiZmVlZElkSGV4IiwidG9VdGY4U3RyaW5nIiwicmVwbGFjZSIsImhleGxpZnkiLCJhZGRyZXNzTG93ZXIiLCJiYWNrZW5kTWFya2V0IiwiZmVlZElkTm9QcmVmaXgiLCJjcmVhdGlvblR4SGFzaCIsImNyZWF0b3JfYWRkcmVzcyIsImltYWdlVXJsIiwiaW1hZ2VfdXJsIiwic3Vic3RyaW5nIiwiZGlzcGxheVF1ZXN0aW9uIiwiZGlzcGxheUNhdGVnb3J5IiwiY2F0ZWdvcnkiLCJtYXJrZXREYXRhIiwiZm9ybWF0RXRoZXIiLCJkZXNjcmlwdGlvbiIsImNyZWF0ZWRBdCIsImNyZWF0ZWRfYXQiLCJtYXJrZXRJZCIsIm1hcmtldF9pZCIsInVuZGVmaW5lZCIsImJhc2ljQ29udHJhY3QiLCJxdWVzdGlvbkVyciIsIm1hcmtldHNOZWVkaW5nQ3JlYXRvcnMiLCJtYXJrZXRzTmVlZGluZ0JhY2tlbmRTeW5jIiwiZXhpc3RzIiwic29tZSIsInBvc3QiLCJkdXJhdGlvbiIsInJlc29sdXRpb25EZWxheSIsIm9yYWNsZVR5cGUiLCJjYXRjaCIsInZhbGlkTWFya2V0cyIsInRlc3QiLCJtYXJrZXRzV2l0aENyZWF0b3JzIiwibWFya2V0c1dpdGhUcmVuZGluZyIsInRyZW5kaW5nU2NvcmUiLCJoYXNJbWFnZSIsIm1lc3NhZ2UiLCJyZWZldGNoIiwidXNlTWFya2V0Iiwic2V0TWFya2V0IiwiZmV0Y2hNYXJrZXQiLCJiYXNlUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});