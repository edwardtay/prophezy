"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/create/page",{

/***/ "(app-pages-browser)/./src/lib/contracts.ts":
/*!******************************!*\
  !*** ./src/lib/contracts.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BNB_TESTNET_CHAIN_ID: function() { return /* binding */ BNB_TESTNET_CHAIN_ID; },\n/* harmony export */   BNB_TESTNET_CONFIG: function() { return /* binding */ BNB_TESTNET_CONFIG; },\n/* harmony export */   BNB_TESTNET_FEEDS: function() { return /* binding */ BNB_TESTNET_FEEDS; },\n/* harmony export */   BNB_TESTNET_RPC: function() { return /* binding */ BNB_TESTNET_RPC; },\n/* harmony export */   CONTRACT_ADDRESSES: function() { return /* binding */ CONTRACT_ADDRESSES; },\n/* harmony export */   FACTORY_ADDRESS: function() { return /* binding */ FACTORY_ADDRESS; },\n/* harmony export */   MarketState: function() { return /* binding */ MarketState; },\n/* harmony export */   ORACLE_ROUTER_ABI: function() { return /* binding */ ORACLE_ROUTER_ABI; },\n/* harmony export */   ORACLE_ROUTER_ADDRESS: function() { return /* binding */ ORACLE_ROUTER_ADDRESS; },\n/* harmony export */   PREDICTION_MARKET_ABI: function() { return /* binding */ PREDICTION_MARKET_ABI; },\n/* harmony export */   PREDICTION_MARKET_FACTORY_ABI: function() { return /* binding */ PREDICTION_MARKET_FACTORY_ABI; },\n/* harmony export */   ensureBNBTestnet: function() { return /* binding */ ensureBNBTestnet; },\n/* harmony export */   getFactoryContract: function() { return /* binding */ getFactoryContract; },\n/* harmony export */   getMarketContract: function() { return /* binding */ getMarketContract; },\n/* harmony export */   getProvider: function() { return /* binding */ getProvider; },\n/* harmony export */   getSigner: function() { return /* binding */ getSigner; },\n/* harmony export */   isOnBNBTestnet: function() { return /* binding */ isOnBNBTestnet; },\n/* harmony export */   switchToBNBTestnet: function() { return /* binding */ switchToBNBTestnet; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _abi_PredictionMarketFactory_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/abi/PredictionMarketFactory.json */ \"(app-pages-browser)/./src/abi/PredictionMarketFactory.json\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n\n\n\n// Deployed contract addresses on BNB Testnet\nconst ORACLE_ROUTER_ADDRESS = \"0x8F878deCd44f7Cf547D559a6e6D0577E370fa0Db\";\nconst FACTORY_ADDRESS = \"0xEff2eC240CEB2Ddf582Df0e42fc66a6910D3Fe3f\";\n// Backward compatibility - keep existing CONTRACT_ADDRESSES object\nconst CONTRACT_ADDRESSES = {\n    ORACLE_ROUTER: ORACLE_ROUTER_ADDRESS,\n    PREDICTION_MARKET_FACTORY: FACTORY_ADDRESS\n};\n// BNB Testnet feeds map\nconst BNB_TESTNET_FEEDS = {\n    BTC: \"0x491fD333937522e69D1c3FB944fbC5e95eEF9f59\",\n    ETH: \"0x635780E5D02Ab29d7aE14d266936A38d3D5B0CC5\",\n    BNB: \"0x1A26d803C2e796601794f8C5609549643832702C\"\n};\n// BNB Testnet RPC\nconst BNB_TESTNET_RPC = \"https://data-seed-prebsc-1-s1.binance.org:8545\";\nconst BNB_TESTNET_CHAIN_ID = 97;\n// BNB Testnet network configuration\nconst BNB_TESTNET_CONFIG = {\n    chainId: \"0x\".concat(BNB_TESTNET_CHAIN_ID.toString(16)),\n    chainName: \"BNB Smart Chain Testnet\",\n    nativeCurrency: {\n        name: \"BNB\",\n        symbol: \"BNB\",\n        decimals: 18\n    },\n    rpcUrls: [\n        BNB_TESTNET_RPC\n    ],\n    blockExplorerUrls: [\n        \"https://testnet.bscscan.com\"\n    ]\n};\n// OracleRouter ABI (if needed to check feedId validity)\nconst ORACLE_ROUTER_ABI = [\n    \"function getPrice(bytes32 feedId) external view returns (uint256)\",\n    \"function isValidFeed(bytes32 feedId) external view returns (bool)\"\n];\n// Keep inline ABI for backward compatibility, but prefer using factoryABI from JSON\nconst PREDICTION_MARKET_FACTORY_ABI = [\n    \"function getMarkets() external view returns (address[] memory)\",\n    \"function createMarket(address feedAddress, string question, uint256 deadlineUnix, uint256 strikePriceRaw) external returns (address)\",\n    \"event MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\"\n];\n// Use the PredictionMarket artifact ABI\nconst PREDICTION_MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Get a provider for BNB Testnet\n */ function getProvider() {\n    return new ethers__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider(BNB_TESTNET_RPC);\n}\n/**\n * Get a signer from Privy wallet\n */ function getSigner(provider) {\n    if ( false || !window.ethereum) {\n        return null;\n    }\n    return new ethers__WEBPACK_IMPORTED_MODULE_3__.BrowserProvider(window.ethereum).getSigner();\n}\n/**\n * Get PredictionMarketFactory contract instance\n */ function getFactoryContract(provider) {\n    const prov = provider || getProvider();\n    return new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(FACTORY_ADDRESS, _abi_PredictionMarketFactory_json__WEBPACK_IMPORTED_MODULE_0__.abi, prov);\n}\n/**\n * Get PredictionMarket contract instance\n */ function getMarketContract(marketAddress, provider) {\n    const prov = provider || getProvider();\n    return new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(marketAddress, PREDICTION_MARKET_ABI, prov);\n}\n/**\n * Switch wallet to BNB Testnet\n * This will prompt the user to switch networks if they're not already on BNB Testnet\n */ async function switchToBNBTestnet() {\n    if ( false || !window.ethereum) {\n        throw new Error(\"No wallet provider found\");\n    }\n    try {\n        // Check current chain ID\n        const currentChainId = await window.ethereum.request({\n            method: \"eth_chainId\"\n        });\n        // If already on BNB Testnet, return success\n        if (currentChainId === BNB_TESTNET_CONFIG.chainId) {\n            return true;\n        }\n        // Try to switch to BNB Testnet\n        try {\n            await window.ethereum.request({\n                method: \"wallet_switchEthereumChain\",\n                params: [\n                    {\n                        chainId: BNB_TESTNET_CONFIG.chainId\n                    }\n                ]\n            });\n            return true;\n        } catch (switchError) {\n            // This error code indicates that the chain has not been added to MetaMask\n            if (switchError.code === 4902) {\n                // Try to add the chain\n                try {\n                    await window.ethereum.request({\n                        method: \"wallet_addEthereumChain\",\n                        params: [\n                            BNB_TESTNET_CONFIG\n                        ]\n                    });\n                    return true;\n                } catch (addError) {\n                    console.error(\"Failed to add BNB Testnet:\", addError);\n                    throw new Error(\"Failed to add BNB Testnet to wallet\");\n                }\n            } else {\n                // User rejected the switch\n                throw switchError;\n            }\n        }\n    } catch (error) {\n        console.error(\"Failed to switch network:\", error);\n        if (error.code === 4001) {\n            throw new Error(\"User rejected network switch\");\n        }\n        throw error;\n    }\n}\n/**\n * Check if wallet is connected to BNB Testnet\n */ async function isOnBNBTestnet() {\n    if ( false || !window.ethereum) {\n        return false;\n    }\n    try {\n        const chainId = await window.ethereum.request({\n            method: \"eth_chainId\"\n        });\n        return chainId === BNB_TESTNET_CONFIG.chainId;\n    } catch (error) {\n        console.error(\"Failed to check chain ID:\", error);\n        return false;\n    }\n}\n/**\n * Ensure wallet is on BNB Testnet before a transaction\n * This should be called right before getting a provider/signer for any transaction\n * It will automatically prompt the user to switch networks if needed\n */ async function ensureBNBTestnet() {\n    if ( false || !window.ethereum) {\n        throw new Error(\"No wallet provider found\");\n    }\n    try {\n        // Check if already on correct network\n        const isOnCorrectNetwork = await isOnBNBTestnet();\n        if (isOnCorrectNetwork) {\n            return;\n        }\n        // Switch to BNB Testnet\n        await switchToBNBTestnet();\n        // Verify switch was successful\n        const verifyNetwork = await isOnBNBTestnet();\n        if (!verifyNetwork) {\n            throw new Error(\"Failed to switch to BNB Testnet. Please switch manually.\");\n        }\n    } catch (error) {\n        var _error_message;\n        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"rejected\")) || error.code === 4001) {\n            throw new Error(\"Please switch to BNB Testnet to continue\");\n        }\n        throw error;\n    }\n}\nvar MarketState;\n(function(MarketState) {\n    MarketState[MarketState[\"Active\"] = 0] = \"Active\";\n    MarketState[MarketState[\"Locked\"] = 1] = \"Locked\";\n    MarketState[MarketState[\"Resolved\"] = 2] = \"Resolved\";\n})(MarketState || (MarketState = {}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udHJhY3RzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2lDO0FBQ1I7QUFFekQsNkNBQTZDO0FBQ3RDLE1BQU1HLHdCQUF3Qiw2Q0FBNkM7QUFDM0UsTUFBTUMsa0JBQWtCLDZDQUE2QztBQUU1RSxtRUFBbUU7QUFDNUQsTUFBTUMscUJBQXFCO0lBQ2hDQyxlQUFlSDtJQUNmSSwyQkFBMkJIO0FBQzdCLEVBQVc7QUFFWCx3QkFBd0I7QUFDakIsTUFBTUksb0JBQW9CO0lBQy9CQyxLQUFLO0lBQ0xDLEtBQUs7SUFDTEMsS0FBSztBQUVQLEVBQVc7QUFFWCxrQkFBa0I7QUFDWCxNQUFNQyxrQkFBa0IsaURBQWlEO0FBQ3pFLE1BQU1DLHVCQUF1QixHQUFHO0FBRXZDLG9DQUFvQztBQUM3QixNQUFNQyxxQkFBcUI7SUFDaENDLFNBQVMsS0FBdUMsT0FBbENGLHFCQUFxQkcsUUFBUSxDQUFDO0lBQzVDQyxXQUFXO0lBQ1hDLGdCQUFnQjtRQUNkQyxNQUFNO1FBQ05DLFFBQVE7UUFDUkMsVUFBVTtJQUNaO0lBQ0FDLFNBQVM7UUFBQ1Y7S0FBZ0I7SUFDMUJXLG1CQUFtQjtRQUFDO0tBQThCO0FBQ3BELEVBQUU7QUFFRix3REFBd0Q7QUFDakQsTUFBTUMsb0JBQW9CO0lBQy9CO0lBQ0E7Q0FDRCxDQUFVO0FBRVgsb0ZBQW9GO0FBQzdFLE1BQU1DLGdDQUFnQztJQUMzQztJQUNBO0lBQ0E7Q0FDRCxDQUFVO0FBRVgsd0NBQXdDO0FBQ2pDLE1BQU1DLHdCQUF3QnhCLDJEQUFrQixDQUFDO0FBRXhEOztDQUVDLEdBQ00sU0FBUzBCO0lBQ2QsT0FBTyxJQUFJNUIsbURBQXNCLENBQUNZO0FBQ3BDO0FBRUE7O0NBRUMsR0FDTSxTQUFTa0IsVUFBVUMsUUFBeUI7SUFDakQsSUFBSSxNQUE2QixJQUFJLENBQUNDLE9BQU9DLFFBQVEsRUFBRTtRQUNyRCxPQUFPO0lBQ1Q7SUFDQSxPQUFPLElBQUlqQyxtREFBc0IsQ0FBQ2dDLE9BQU9DLFFBQVEsRUFBU0gsU0FBUztBQUNyRTtBQUVBOztDQUVDLEdBQ00sU0FBU0ssbUJBQW1CSixRQUEwQjtJQUMzRCxNQUFNSyxPQUFPTCxZQUFZSDtJQUN6QixPQUFPLElBQUk1Qiw0Q0FBZSxDQUN4QkksaUJBQ0FILGtFQUFtQixFQUNuQm1DO0FBRUo7QUFFQTs7Q0FFQyxHQUNNLFNBQVNFLGtCQUNkQyxhQUFxQixFQUNyQlIsUUFBMEI7SUFFMUIsTUFBTUssT0FBT0wsWUFBWUg7SUFDekIsT0FBTyxJQUFJNUIsNENBQWUsQ0FDeEJ1QyxlQUNBYix1QkFDQVU7QUFFSjtBQUVBOzs7Q0FHQyxHQUNNLGVBQWVJO0lBQ3BCLElBQUksTUFBNkIsSUFBSSxDQUFDUixPQUFPQyxRQUFRLEVBQUU7UUFDckQsTUFBTSxJQUFJUSxNQUFNO0lBQ2xCO0lBRUEsSUFBSTtRQUNGLHlCQUF5QjtRQUN6QixNQUFNQyxpQkFBaUIsTUFBTVYsT0FBT0MsUUFBUSxDQUFDVSxPQUFPLENBQUM7WUFDbkRDLFFBQVE7UUFDVjtRQUVBLDRDQUE0QztRQUM1QyxJQUFJRixtQkFBbUI1QixtQkFBbUJDLE9BQU8sRUFBRTtZQUNqRCxPQUFPO1FBQ1Q7UUFFQSwrQkFBK0I7UUFDL0IsSUFBSTtZQUNGLE1BQU1pQixPQUFPQyxRQUFRLENBQUNVLE9BQU8sQ0FBQztnQkFDNUJDLFFBQVE7Z0JBQ1JDLFFBQVE7b0JBQUM7d0JBQUU5QixTQUFTRCxtQkFBbUJDLE9BQU87b0JBQUM7aUJBQUU7WUFDbkQ7WUFDQSxPQUFPO1FBQ1QsRUFBRSxPQUFPK0IsYUFBa0I7WUFDekIsMEVBQTBFO1lBQzFFLElBQUlBLFlBQVlDLElBQUksS0FBSyxNQUFNO2dCQUM3Qix1QkFBdUI7Z0JBQ3ZCLElBQUk7b0JBQ0YsTUFBTWYsT0FBT0MsUUFBUSxDQUFDVSxPQUFPLENBQUM7d0JBQzVCQyxRQUFRO3dCQUNSQyxRQUFROzRCQUFDL0I7eUJBQW1CO29CQUM5QjtvQkFDQSxPQUFPO2dCQUNULEVBQUUsT0FBT2tDLFVBQVU7b0JBQ2pCQyxRQUFRQyxLQUFLLENBQUMsOEJBQThCRjtvQkFDNUMsTUFBTSxJQUFJUCxNQUFNO2dCQUNsQjtZQUNGLE9BQU87Z0JBQ0wsMkJBQTJCO2dCQUMzQixNQUFNSztZQUNSO1FBQ0Y7SUFDRixFQUFFLE9BQU9JLE9BQVk7UUFDbkJELFFBQVFDLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLElBQUlBLE1BQU1ILElBQUksS0FBSyxNQUFNO1lBQ3ZCLE1BQU0sSUFBSU4sTUFBTTtRQUNsQjtRQUNBLE1BQU1TO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZUM7SUFDcEIsSUFBSSxNQUE2QixJQUFJLENBQUNuQixPQUFPQyxRQUFRLEVBQUU7UUFDckQsT0FBTztJQUNUO0lBRUEsSUFBSTtRQUNGLE1BQU1sQixVQUFVLE1BQU1pQixPQUFPQyxRQUFRLENBQUNVLE9BQU8sQ0FBQztZQUM1Q0MsUUFBUTtRQUNWO1FBQ0EsT0FBTzdCLFlBQVlELG1CQUFtQkMsT0FBTztJQUMvQyxFQUFFLE9BQU9tQyxPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE9BQU87SUFDVDtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWVFO0lBQ3BCLElBQUksTUFBNkIsSUFBSSxDQUFDcEIsT0FBT0MsUUFBUSxFQUFFO1FBQ3JELE1BQU0sSUFBSVEsTUFBTTtJQUNsQjtJQUVBLElBQUk7UUFDRixzQ0FBc0M7UUFDdEMsTUFBTVkscUJBQXFCLE1BQU1GO1FBQ2pDLElBQUlFLG9CQUFvQjtZQUN0QjtRQUNGO1FBRUEsd0JBQXdCO1FBQ3hCLE1BQU1iO1FBRU4sK0JBQStCO1FBQy9CLE1BQU1jLGdCQUFnQixNQUFNSDtRQUM1QixJQUFJLENBQUNHLGVBQWU7WUFDbEIsTUFBTSxJQUFJYixNQUFNO1FBQ2xCO0lBQ0YsRUFBRSxPQUFPUyxPQUFZO1lBQ2ZBO1FBQUosSUFBSUEsRUFBQUEsaUJBQUFBLE1BQU1LLE9BQU8sY0FBYkwscUNBQUFBLGVBQWVNLFFBQVEsQ0FBQyxnQkFBZU4sTUFBTUgsSUFBSSxLQUFLLE1BQU07WUFDOUQsTUFBTSxJQUFJTixNQUFNO1FBQ2xCO1FBQ0EsTUFBTVM7SUFDUjtBQUNGOztVQUtZTzs7OztHQUFBQSxnQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jb250cmFjdHMudHM/ZmRkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgZmFjdG9yeUFydGlmYWN0IGZyb20gXCJAL2FiaS9QcmVkaWN0aW9uTWFya2V0RmFjdG9yeS5qc29uXCI7XG5pbXBvcnQgbWFya2V0QXJ0aWZhY3QgZnJvbSBcIkAvYWJpL1ByZWRpY3Rpb25NYXJrZXQuanNvblwiO1xuXG4vLyBEZXBsb3llZCBjb250cmFjdCBhZGRyZXNzZXMgb24gQk5CIFRlc3RuZXRcbmV4cG9ydCBjb25zdCBPUkFDTEVfUk9VVEVSX0FERFJFU1MgPSBcIjB4OEY4NzhkZUNkNDRmN0NmNTQ3RDU1OWE2ZTZEMDU3N0UzNzBmYTBEYlwiO1xuZXhwb3J0IGNvbnN0IEZBQ1RPUllfQUREUkVTUyA9IFwiMHhFZmYyZUMyNDBDRUIyRGRmNTgyRGYwZTQyZmM2NmE2OTEwRDNGZTNmXCI7XG5cbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBrZWVwIGV4aXN0aW5nIENPTlRSQUNUX0FERFJFU1NFUyBvYmplY3RcbmV4cG9ydCBjb25zdCBDT05UUkFDVF9BRERSRVNTRVMgPSB7XG4gIE9SQUNMRV9ST1VURVI6IE9SQUNMRV9ST1VURVJfQUREUkVTUyxcbiAgUFJFRElDVElPTl9NQVJLRVRfRkFDVE9SWTogRkFDVE9SWV9BRERSRVNTLFxufSBhcyBjb25zdDtcblxuLy8gQk5CIFRlc3RuZXQgZmVlZHMgbWFwXG5leHBvcnQgY29uc3QgQk5CX1RFU1RORVRfRkVFRFMgPSB7XG4gIEJUQzogXCIweDQ5MWZEMzMzOTM3NTIyZTY5RDFjM0ZCOTQ0ZmJDNWU5NWVFRjlmNTlcIixcbiAgRVRIOiBcIjB4NjM1NzgwRTVEMDJBYjI5ZDdhRTE0ZDI2NjkzNkEzOGQzRDVCMENDNVwiLFxuICBCTkI6IFwiMHgxQTI2ZDgwM0MyZTc5NjYwMTc5NGY4QzU2MDk1NDk2NDM4MzI3MDJDXCIsXG4gIC8vIGFkZCBtb3JlIGZyb20gdGhlIHNhbWUgdGFibGUgd2hlbiB5b3UgbmVlZCB0aGVtXG59IGFzIGNvbnN0O1xuXG4vLyBCTkIgVGVzdG5ldCBSUENcbmV4cG9ydCBjb25zdCBCTkJfVEVTVE5FVF9SUEMgPSBcImh0dHBzOi8vZGF0YS1zZWVkLXByZWJzYy0xLXMxLmJpbmFuY2Uub3JnOjg1NDVcIjtcbmV4cG9ydCBjb25zdCBCTkJfVEVTVE5FVF9DSEFJTl9JRCA9IDk3O1xuXG4vLyBCTkIgVGVzdG5ldCBuZXR3b3JrIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBCTkJfVEVTVE5FVF9DT05GSUcgPSB7XG4gIGNoYWluSWQ6IGAweCR7Qk5CX1RFU1RORVRfQ0hBSU5fSUQudG9TdHJpbmcoMTYpfWAsIC8vIDB4NjFcbiAgY2hhaW5OYW1lOiBcIkJOQiBTbWFydCBDaGFpbiBUZXN0bmV0XCIsXG4gIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgbmFtZTogXCJCTkJcIixcbiAgICBzeW1ib2w6IFwiQk5CXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICB9LFxuICBycGNVcmxzOiBbQk5CX1RFU1RORVRfUlBDXSxcbiAgYmxvY2tFeHBsb3JlclVybHM6IFtcImh0dHBzOi8vdGVzdG5ldC5ic2NzY2FuLmNvbVwiXSxcbn07XG5cbi8vIE9yYWNsZVJvdXRlciBBQkkgKGlmIG5lZWRlZCB0byBjaGVjayBmZWVkSWQgdmFsaWRpdHkpXG5leHBvcnQgY29uc3QgT1JBQ0xFX1JPVVRFUl9BQkkgPSBbXG4gIFwiZnVuY3Rpb24gZ2V0UHJpY2UoYnl0ZXMzMiBmZWVkSWQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NilcIixcbiAgXCJmdW5jdGlvbiBpc1ZhbGlkRmVlZChieXRlczMyIGZlZWRJZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiLFxuXSBhcyBjb25zdDtcblxuLy8gS2VlcCBpbmxpbmUgQUJJIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBidXQgcHJlZmVyIHVzaW5nIGZhY3RvcnlBQkkgZnJvbSBKU09OXG5leHBvcnQgY29uc3QgUFJFRElDVElPTl9NQVJLRVRfRkFDVE9SWV9BQkkgPSBbXG4gIFwiZnVuY3Rpb24gZ2V0TWFya2V0cygpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzc1tdIG1lbW9yeSlcIixcbiAgXCJmdW5jdGlvbiBjcmVhdGVNYXJrZXQoYWRkcmVzcyBmZWVkQWRkcmVzcywgc3RyaW5nIHF1ZXN0aW9uLCB1aW50MjU2IGRlYWRsaW5lVW5peCwgdWludDI1NiBzdHJpa2VQcmljZVJhdykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgXCJldmVudCBNYXJrZXRDcmVhdGVkKGFkZHJlc3MgaW5kZXhlZCBtYXJrZXQsIGFkZHJlc3MgaW5kZXhlZCBjcmVhdG9yLCBhZGRyZXNzIGluZGV4ZWQgZmVlZEFkZHJlc3MpXCIsXG5dIGFzIGNvbnN0O1xuXG4vLyBVc2UgdGhlIFByZWRpY3Rpb25NYXJrZXQgYXJ0aWZhY3QgQUJJXG5leHBvcnQgY29uc3QgUFJFRElDVElPTl9NQVJLRVRfQUJJID0gbWFya2V0QXJ0aWZhY3QuYWJpO1xuXG4vKipcbiAqIEdldCBhIHByb3ZpZGVyIGZvciBCTkIgVGVzdG5ldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvdmlkZXIoKTogZXRoZXJzLkpzb25ScGNQcm92aWRlciB7XG4gIHJldHVybiBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihCTkJfVEVTVE5FVF9SUEMpO1xufVxuXG4vKipcbiAqIEdldCBhIHNpZ25lciBmcm9tIFByaXZ5IHdhbGxldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmVyKHByb3ZpZGVyOiBldGhlcnMuUHJvdmlkZXIpOiBldGhlcnMuSnNvblJwY1NpZ25lciB8IG51bGwge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93LmV0aGVyZXVtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSBhcyBhbnkpLmdldFNpZ25lcigpO1xufVxuXG4vKipcbiAqIEdldCBQcmVkaWN0aW9uTWFya2V0RmFjdG9yeSBjb250cmFjdCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFjdG9yeUNvbnRyYWN0KHByb3ZpZGVyPzogZXRoZXJzLlByb3ZpZGVyKSB7XG4gIGNvbnN0IHByb3YgPSBwcm92aWRlciB8fCBnZXRQcm92aWRlcigpO1xuICByZXR1cm4gbmV3IGV0aGVycy5Db250cmFjdChcbiAgICBGQUNUT1JZX0FERFJFU1MsXG4gICAgZmFjdG9yeUFydGlmYWN0LmFiaSxcbiAgICBwcm92XG4gICk7XG59XG5cbi8qKlxuICogR2V0IFByZWRpY3Rpb25NYXJrZXQgY29udHJhY3QgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtldENvbnRyYWN0KFxuICBtYXJrZXRBZGRyZXNzOiBzdHJpbmcsXG4gIHByb3ZpZGVyPzogZXRoZXJzLlByb3ZpZGVyXG4pIHtcbiAgY29uc3QgcHJvdiA9IHByb3ZpZGVyIHx8IGdldFByb3ZpZGVyKCk7XG4gIHJldHVybiBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICAgIG1hcmtldEFkZHJlc3MsXG4gICAgUFJFRElDVElPTl9NQVJLRVRfQUJJLFxuICAgIHByb3ZcbiAgKTtcbn1cblxuLyoqXG4gKiBTd2l0Y2ggd2FsbGV0IHRvIEJOQiBUZXN0bmV0XG4gKiBUaGlzIHdpbGwgcHJvbXB0IHRoZSB1c2VyIHRvIHN3aXRjaCBuZXR3b3JrcyBpZiB0aGV5J3JlIG5vdCBhbHJlYWR5IG9uIEJOQiBUZXN0bmV0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzd2l0Y2hUb0JOQlRlc3RuZXQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB3YWxsZXQgcHJvdmlkZXIgZm91bmRcIik7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIENoZWNrIGN1cnJlbnQgY2hhaW4gSURcbiAgICBjb25zdCBjdXJyZW50Q2hhaW5JZCA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLFxuICAgIH0pO1xuXG4gICAgLy8gSWYgYWxyZWFkeSBvbiBCTkIgVGVzdG5ldCwgcmV0dXJuIHN1Y2Nlc3NcbiAgICBpZiAoY3VycmVudENoYWluSWQgPT09IEJOQl9URVNUTkVUX0NPTkZJRy5jaGFpbklkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gc3dpdGNoIHRvIEJOQiBUZXN0bmV0XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCIsXG4gICAgICAgIHBhcmFtczogW3sgY2hhaW5JZDogQk5CX1RFU1RORVRfQ09ORklHLmNoYWluSWQgfV0sXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKHN3aXRjaEVycm9yOiBhbnkpIHtcbiAgICAgIC8vIFRoaXMgZXJyb3IgY29kZSBpbmRpY2F0ZXMgdGhhdCB0aGUgY2hhaW4gaGFzIG5vdCBiZWVuIGFkZGVkIHRvIE1ldGFNYXNrXG4gICAgICBpZiAoc3dpdGNoRXJyb3IuY29kZSA9PT0gNDkwMikge1xuICAgICAgICAvLyBUcnkgdG8gYWRkIHRoZSBjaGFpblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfYWRkRXRoZXJldW1DaGFpblwiLFxuICAgICAgICAgICAgcGFyYW1zOiBbQk5CX1RFU1RORVRfQ09ORklHXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoYWRkRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGFkZCBCTkIgVGVzdG5ldDpcIiwgYWRkRXJyb3IpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhZGQgQk5CIFRlc3RuZXQgdG8gd2FsbGV0XCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2VyIHJlamVjdGVkIHRoZSBzd2l0Y2hcbiAgICAgICAgdGhyb3cgc3dpdGNoRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzd2l0Y2ggbmV0d29yazpcIiwgZXJyb3IpO1xuICAgIGlmIChlcnJvci5jb2RlID09PSA0MDAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIHJlamVjdGVkIG5ldHdvcmsgc3dpdGNoXCIpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHdhbGxldCBpcyBjb25uZWN0ZWQgdG8gQk5CIFRlc3RuZXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzT25CTkJUZXN0bmV0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93LmV0aGVyZXVtKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYWluSWQgPT09IEJOQl9URVNUTkVUX0NPTkZJRy5jaGFpbklkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY2hlY2sgY2hhaW4gSUQ6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgd2FsbGV0IGlzIG9uIEJOQiBUZXN0bmV0IGJlZm9yZSBhIHRyYW5zYWN0aW9uXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgcmlnaHQgYmVmb3JlIGdldHRpbmcgYSBwcm92aWRlci9zaWduZXIgZm9yIGFueSB0cmFuc2FjdGlvblxuICogSXQgd2lsbCBhdXRvbWF0aWNhbGx5IHByb21wdCB0aGUgdXNlciB0byBzd2l0Y2ggbmV0d29ya3MgaWYgbmVlZGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbnN1cmVCTkJUZXN0bmV0KCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93LmV0aGVyZXVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gd2FsbGV0IHByb3ZpZGVyIGZvdW5kXCIpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IG9uIGNvcnJlY3QgbmV0d29ya1xuICAgIGNvbnN0IGlzT25Db3JyZWN0TmV0d29yayA9IGF3YWl0IGlzT25CTkJUZXN0bmV0KCk7XG4gICAgaWYgKGlzT25Db3JyZWN0TmV0d29yaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN3aXRjaCB0byBCTkIgVGVzdG5ldFxuICAgIGF3YWl0IHN3aXRjaFRvQk5CVGVzdG5ldCgpO1xuICAgIFxuICAgIC8vIFZlcmlmeSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWxcbiAgICBjb25zdCB2ZXJpZnlOZXR3b3JrID0gYXdhaXQgaXNPbkJOQlRlc3RuZXQoKTtcbiAgICBpZiAoIXZlcmlmeU5ldHdvcmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzd2l0Y2ggdG8gQk5CIFRlc3RuZXQuIFBsZWFzZSBzd2l0Y2ggbWFudWFsbHkuXCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcInJlamVjdGVkXCIpIHx8IGVycm9yLmNvZGUgPT09IDQwMDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzd2l0Y2ggdG8gQk5CIFRlc3RuZXQgdG8gY29udGludWVcIik7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogTWFya2V0IHN0YXRlIGVudW1cbiAqL1xuZXhwb3J0IGVudW0gTWFya2V0U3RhdGUge1xuICBBY3RpdmUgPSAwLFxuICBMb2NrZWQgPSAxLFxuICBSZXNvbHZlZCA9IDIsXG59XG5cbi8qKlxuICogTWFya2V0IGRhdGEgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFya2V0RGF0YSB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgZmVlZElkOiBzdHJpbmc7XG4gIGN1cnJlbnRQcmljZTogc3RyaW5nO1xuICBsb2NrUHJpY2U6IHN0cmluZztcbiAgc3RhdGU6IE1hcmtldFN0YXRlO1xuICB0b3RhbFllczogc3RyaW5nO1xuICB0b3RhbE5vOiBzdHJpbmc7XG4gIC8vIE9wdGlvbmFsIG1ldGFkYXRhIChzdG9yZWQgb2ZmLWNoYWluKVxuICBxdWVzdGlvbj86IHN0cmluZztcbiAgY2F0ZWdvcnk/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBpbWFnZVVybD86IHN0cmluZztcbiAgLy8gQ29tcHV0ZWQgZmllbGRzXG4gIHRyZW5kaW5nU2NvcmU/OiBudW1iZXI7XG4gIGNyZWF0aW9uVHhIYXNoPzogc3RyaW5nOyAvLyBUcmFuc2FjdGlvbiBoYXNoIHRoYXQgY3JlYXRlZCB0aGlzIG1hcmtldFxuICBjcmVhdG9yQWRkcmVzcz86IHN0cmluZzsgLy8gQWRkcmVzcyBvZiB0aGUgbWFya2V0IGNyZWF0b3JcbiAgbWFya2V0SWQ/OiBudW1iZXI7IC8vIEJhY2tlbmQgZGF0YWJhc2UgSUQgZm9yIEFQSSBjYWxsc1xufVxuXG4iXSwibmFtZXMiOlsiZXRoZXJzIiwiZmFjdG9yeUFydGlmYWN0IiwibWFya2V0QXJ0aWZhY3QiLCJPUkFDTEVfUk9VVEVSX0FERFJFU1MiLCJGQUNUT1JZX0FERFJFU1MiLCJDT05UUkFDVF9BRERSRVNTRVMiLCJPUkFDTEVfUk9VVEVSIiwiUFJFRElDVElPTl9NQVJLRVRfRkFDVE9SWSIsIkJOQl9URVNUTkVUX0ZFRURTIiwiQlRDIiwiRVRIIiwiQk5CIiwiQk5CX1RFU1RORVRfUlBDIiwiQk5CX1RFU1RORVRfQ0hBSU5fSUQiLCJCTkJfVEVTVE5FVF9DT05GSUciLCJjaGFpbklkIiwidG9TdHJpbmciLCJjaGFpbk5hbWUiLCJuYXRpdmVDdXJyZW5jeSIsIm5hbWUiLCJzeW1ib2wiLCJkZWNpbWFscyIsInJwY1VybHMiLCJibG9ja0V4cGxvcmVyVXJscyIsIk9SQUNMRV9ST1VURVJfQUJJIiwiUFJFRElDVElPTl9NQVJLRVRfRkFDVE9SWV9BQkkiLCJQUkVESUNUSU9OX01BUktFVF9BQkkiLCJhYmkiLCJnZXRQcm92aWRlciIsIkpzb25ScGNQcm92aWRlciIsImdldFNpZ25lciIsInByb3ZpZGVyIiwid2luZG93IiwiZXRoZXJldW0iLCJCcm93c2VyUHJvdmlkZXIiLCJnZXRGYWN0b3J5Q29udHJhY3QiLCJwcm92IiwiQ29udHJhY3QiLCJnZXRNYXJrZXRDb250cmFjdCIsIm1hcmtldEFkZHJlc3MiLCJzd2l0Y2hUb0JOQlRlc3RuZXQiLCJFcnJvciIsImN1cnJlbnRDaGFpbklkIiwicmVxdWVzdCIsIm1ldGhvZCIsInBhcmFtcyIsInN3aXRjaEVycm9yIiwiY29kZSIsImFkZEVycm9yIiwiY29uc29sZSIsImVycm9yIiwiaXNPbkJOQlRlc3RuZXQiLCJlbnN1cmVCTkJUZXN0bmV0IiwiaXNPbkNvcnJlY3ROZXR3b3JrIiwidmVyaWZ5TmV0d29yayIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIk1hcmtldFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contracts.ts\n"));

/***/ })

});