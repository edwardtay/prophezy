"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory\n            const marketAddresses = await factory.getMarkets();\n            // Fetch MarketCreated events to get creation transaction hashes and creator addresses\n            const creationTxMap = new Map();\n            const creatorMap = new Map();\n            try {\n                // Query MarketCreated events from the factory contract\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        eventTopic\n                    ]\n                };\n                const events = await provider.getLogs(filter);\n                // Parse events\n                for (const log of events){\n                    try {\n                        // Decode the event (market address is the first indexed parameter, creator is second)\n                        const decoded = factory.interface.parseLog({\n                            topics: log.topics,\n                            data: log.data\n                        });\n                        if (decoded && decoded.args && decoded.args.market) {\n                            const marketAddress = decoded.args.market.toLowerCase();\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            // Extract creator address (second indexed parameter)\n                            if (decoded.args.creator) {\n                                creatorMap.set(marketAddress, decoded.args.creator);\n                            }\n                        }\n                    } catch (parseErr) {\n                        // Try alternative parsing - market address might be in topics[1], creator in topics[2]\n                        if (log.topics && log.topics.length > 2) {\n                            const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                            const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26));\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            creatorMap.set(marketAddress, creatorAddress);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" markets in backend metadata\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market using new ABI\n            const marketPromises = marketAddresses.map(async (address)=>{\n                // Use BrowserProvider and Contract directly with new ABI\n                let providerForContract;\n                if ( true && window.ethereum) {\n                    providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n                } else {\n                    providerForContract = provider;\n                }\n                const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                try {\n                    var _marketAddresses_;\n                    // Use new ABI methods: question, deadline, resolved, outcome\n                    const [question, deadline, resolved, outcome] = await Promise.all([\n                        marketContract.question(),\n                        marketContract.deadline(),\n                        marketContract.resolved(),\n                        marketContract.outcome()\n                    ]);\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    let currentPrice = 0n;\n                    let lockPrice = 0n;\n                    let totalYes = 0n;\n                    let totalNo = 0n;\n                    let feedId = \"0x0\";\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    try {\n                        // Try old methods for backward compatibility (if they exist in ABI)\n                        const promises = [];\n                        try {\n                            promises.push(marketContract.getCurrentPrice());\n                        } catch (e) {\n                            promises.push(Promise.resolve(0n));\n                        }\n                        try {\n                            promises.push(marketContract.lockPrice());\n                        } catch (e) {\n                            promises.push(Promise.resolve(0n));\n                        }\n                        try {\n                            promises.push(marketContract.state());\n                        } catch (e) {\n                            promises.push(Promise.resolve(0));\n                        }\n                        try {\n                            promises.push(marketContract.totalYes());\n                        } catch (e) {\n                            promises.push(Promise.resolve(0n));\n                        }\n                        try {\n                            promises.push(marketContract.totalNo());\n                        } catch (e) {\n                            promises.push(Promise.resolve(0n));\n                        }\n                        try {\n                            promises.push(marketContract.feedId());\n                        } catch (e) {\n                            promises.push(Promise.resolve(\"0x0\"));\n                        }\n                        [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all(promises);\n                    } catch (err) {\n                        // If old methods don't exist, use defaults\n                        console.warn(\"Some optional methods not available for market \".concat(address, \", using defaults\"));\n                    }\n                    // Map resolved/outcome to MarketState\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    } else {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes) if it's a bytes32\n                    let feedIdStr = \"\";\n                    let feedIdHex = \"0x0\";\n                    if (feedId && feedId !== \"0x0\") {\n                        try {\n                            feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                            feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        } catch (e) {\n                            feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        }\n                    }\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    const creatorAddress = creatorMap.get(addressLower);\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                        lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                        state: state,\n                        totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                        totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                        // Use question from contract (new ABI)\n                        question: question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question),\n                        category: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress,\n                        // Include backend market_id for API calls (MarketInfo, MarketChat)\n                        marketId: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.market_id) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.id) || undefined\n                    };\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least basic data using new ABI if other calls fail\n                    let question = \"\";\n                    let deadline = 0;\n                    let resolved = false;\n                    let outcome = 0n;\n                    try {\n                        const basicContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                        [question, deadline, resolved, outcome] = await Promise.all([\n                            basicContract.question(),\n                            basicContract.deadline(),\n                            basicContract.resolved(),\n                            basicContract.outcome()\n                        ]);\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch basic data for market \".concat(address, \":\"), questionErr);\n                    }\n                    // Determine state from resolved/deadline\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (deadline > 0 && deadline <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: state,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // Filter out markets with empty addresses (failed fetches)\n            const validMarkets = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\");\n            console.log(\"[useMarkets] Valid markets after filtering: \".concat(validMarkets.length));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            // Use BrowserProvider and Contract directly with new ABI\n            let providerForContract;\n            if ( true && window.ethereum) {\n                providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n            } else {\n                const baseProvider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n                providerForContract = baseProvider;\n            }\n            const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(marketAddress, MARKET_ABI, providerForContract);\n            // Use new ABI methods: question, deadline, resolved, outcome\n            const [question, deadline, resolved, outcome] = await Promise.all([\n                marketContract.question(),\n                marketContract.deadline(),\n                marketContract.resolved(),\n                marketContract.outcome()\n            ]);\n            // Try to get additional data if methods exist (for backward compatibility)\n            let currentPrice = 0n;\n            let lockPrice = 0n;\n            let totalYes = 0n;\n            let totalNo = 0n;\n            let feedId = \"0x0\";\n            let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            try {\n                // Try old methods for backward compatibility (if they exist in ABI)\n                const promises = [];\n                try {\n                    promises.push(marketContract.getCurrentPrice());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.lockPrice());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.state());\n                } catch (e) {\n                    promises.push(Promise.resolve(0));\n                }\n                try {\n                    promises.push(marketContract.totalYes());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.totalNo());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.feedId());\n                } catch (e) {\n                    promises.push(Promise.resolve(\"0x0\"));\n                }\n                [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all(promises);\n            } catch (err) {\n                // If old methods don't exist, use defaults\n                console.warn(\"Some optional methods not available for market \".concat(marketAddress, \", using defaults\"));\n            }\n            // Map resolved/outcome to MarketState\n            if (resolved) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n            } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n            } else {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            }\n            // Convert feedId bytes32 to string if available\n            let feedIdStr = \"\";\n            let feedIdHex = \"0x0\";\n            if (feedId && feedId !== \"0x0\") {\n                try {\n                    feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                } catch (e) {\n                    feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                }\n            }\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdHex,\n                currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                state: state,\n                totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0U7QUFDakM7QUFDK0I7QUFPL0I7QUFFMUIsTUFBTVksYUFBYUwsMkRBQWtCO0FBRXJDOztDQUVDLEdBQ0QsU0FBU08sdUJBQXVCQyxNQUFrQjtJQUNoRCxNQUFNQyxXQUFXQyxXQUFXRixPQUFPQyxRQUFRO0lBQzNDLE1BQU1FLFVBQVVELFdBQVdGLE9BQU9HLE9BQU87SUFDekMsTUFBTUMsaUJBQWlCSCxXQUFXRTtJQUVsQyxxQ0FBcUM7SUFDckMsSUFBSUUsUUFBUUQ7SUFFWiwyQkFBMkI7SUFDM0IsSUFBSUosT0FBT00sS0FBSyxLQUFLWCx1REFBV0EsQ0FBQ1ksTUFBTSxFQUFFO1FBQ3ZDRixTQUFTO0lBQ1g7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTUksVUFBVUMsS0FBS0MsR0FBRyxDQUFDVCxVQUFVRSxXQUFXTSxLQUFLRSxHQUFHLENBQUNWLFVBQVVFO1FBQ2pFRSxTQUFVLElBQUlHLFVBQVUsS0FBTSx1Q0FBdUM7SUFDdkU7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTTztJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQWUsRUFBRTtJQUN2RCxNQUFNLENBQUM4QixTQUFTQyxXQUFXLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWtDLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQixJQUFJO1lBQ0Y2QixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxNQUFNRSxXQUFXMUIsMkRBQVdBO1lBQzVCLE1BQU0yQixVQUFVNUIsa0VBQWtCQSxDQUFDMkI7WUFFbkMsd0NBQXdDO1lBQ3hDLE1BQU1FLGtCQUE0QixNQUFNRCxRQUFRRSxV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QUFnRDtZQUNoRCxJQUFJdUYsWUFBWTtZQUNoQixJQUFJQyxZQUFZO1lBQ2hCLElBQUlaLFVBQVVBLFdBQVcsT0FBTztnQkFDOUIsSUFBSTtvQkFDRlcsWUFBWTFHLGdEQUFtQixDQUFDK0YsUUFBUWMsT0FBTyxDQUFDLE9BQU87b0JBQ3ZERixZQUFZRCxhQUFhMUcsMkNBQWMsQ0FBQytGO2dCQUMxQyxFQUFFLFVBQU07b0JBQ05ZLFlBQVksT0FBT1osV0FBVyxXQUFXQSxTQUFTL0YsMkNBQWMsQ0FBQytGO2dCQUNuRTtZQUNGO1lBRUF1QyxVQUFVO2dCQUNSNUYsU0FBU1U7Z0JBQ1QyQyxRQUFRWTtnQkFDUmQsY0FBY0EsZUFBZSxFQUFFLEdBQUc3RixnREFBa0IsQ0FBQzZGLGdCQUFnQjtnQkFDckVDLFdBQVdBLFlBQVksRUFBRSxHQUFHOUYsZ0RBQWtCLENBQUM4RixhQUFhO2dCQUM1RDVFLE9BQU9BO2dCQUNQTCxVQUFVQSxXQUFXLEVBQUUsR0FBR2IsZ0RBQWtCLENBQUNhLFlBQVk7Z0JBQ3pERSxTQUFTQSxVQUFVLEVBQUUsR0FBR2YsZ0RBQWtCLENBQUNlLFdBQVc7Z0JBQ3REd0UsVUFBVUE7WUFDWjtRQUNGLEVBQUUsT0FBT3pCLEtBQVU7WUFDakJDLFFBQVFsQyxLQUFLLENBQUMsMkJBQTJCaUM7WUFDekNoQyxTQUFTZ0MsSUFBSXFFLE9BQU8sSUFBSTtRQUMxQixTQUFVO1lBQ1J2RyxXQUFXO1FBQ2I7SUFDRjtJQUVBLE9BQU87UUFBRWhCO1FBQVFlO1FBQVNFO1FBQU91RyxTQUFTRztJQUFZO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzP2QzYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGV0aGVycywgQnJvd3NlclByb3ZpZGVyLCBDb250cmFjdCB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBtYXJrZXRBcnRpZmFjdCBmcm9tIFwiQC9hYmkvUHJlZGljdGlvbk1hcmtldC5qc29uXCI7XG5pbXBvcnQge1xuICBnZXRGYWN0b3J5Q29udHJhY3QsXG4gIGdldFByb3ZpZGVyLFxuICBNYXJrZXREYXRhLFxuICBNYXJrZXRTdGF0ZSxcbiAgRkFDVE9SWV9BRERSRVNTLFxufSBmcm9tIFwiLi4vbGliL2NvbnRyYWN0c1wiO1xuXG5jb25zdCBNQVJLRVRfQUJJID0gbWFya2V0QXJ0aWZhY3QuYWJpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZSBiYXNlZCBvbiBsaXF1aWRpdHkgYW5kIGFjdGl2aXR5XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUobWFya2V0OiBNYXJrZXREYXRhKTogbnVtYmVyIHtcbiAgY29uc3QgdG90YWxZZXMgPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbFllcyk7XG4gIGNvbnN0IHRvdGFsTm8gPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbE5vKTtcbiAgY29uc3QgdG90YWxMaXF1aWRpdHkgPSB0b3RhbFllcyArIHRvdGFsTm87XG4gIFxuICAvLyBCYXNlIHNjb3JlIGZyb20gbGlxdWlkaXR5ICh2b2x1bWUpXG4gIGxldCBzY29yZSA9IHRvdGFsTGlxdWlkaXR5O1xuICBcbiAgLy8gQm9vc3QgZm9yIGFjdGl2ZSBtYXJrZXRzXG4gIGlmIChtYXJrZXQuc3RhdGUgPT09IE1hcmtldFN0YXRlLkFjdGl2ZSkge1xuICAgIHNjb3JlICo9IDEuMjtcbiAgfVxuICBcbiAgLy8gQm9vc3QgZm9yIG1hcmtldHMgd2l0aCBiYWxhbmNlZCBsaXF1aWRpdHkgKG1vcmUgaW50ZXJlc3RpbmcpXG4gIGlmICh0b3RhbExpcXVpZGl0eSA+IDApIHtcbiAgICBjb25zdCBiYWxhbmNlID0gTWF0aC5taW4odG90YWxZZXMsIHRvdGFsTm8pIC8gTWF0aC5tYXgodG90YWxZZXMsIHRvdGFsTm8pO1xuICAgIHNjb3JlICo9ICgxICsgYmFsYW5jZSAqIDAuMyk7IC8vIFVwIHRvIDMwJSBib29zdCBmb3IgYmFsYW5jZWQgbWFya2V0c1xuICB9XG4gIFxuICByZXR1cm4gc2NvcmU7XG59XG5cbi8qKlxuICogSG9vayB0byBmZXRjaCBhbGwgbWFya2V0cyBmcm9tIHRoZSBmYWN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXJrZXRzKCkge1xuICBjb25zdCBbbWFya2V0cywgc2V0TWFya2V0c10gPSB1c2VTdGF0ZTxNYXJrZXREYXRhW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZmV0Y2hNYXJrZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IGZhY3RvcnkgPSBnZXRGYWN0b3J5Q29udHJhY3QocHJvdmlkZXIpO1xuXG4gICAgICAvLyBHZXQgYWxsIG1hcmtldCBhZGRyZXNzZXMgZnJvbSBmYWN0b3J5XG4gICAgICBjb25zdCBtYXJrZXRBZGRyZXNzZXM6IHN0cmluZ1tdID0gYXdhaXQgZmFjdG9yeS5nZXRNYXJrZXRzKCk7XG4gICAgICBcbiAgICAgIC8vIEZldGNoIE1hcmtldENyZWF0ZWQgZXZlbnRzIHRvIGdldCBjcmVhdGlvbiB0cmFuc2FjdGlvbiBoYXNoZXMgYW5kIGNyZWF0b3IgYWRkcmVzc2VzXG4gICAgICBjb25zdCBjcmVhdGlvblR4TWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgIGNvbnN0IGNyZWF0b3JNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUXVlcnkgTWFya2V0Q3JlYXRlZCBldmVudHMgZnJvbSB0aGUgZmFjdG9yeSBjb250cmFjdFxuICAgICAgICAvLyBFdmVudCBzaWduYXR1cmU6IE1hcmtldENyZWF0ZWQoYWRkcmVzcyBpbmRleGVkIG1hcmtldCwgYWRkcmVzcyBpbmRleGVkIGNyZWF0b3IsIGFkZHJlc3MgaW5kZXhlZCBmZWVkQWRkcmVzcylcbiAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGV0aGVycy5pZChcIk1hcmtldENyZWF0ZWQoYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MpXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgYWRkcmVzczogRkFDVE9SWV9BRERSRVNTLFxuICAgICAgICAgIHRvcGljczogW2V2ZW50VG9waWNdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBldmVudHMgPSBhd2FpdCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBQYXJzZSBldmVudHNcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgZXZlbnQgKG1hcmtldCBhZGRyZXNzIGlzIHRoZSBmaXJzdCBpbmRleGVkIHBhcmFtZXRlciwgY3JlYXRvciBpcyBzZWNvbmQpXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gZmFjdG9yeS5pbnRlcmZhY2UucGFyc2VMb2coe1xuICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3MsXG4gICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZCAmJiBkZWNvZGVkLmFyZ3MgJiYgZGVjb2RlZC5hcmdzLm1hcmtldCkge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZGVjb2RlZC5hcmdzLm1hcmtldC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgLy8gRXh0cmFjdCBjcmVhdG9yIGFkZHJlc3MgKHNlY29uZCBpbmRleGVkIHBhcmFtZXRlcilcbiAgICAgICAgICAgICAgaWYgKGRlY29kZWQuYXJncy5jcmVhdG9yKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQobWFya2V0QWRkcmVzcywgZGVjb2RlZC5hcmdzLmNyZWF0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXJzaW5nIC0gbWFya2V0IGFkZHJlc3MgbWlnaHQgYmUgaW4gdG9waWNzWzFdLCBjcmVhdG9yIGluIHRvcGljc1syXVxuICAgICAgICAgICAgaWYgKGxvZy50b3BpY3MgJiYgbG9nLnRvcGljcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtldEFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzFdLnNsaWNlKDI2KSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgY29uc3QgY3JlYXRvckFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzJdLnNsaWNlKDI2KSk7XG4gICAgICAgICAgICAgIGNyZWF0aW9uVHhNYXAuc2V0KG1hcmtldEFkZHJlc3MsIGxvZy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICBjcmVhdG9yTWFwLnNldChtYXJrZXRBZGRyZXNzLCBjcmVhdG9yQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGZldGNoIE1hcmtldENyZWF0ZWQgZXZlbnRzOlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke21hcmtldEFkZHJlc3Nlcy5sZW5ndGh9IG1hcmtldHMgZnJvbSBmYWN0b3J5OmAsIG1hcmtldEFkZHJlc3Nlcyk7XG5cbiAgICAgIC8vIEZldGNoIG1ldGFkYXRhIGZyb20gYmFja2VuZCBBUElcbiAgICAgIGxldCBiYWNrZW5kTWFya2V0czogYW55W10gPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjMwMDFcIjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2ApO1xuICAgICAgICBiYWNrZW5kTWFya2V0cyA9IHJlc3BvbnNlLmRhdGEgfHwgW107XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHtiYWNrZW5kTWFya2V0cy5sZW5ndGh9IG1hcmtldHMgaW4gYmFja2VuZCBtZXRhZGF0YWApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXQgbWV0YWRhdGEgZnJvbSBiYWNrZW5kOlwiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgYmFja2VuZCBtYXJrZXRzIGJ5IG1hcmtldF9hZGRyZXNzIChwcmltYXJ5KSBhbmQgZmVlZElkIChmYWxsYmFjaykgZm9yIHF1aWNrIGxvb2t1cFxuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5QWRkcmVzcyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICBjb25zdCBiYWNrZW5kTWFwQnlGZWVkSWQgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgYmFja2VuZE1hcmtldHMuZm9yRWFjaCgobTogYW55KSA9PiB7XG4gICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldF9hZGRyZXNzIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5tYXJrZXRfYWRkcmVzcykge1xuICAgICAgICAgIGNvbnN0IGFkZHJMb3dlciA9IG0ubWFya2V0X2FkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlBZGRyZXNzLnNldChhZGRyTG93ZXIsIG0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrOiBtYXRjaCBieSBmZWVkSWQgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtLmZlZWRfaWQpIHtcbiAgICAgICAgICBjb25zdCBmZWVkSWRMb3dlciA9IG0uZmVlZF9pZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIsIG0pO1xuICAgICAgICAgIC8vIEFsc28gdHJ5IHdpdGhvdXQgMHggcHJlZml4IGlmIHByZXNlbnRcbiAgICAgICAgICBpZiAoZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLnNldChmZWVkSWRMb3dlci5zbGljZSgyKSwgbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRmV0Y2ggZGF0YSBmb3IgZWFjaCBtYXJrZXQgdXNpbmcgbmV3IEFCSVxuICAgICAgY29uc3QgbWFya2V0UHJvbWlzZXMgPSBtYXJrZXRBZGRyZXNzZXMubWFwKGFzeW5jIChhZGRyZXNzKSA9PiB7XG4gICAgICAgIC8vIFVzZSBCcm93c2VyUHJvdmlkZXIgYW5kIENvbnRyYWN0IGRpcmVjdGx5IHdpdGggbmV3IEFCSVxuICAgICAgICBsZXQgcHJvdmlkZXJGb3JDb250cmFjdDogQnJvd3NlclByb3ZpZGVyO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBwcm92aWRlciBhcyBhbnkgYXMgQnJvd3NlclByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIE1BUktFVF9BQkksIHByb3ZpZGVyRm9yQ29udHJhY3QpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVXNlIG5ldyBBQkkgbWV0aG9kczogcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZVxuICAgICAgICAgIGNvbnN0IFtxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LnF1ZXN0aW9uKCksXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5kZWFkbGluZSgpLFxuICAgICAgICAgICAgbWFya2V0Q29udHJhY3QucmVzb2x2ZWQoKSxcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0Lm91dGNvbWUoKSwgLy8gZW51bTogMCwxLDJcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgYWRkaXRpb25hbCBkYXRhIGlmIG1ldGhvZHMgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgICAgIGxldCBjdXJyZW50UHJpY2UgPSAwbjtcbiAgICAgICAgICBsZXQgbG9ja1ByaWNlID0gMG47XG4gICAgICAgICAgbGV0IHRvdGFsWWVzID0gMG47XG4gICAgICAgICAgbGV0IHRvdGFsTm8gPSAwbjtcbiAgICAgICAgICBsZXQgZmVlZElkID0gXCIweDBcIjtcbiAgICAgICAgICBsZXQgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IG9sZCBtZXRob2RzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IChpZiB0aGV5IGV4aXN0IGluIEFCSSlcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSgwbikpOyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSgwbikpOyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LnN0YXRlKCkpO1xuICAgICAgICAgICAgfSBjYXRjaCB7IHByb21pc2VzLnB1c2goUHJvbWlzZS5yZXNvbHZlKDApKTsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC50b3RhbFllcygpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSgwbikpOyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LnRvdGFsTm8oKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHsgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUoMG4pKTsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC5mZWVkSWQoKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHsgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUoXCIweDBcIikpOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFtjdXJyZW50UHJpY2UsIGxvY2tQcmljZSwgc3RhdGUsIHRvdGFsWWVzLCB0b3RhbE5vLCBmZWVkSWRdID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgb2xkIG1ldGhvZHMgZG9uJ3QgZXhpc3QsIHVzZSBkZWZhdWx0c1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTb21lIG9wdGlvbmFsIG1ldGhvZHMgbm90IGF2YWlsYWJsZSBmb3IgbWFya2V0ICR7YWRkcmVzc30sIHVzaW5nIGRlZmF1bHRzYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTWFwIHJlc29sdmVkL291dGNvbWUgdG8gTWFya2V0U3RhdGVcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIoZGVhZGxpbmUpIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkxvY2tlZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgKHJlbW92ZSBudWxsIGJ5dGVzKSBpZiBpdCdzIGEgYnl0ZXMzMlxuICAgICAgICAgIGxldCBmZWVkSWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGxldCBmZWVkSWRIZXggPSBcIjB4MFwiO1xuICAgICAgICAgIGlmIChmZWVkSWQgJiYgZmVlZElkICE9PSBcIjB4MFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuICAgICAgICAgICAgICBmZWVkSWRIZXggPSBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBmZWVkSWRIZXggPSB0eXBlb2YgZmVlZElkID09PSBcInN0cmluZ1wiID8gZmVlZElkIDogZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgbWF0Y2hpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldCBhZGRyZXNzIChtb3N0IHJlbGlhYmxlKVxuICAgICAgICAgIGNvbnN0IGFkZHJlc3NMb3dlciA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsZXQgYmFja2VuZE1hcmtldCA9IGJhY2tlbmRNYXBCeUFkZHJlc3MuZ2V0KGFkZHJlc3NMb3dlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmFsbGJhY2s6IG1hdGNoIGJ5IGZlZWRJZCBpZiBhZGRyZXNzIG1hdGNoIGZhaWxlZFxuICAgICAgICAgIGlmICghYmFja2VuZE1hcmtldCkge1xuICAgICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBmZWVkSWRIZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRJZE5vUHJlZml4ID0gZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSA/IGZlZWRJZExvd2VyLnNsaWNlKDIpIDogZmVlZElkTG93ZXI7XG4gICAgICAgICAgICBiYWNrZW5kTWFya2V0ID0gYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRMb3dlcikgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZE5vUHJlZml4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRTdHIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY3JlYXRpb25UeEhhc2ggPSBjcmVhdGlvblR4TWFwLmdldChhZGRyZXNzTG93ZXIpO1xuICAgICAgICAgIGNvbnN0IGNyZWF0b3JBZGRyZXNzID0gY3JlYXRvck1hcC5nZXQoYWRkcmVzc0xvd2VyKTtcblxuICAgICAgICAgIC8vIEV4dHJhY3QgaW1hZ2VVcmwgZnJvbSBiYWNrZW5kIG1hcmtldCAoc3VwcG9ydCBib3RoIHNuYWtlX2Nhc2UgYW5kIGNhbWVsQ2FzZSlcbiAgICAgICAgICBjb25zdCBpbWFnZVVybCA9IGJhY2tlbmRNYXJrZXQ/LmltYWdlX3VybCB8fCBiYWNrZW5kTWFya2V0Py5pbWFnZVVybCB8fCBudWxsO1xuICAgICAgICAgIGlmIChpbWFnZVVybCAmJiBhZGRyZXNzTG93ZXIgPT09IG1hcmtldEFkZHJlc3Nlc1swXT8udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBNYXJrZXQgJHthZGRyZXNzfSBoYXMgaW1hZ2VVcmw6YCwgaW1hZ2VVcmwuc3Vic3RyaW5nKDAsIDEwMCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG1hcmtldERhdGE6IE1hcmtldERhdGEgPSB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZmVlZElkOiBmZWVkSWRIZXgsXG4gICAgICAgICAgICBjdXJyZW50UHJpY2U6IGN1cnJlbnRQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSkgOiBcIjBcIixcbiAgICAgICAgICAgIGxvY2tQcmljZTogbG9ja1ByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIobG9ja1ByaWNlKSA6IFwiMFwiLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlIGFzIE1hcmtldFN0YXRlLFxuICAgICAgICAgICAgdG90YWxZZXM6IHRvdGFsWWVzID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxZZXMpIDogXCIwXCIsXG4gICAgICAgICAgICB0b3RhbE5vOiB0b3RhbE5vID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxObykgOiBcIjBcIixcbiAgICAgICAgICAgIC8vIFVzZSBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0IChuZXcgQUJJKVxuICAgICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uIHx8IGJhY2tlbmRNYXJrZXQ/LnF1ZXN0aW9uLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGJhY2tlbmRNYXJrZXQ/LmNhdGVnb3J5LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGJhY2tlbmRNYXJrZXQ/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaW1hZ2VVcmw6IGltYWdlVXJsLCAvLyBTZXQgaW1hZ2VVcmwgZXhwbGljaXRseVxuICAgICAgICAgICAgY3JlYXRpb25UeEhhc2g6IGNyZWF0aW9uVHhIYXNoLFxuICAgICAgICAgICAgY3JlYXRvckFkZHJlc3M6IGNyZWF0b3JBZGRyZXNzLFxuICAgICAgICAgICAgLy8gSW5jbHVkZSBiYWNrZW5kIG1hcmtldF9pZCBmb3IgQVBJIGNhbGxzIChNYXJrZXRJbmZvLCBNYXJrZXRDaGF0KVxuICAgICAgICAgICAgbWFya2V0SWQ6IGJhY2tlbmRNYXJrZXQ/Lm1hcmtldF9pZCB8fCBiYWNrZW5kTWFya2V0Py5pZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBtYXJrZXREYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIG1hcmtldCAke2FkZHJlc3N9OmAsIGVycik7XG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBhdCBsZWFzdCBiYXNpYyBkYXRhIHVzaW5nIG5ldyBBQkkgaWYgb3RoZXIgY2FsbHMgZmFpbFxuICAgICAgICAgIGxldCBxdWVzdGlvbiA9IFwiXCI7XG4gICAgICAgICAgbGV0IGRlYWRsaW5lID0gMDtcbiAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgb3V0Y29tZSA9IDBuO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiYXNpY0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIE1BUktFVF9BQkksIHByb3ZpZGVyRm9yQ29udHJhY3QpO1xuICAgICAgICAgICAgW3F1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0LnF1ZXN0aW9uKCksXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3QuZGVhZGxpbmUoKSxcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5yZXNvbHZlZCgpLFxuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0Lm91dGNvbWUoKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gY2F0Y2ggKHF1ZXN0aW9uRXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmZXRjaCBiYXNpYyBkYXRhIGZvciBtYXJrZXQgJHthZGRyZXNzfTpgLCBxdWVzdGlvbkVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERldGVybWluZSBzdGF0ZSBmcm9tIHJlc29sdmVkL2RlYWRsaW5lXG4gICAgICAgICAgbGV0IHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5SZXNvbHZlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlYWRsaW5lID4gMCAmJiBkZWFkbGluZSA8PSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5Mb2NrZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJldHVybiBtaW5pbWFsIGRhdGEgaWYgY29udHJhY3QgY2FsbCBmYWlscywgYnV0IHN0aWxsIGluY2x1ZGUgdGhlIGFkZHJlc3NcbiAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgbWFya2V0cyBhcmUgc2hvd24gZXZlbiBpZiBzb21lIGNhbGxzIGZhaWxcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZWRJZDogXCJcIixcbiAgICAgICAgICAgIGN1cnJlbnRQcmljZTogXCIwXCIsXG4gICAgICAgICAgICBsb2NrUHJpY2U6IFwiMFwiLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgdG90YWxZZXM6IFwiMFwiLFxuICAgICAgICAgICAgdG90YWxObzogXCIwXCIsXG4gICAgICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24gfHwgYE1hcmtldCAke2FkZHJlc3Muc2xpY2UoMCwgOCl9Li4uJHthZGRyZXNzLnNsaWNlKC02KX1gLFxuICAgICAgICAgIH0gYXMgTWFya2V0RGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1hcmtldERhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChtYXJrZXRQcm9taXNlcyk7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFN1Y2Nlc3NmdWxseSBmZXRjaGVkIGRhdGEgZm9yICR7bWFya2V0RGF0YS5sZW5ndGh9IG1hcmtldHNgKTtcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIG91dCBtYXJrZXRzIHdpdGggZW1wdHkgYWRkcmVzc2VzIChmYWlsZWQgZmV0Y2hlcylcbiAgICAgIGNvbnN0IHZhbGlkTWFya2V0cyA9IG1hcmtldERhdGEuZmlsdGVyKG0gPT4gbS5hZGRyZXNzICYmIG0uYWRkcmVzcyAhPT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIik7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIFZhbGlkIG1hcmtldHMgYWZ0ZXIgZmlsdGVyaW5nOiAke3ZhbGlkTWFya2V0cy5sZW5ndGh9YCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZXMgYW5kIGFkZCB0byBtYXJrZXQgZGF0YVxuICAgICAgY29uc3QgbWFya2V0c1dpdGhUcmVuZGluZyA9IHZhbGlkTWFya2V0cy5tYXAobWFya2V0ID0+ICh7XG4gICAgICAgIC4uLm1hcmtldCxcbiAgICAgICAgdHJlbmRpbmdTY29yZTogY2FsY3VsYXRlVHJlbmRpbmdTY29yZShtYXJrZXQpLFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZpbmFsIG1hcmtldHMgdG8gZGlzcGxheTpgLCBtYXJrZXRzV2l0aFRyZW5kaW5nLm1hcChtID0+ICh7IFxuICAgICAgICBhZGRyZXNzOiBtLmFkZHJlc3MsIFxuICAgICAgICBxdWVzdGlvbjogbS5xdWVzdGlvbiB8fCAnTm8gcXVlc3Rpb24nLCBcbiAgICAgICAgaGFzSW1hZ2U6ICEhbS5pbWFnZVVybCxcbiAgICAgICAgaW1hZ2VVcmw6IG0uaW1hZ2VVcmwgPyBgJHttLmltYWdlVXJsLnN1YnN0cmluZygwLCA1MCl9Li4uYCA6ICdub25lJ1xuICAgICAgfSkpKTtcbiAgICAgIFxuICAgICAgc2V0TWFya2V0cyhtYXJrZXRzV2l0aFRyZW5kaW5nKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzOlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0c1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaE1hcmtldHMoKTtcbiAgfSwgW2ZldGNoTWFya2V0c10pO1xuXG4gIHJldHVybiB7IG1hcmtldHMsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldHMgfTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGZldGNoIGEgc2luZ2xlIG1hcmtldCdzIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcmtldChtYXJrZXRBZGRyZXNzOiBzdHJpbmcgfCBudWxsKSB7XG4gIGNvbnN0IFttYXJrZXQsIHNldE1hcmtldF0gPSB1c2VTdGF0ZTxNYXJrZXREYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmV0Y2hNYXJrZXQoKTtcbiAgfSwgW21hcmtldEFkZHJlc3NdKTtcblxuICBjb25zdCBmZXRjaE1hcmtldCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIC8vIFVzZSBCcm93c2VyUHJvdmlkZXIgYW5kIENvbnRyYWN0IGRpcmVjdGx5IHdpdGggbmV3IEFCSVxuICAgICAgbGV0IHByb3ZpZGVyRm9yQ29udHJhY3Q6IEJyb3dzZXJQcm92aWRlcjtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmFzZVByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IGJhc2VQcm92aWRlciBhcyBhbnkgYXMgQnJvd3NlclByb3ZpZGVyO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtYXJrZXRDb250cmFjdCA9IG5ldyBDb250cmFjdChtYXJrZXRBZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcblxuICAgICAgLy8gVXNlIG5ldyBBQkkgbWV0aG9kczogcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZVxuICAgICAgY29uc3QgW3F1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5kZWFkbGluZSgpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5yZXNvbHZlZCgpLFxuICAgICAgICBtYXJrZXRDb250cmFjdC5vdXRjb21lKCksIC8vIGVudW06IDAsMSwyXG4gICAgICBdKTtcblxuICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICBsZXQgY3VycmVudFByaWNlID0gMG47XG4gICAgICBsZXQgbG9ja1ByaWNlID0gMG47XG4gICAgICBsZXQgdG90YWxZZXMgPSAwbjtcbiAgICAgIGxldCB0b3RhbE5vID0gMG47XG4gICAgICBsZXQgZmVlZElkID0gXCIweDBcIjtcbiAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IG9sZCBtZXRob2RzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IChpZiB0aGV5IGV4aXN0IGluIEFCSSlcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpKTtcbiAgICAgICAgfSBjYXRjaCB7IHByb21pc2VzLnB1c2goUHJvbWlzZS5yZXNvbHZlKDBuKSk7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpKTtcbiAgICAgICAgfSBjYXRjaCB7IHByb21pc2VzLnB1c2goUHJvbWlzZS5yZXNvbHZlKDBuKSk7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LnN0YXRlKCkpO1xuICAgICAgICB9IGNhdGNoIHsgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUoMCkpOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC50b3RhbFllcygpKTtcbiAgICAgICAgfSBjYXRjaCB7IHByb21pc2VzLnB1c2goUHJvbWlzZS5yZXNvbHZlKDBuKSk7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hcmtldENvbnRyYWN0LnRvdGFsTm8oKSk7XG4gICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSgwbikpOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC5mZWVkSWQoKSk7XG4gICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZShcIjB4MFwiKSk7IH1cbiAgICAgICAgXG4gICAgICAgIFtjdXJyZW50UHJpY2UsIGxvY2tQcmljZSwgc3RhdGUsIHRvdGFsWWVzLCB0b3RhbE5vLCBmZWVkSWRdID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElmIG9sZCBtZXRob2RzIGRvbid0IGV4aXN0LCB1c2UgZGVmYXVsdHNcbiAgICAgICAgY29uc29sZS53YXJuKGBTb21lIG9wdGlvbmFsIG1ldGhvZHMgbm90IGF2YWlsYWJsZSBmb3IgbWFya2V0ICR7bWFya2V0QWRkcmVzc30sIHVzaW5nIGRlZmF1bHRzYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCByZXNvbHZlZC9vdXRjb21lIHRvIE1hcmtldFN0YXRlXG4gICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5SZXNvbHZlZDtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyKGRlYWRsaW5lKSA8PSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkxvY2tlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IGZlZWRJZCBieXRlczMyIHRvIHN0cmluZyBpZiBhdmFpbGFibGVcbiAgICAgIGxldCBmZWVkSWRTdHIgPSBcIlwiO1xuICAgICAgbGV0IGZlZWRJZEhleCA9IFwiMHgwXCI7XG4gICAgICBpZiAoZmVlZElkICYmIGZlZWRJZCAhPT0gXCIweDBcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZlZWRJZFN0ciA9IGV0aGVycy50b1V0ZjhTdHJpbmcoZmVlZElkKS5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG4gICAgICAgICAgZmVlZElkSGV4ID0gZmVlZElkU3RyIHx8IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGZlZWRJZEhleCA9IHR5cGVvZiBmZWVkSWQgPT09IFwic3RyaW5nXCIgPyBmZWVkSWQgOiBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldE1hcmtldCh7XG4gICAgICAgIGFkZHJlc3M6IG1hcmtldEFkZHJlc3MsXG4gICAgICAgIGZlZWRJZDogZmVlZElkSGV4LFxuICAgICAgICBjdXJyZW50UHJpY2U6IGN1cnJlbnRQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSkgOiBcIjBcIixcbiAgICAgICAgbG9ja1ByaWNlOiBsb2NrUHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpIDogXCIwXCIsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSBhcyBNYXJrZXRTdGF0ZSxcbiAgICAgICAgdG90YWxZZXM6IHRvdGFsWWVzID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxZZXMpIDogXCIwXCIsXG4gICAgICAgIHRvdGFsTm86IHRvdGFsTm8gPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSA6IFwiMFwiLFxuICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXQ6XCIsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBtYXJrZXQsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldCB9O1xufVxuXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsImV0aGVycyIsIkJyb3dzZXJQcm92aWRlciIsIkNvbnRyYWN0IiwiYXhpb3MiLCJtYXJrZXRBcnRpZmFjdCIsImdldEZhY3RvcnlDb250cmFjdCIsImdldFByb3ZpZGVyIiwiTWFya2V0U3RhdGUiLCJGQUNUT1JZX0FERFJFU1MiLCJNQVJLRVRfQUJJIiwiYWJpIiwiY2FsY3VsYXRlVHJlbmRpbmdTY29yZSIsIm1hcmtldCIsInRvdGFsWWVzIiwicGFyc2VGbG9hdCIsInRvdGFsTm8iLCJ0b3RhbExpcXVpZGl0eSIsInNjb3JlIiwic3RhdGUiLCJBY3RpdmUiLCJiYWxhbmNlIiwiTWF0aCIsIm1pbiIsIm1heCIsInVzZU1hcmtldHMiLCJtYXJrZXRzIiwic2V0TWFya2V0cyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoTWFya2V0cyIsInByb3ZpZGVyIiwiZmFjdG9yeSIsIm1hcmtldEFkZHJlc3NlcyIsImdldE1hcmtldHMiLCJjcmVhdGlvblR4TWFwIiwiTWFwIiwiY3JlYXRvck1hcCIsImV2ZW50VG9waWMiLCJpZCIsImZpbHRlciIsImFkZHJlc3MiLCJ0b3BpY3MiLCJldmVudHMiLCJnZXRMb2dzIiwibG9nIiwiZGVjb2RlZCIsImludGVyZmFjZSIsInBhcnNlTG9nIiwiZGF0YSIsImFyZ3MiLCJtYXJrZXRBZGRyZXNzIiwidG9Mb3dlckNhc2UiLCJzZXQiLCJ0cmFuc2FjdGlvbkhhc2giLCJjcmVhdG9yIiwicGFyc2VFcnIiLCJsZW5ndGgiLCJnZXRBZGRyZXNzIiwic2xpY2UiLCJjcmVhdG9yQWRkcmVzcyIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwiYmFja2VuZE1hcmtldHMiLCJhcGlVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInJlc3BvbnNlIiwiZ2V0IiwiYmFja2VuZE1hcEJ5QWRkcmVzcyIsImJhY2tlbmRNYXBCeUZlZWRJZCIsImZvckVhY2giLCJtIiwibWFya2V0X2FkZHJlc3MiLCJhZGRyTG93ZXIiLCJmZWVkX2lkIiwiZmVlZElkTG93ZXIiLCJzdGFydHNXaXRoIiwibWFya2V0UHJvbWlzZXMiLCJtYXAiLCJwcm92aWRlckZvckNvbnRyYWN0Iiwid2luZG93IiwiZXRoZXJldW0iLCJtYXJrZXRDb250cmFjdCIsInF1ZXN0aW9uIiwiZGVhZGxpbmUiLCJyZXNvbHZlZCIsIm91dGNvbWUiLCJQcm9taXNlIiwiYWxsIiwiY3VycmVudFByaWNlIiwibG9ja1ByaWNlIiwiZmVlZElkIiwicHJvbWlzZXMiLCJwdXNoIiwiZ2V0Q3VycmVudFByaWNlIiwicmVzb2x2ZSIsIlJlc29sdmVkIiwiTnVtYmVyIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiTG9ja2VkIiwiZmVlZElkU3RyIiwiZmVlZElkSGV4IiwidG9VdGY4U3RyaW5nIiwicmVwbGFjZSIsImhleGxpZnkiLCJhZGRyZXNzTG93ZXIiLCJiYWNrZW5kTWFya2V0IiwiZmVlZElkTm9QcmVmaXgiLCJjcmVhdGlvblR4SGFzaCIsImltYWdlVXJsIiwiaW1hZ2VfdXJsIiwic3Vic3RyaW5nIiwibWFya2V0RGF0YSIsImZvcm1hdEV0aGVyIiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsIm1hcmtldElkIiwibWFya2V0X2lkIiwidW5kZWZpbmVkIiwiYmFzaWNDb250cmFjdCIsInF1ZXN0aW9uRXJyIiwidmFsaWRNYXJrZXRzIiwibWFya2V0c1dpdGhUcmVuZGluZyIsInRyZW5kaW5nU2NvcmUiLCJoYXNJbWFnZSIsIm1lc3NhZ2UiLCJyZWZldGNoIiwidXNlTWFya2V0Iiwic2V0TWFya2V0IiwiZmV0Y2hNYXJrZXQiLCJiYXNlUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});