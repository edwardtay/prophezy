"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abi/PredictionMarket.json */ \"(app-pages-browser)/./src/abi/PredictionMarket.json\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n\nconst MARKET_ABI = _abi_PredictionMarket_json__WEBPACK_IMPORTED_MODULE_1__.abi;\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getFactoryContract)(provider);\n            // Get all market addresses from factory\n            const marketAddresses = await factory.getMarkets();\n            // Fetch MarketCreated events to get creation transaction hashes and creator addresses\n            const creationTxMap = new Map();\n            const creatorMap = new Map();\n            try {\n                // Query MarketCreated events from the factory contract\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_3__.id(\"MarketCreated(address,address,address)\");\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.FACTORY_ADDRESS,\n                    topics: [\n                        eventTopic\n                    ]\n                };\n                const events = await provider.getLogs(filter);\n                // Parse events\n                for (const log of events){\n                    try {\n                        // Decode the event (market address is the first indexed parameter, creator is second)\n                        const decoded = factory.interface.parseLog({\n                            topics: log.topics,\n                            data: log.data\n                        });\n                        if (decoded && decoded.args && decoded.args.market) {\n                            const marketAddress = decoded.args.market.toLowerCase();\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            // Extract creator address (second indexed parameter)\n                            if (decoded.args.creator) {\n                                creatorMap.set(marketAddress, decoded.args.creator);\n                            }\n                        }\n                    } catch (parseErr) {\n                        // Try alternative parsing - market address might be in topics[1], creator in topics[2]\n                        if (log.topics && log.topics.length > 2) {\n                            const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                            const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(\"0x\" + log.topics[2].slice(26));\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            creatorMap.set(marketAddress, creatorAddress);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" markets in backend metadata\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market using new ABI\n            const marketPromises = marketAddresses.map(async (address)=>{\n                // Use BrowserProvider and Contract directly with new ABI\n                let providerForContract;\n                if ( true && window.ethereum) {\n                    providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n                } else {\n                    providerForContract = provider;\n                }\n                const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                try {\n                    var _marketAddresses_;\n                    // Use new ABI methods: question, deadline, resolved, outcome\n                    const [question, deadline, resolved, outcome] = await Promise.all([\n                        marketContract.question(),\n                        marketContract.deadline(),\n                        marketContract.resolved(),\n                        marketContract.outcome()\n                    ]);\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    let currentPrice = 0n;\n                    let lockPrice = 0n;\n                    let totalYes = 0n;\n                    let totalNo = 0n;\n                    let feedId = \"0x0\";\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    // Try to get additional data if methods exist (for backward compatibility)\n                    // Wrap each call in a promise that catches errors\n                    const safeCall = async (fn, defaultValue)=>{\n                        try {\n                            return await fn();\n                        } catch (e) {\n                            return defaultValue;\n                        }\n                    };\n                    try {\n                        [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                            safeCall(()=>marketContract.getCurrentPrice(), 0n),\n                            safeCall(()=>marketContract.lockPrice(), 0n),\n                            safeCall(()=>marketContract.state(), 0),\n                            safeCall(()=>marketContract.totalYes(), 0n),\n                            safeCall(()=>marketContract.totalNo(), 0n),\n                            safeCall(()=>marketContract.feedId(), \"0x0\")\n                        ]);\n                    } catch (err) {\n                        // If methods don't exist, defaults are already set above\n                        console.warn(\"Some optional methods not available for market \".concat(address, \", using defaults\"));\n                    }\n                    // Map resolved/outcome to MarketState\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    } else {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes) if it's a bytes32\n                    let feedIdStr = \"\";\n                    let feedIdHex = \"0x0\";\n                    if (feedId && feedId !== \"0x0\") {\n                        try {\n                            feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                            feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        } catch (e) {\n                            feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                        }\n                    }\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    const creatorAddress = creatorMap.get(addressLower);\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                        lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                        state: state,\n                        totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                        totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                        // Use question from contract (new ABI)\n                        question: question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question),\n                        category: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress,\n                        // Include backend market_id for API calls (MarketInfo, MarketChat)\n                        marketId: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.market_id) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.id) || undefined\n                    };\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least basic data using new ABI if other calls fail\n                    let question = \"\";\n                    let deadline = 0;\n                    let resolved = false;\n                    let outcome = 0n;\n                    try {\n                        const basicContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, MARKET_ABI, providerForContract);\n                        [question, deadline, resolved, outcome] = await Promise.all([\n                            basicContract.question(),\n                            basicContract.deadline(),\n                            basicContract.resolved(),\n                            basicContract.outcome()\n                        ]);\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch basic data for market \".concat(address, \":\"), questionErr);\n                    }\n                    // Determine state from resolved/deadline\n                    let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n                    if (resolved) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n                    } else if (deadline > 0 && deadline <= Math.floor(Date.now() / 1000)) {\n                        state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: state,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // Filter out markets with empty addresses (failed fetches)\n            const validMarkets = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\");\n            console.log(\"[useMarkets] Valid markets after filtering: \".concat(validMarkets.length));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            // Use BrowserProvider and Contract directly with new ABI\n            let providerForContract;\n            if ( true && window.ethereum) {\n                providerForContract = new ethers__WEBPACK_IMPORTED_MODULE_6__.BrowserProvider(window.ethereum);\n            } else {\n                const baseProvider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_2__.getProvider)();\n                providerForContract = baseProvider;\n            }\n            const marketContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(marketAddress, MARKET_ABI, providerForContract);\n            // Use new ABI methods: question, deadline, resolved, outcome\n            const [question, deadline, resolved, outcome] = await Promise.all([\n                marketContract.question(),\n                marketContract.deadline(),\n                marketContract.resolved(),\n                marketContract.outcome()\n            ]);\n            // Try to get additional data if methods exist (for backward compatibility)\n            let currentPrice = 0n;\n            let lockPrice = 0n;\n            let totalYes = 0n;\n            let totalNo = 0n;\n            let feedId = \"0x0\";\n            let state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            try {\n                // Try old methods for backward compatibility (if they exist in ABI)\n                const promises = [];\n                try {\n                    promises.push(marketContract.getCurrentPrice());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.lockPrice());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.state());\n                } catch (e) {\n                    promises.push(Promise.resolve(0));\n                }\n                try {\n                    promises.push(marketContract.totalYes());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.totalNo());\n                } catch (e) {\n                    promises.push(Promise.resolve(0n));\n                }\n                try {\n                    promises.push(marketContract.feedId());\n                } catch (e) {\n                    promises.push(Promise.resolve(\"0x0\"));\n                }\n                [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all(promises);\n            } catch (err) {\n                // If old methods don't exist, use defaults\n                console.warn(\"Some optional methods not available for market \".concat(marketAddress, \", using defaults\"));\n            }\n            // Map resolved/outcome to MarketState\n            if (resolved) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Resolved;\n            } else if (Number(deadline) <= Math.floor(Date.now() / 1000)) {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Locked;\n            } else {\n                state = _lib_contracts__WEBPACK_IMPORTED_MODULE_2__.MarketState.Active;\n            }\n            // Convert feedId bytes32 to string if available\n            let feedIdStr = \"\";\n            let feedIdHex = \"0x0\";\n            if (feedId && feedId !== \"0x0\") {\n                try {\n                    feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_8__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                } catch (e) {\n                    feedIdHex = typeof feedId === \"string\" ? feedId : ethers__WEBPACK_IMPORTED_MODULE_9__.hexlify(feedId);\n                }\n            }\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdHex,\n                currentPrice: currentPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(currentPrice) : \"0\",\n                lockPrice: lockPrice > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(lockPrice) : \"0\",\n                state: state,\n                totalYes: totalYes > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalYes) : \"0\",\n                totalNo: totalNo > 0n ? ethers__WEBPACK_IMPORTED_MODULE_10__.formatEther(totalNo) : \"0\",\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0U7QUFDakM7QUFDK0I7QUFPL0I7QUFFMUIsTUFBTVksYUFBYUwsMkRBQWtCO0FBRXJDOztDQUVDLEdBQ0QsU0FBU08sdUJBQXVCQyxNQUFrQjtJQUNoRCxNQUFNQyxXQUFXQyxXQUFXRixPQUFPQyxRQUFRO0lBQzNDLE1BQU1FLFVBQVVELFdBQVdGLE9BQU9HLE9BQU87SUFDekMsTUFBTUMsaUJBQWlCSCxXQUFXRTtJQUVsQyxxQ0FBcUM7SUFDckMsSUFBSUUsUUFBUUQ7SUFFWiwyQkFBMkI7SUFDM0IsSUFBSUosT0FBT00sS0FBSyxLQUFLWCx1REFBV0EsQ0FBQ1ksTUFBTSxFQUFFO1FBQ3ZDRixTQUFTO0lBQ1g7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTUksVUFBVUMsS0FBS0MsR0FBRyxDQUFDVCxVQUFVRSxXQUFXTSxLQUFLRSxHQUFHLENBQUNWLFVBQVVFO1FBQ2pFRSxTQUFVLElBQUlHLFVBQVUsS0FBTSx1Q0FBdUM7SUFDdkU7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTTztJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHN0IsK0NBQVFBLENBQWUsRUFBRTtJQUN2RCxNQUFNLENBQUM4QixTQUFTQyxXQUFXLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWtDLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQixJQUFJO1lBQ0Y2QixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxNQUFNRSxXQUFXMUIsMkRBQVdBO1lBQzVCLE1BQU0yQixVQUFVNUIsa0VBQWtCQSxDQUFDMkI7WUFFbkMsd0NBQXdDO1lBQ3hDLE1BQU1FLGtCQUE0QixNQUFNRCxRQUFRRSxV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Z0JBQ3JFQyxXQUFXQSxZQUFZLEVBQUUsR0FBRzlGLGdEQUFrQixDQUFDOEYsYUFBYTtnQkFDNUQ1RSxPQUFPQTtnQkFDUEwsVUFBVUEsV0FBVyxFQUFFLEdBQUdiLGdEQUFrQixDQUFDYSxZQUFZO2dCQUN6REUsU0FBU0EsVUFBVSxFQUFFLEdBQUdmLGdEQUFrQixDQUFDZSxXQUFXO2dCQUN0RHdFLFVBQVVBO1lBQ1o7UUFDRixFQUFFLE9BQU96QixLQUFVO1lBQ2pCQyxRQUFRbEMsS0FBSyxDQUFDLDJCQUEyQmlDO1lBQ3pDaEMsU0FBU2dDLElBQUlxRSxPQUFPLElBQUk7UUFDMUIsU0FBVTtZQUNSdkcsV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPO1FBQUVoQjtRQUFRZTtRQUFTRTtRQUFPdUcsU0FBU0c7SUFBWTtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlTWFya2V0cy50cz9kM2MzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBldGhlcnMsIEJyb3dzZXJQcm92aWRlciwgQ29udHJhY3QgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgbWFya2V0QXJ0aWZhY3QgZnJvbSBcIkAvYWJpL1ByZWRpY3Rpb25NYXJrZXQuanNvblwiO1xuaW1wb3J0IHtcbiAgZ2V0RmFjdG9yeUNvbnRyYWN0LFxuICBnZXRQcm92aWRlcixcbiAgTWFya2V0RGF0YSxcbiAgTWFya2V0U3RhdGUsXG4gIEZBQ1RPUllfQUREUkVTUyxcbn0gZnJvbSBcIi4uL2xpYi9jb250cmFjdHNcIjtcblxuY29uc3QgTUFSS0VUX0FCSSA9IG1hcmtldEFydGlmYWN0LmFiaTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmUgYmFzZWQgb24gbGlxdWlkaXR5IGFuZCBhY3Rpdml0eVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldDogTWFya2V0RGF0YSk6IG51bWJlciB7XG4gIGNvbnN0IHRvdGFsWWVzID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxZZXMpO1xuICBjb25zdCB0b3RhbE5vID0gcGFyc2VGbG9hdChtYXJrZXQudG90YWxObyk7XG4gIGNvbnN0IHRvdGFsTGlxdWlkaXR5ID0gdG90YWxZZXMgKyB0b3RhbE5vO1xuICBcbiAgLy8gQmFzZSBzY29yZSBmcm9tIGxpcXVpZGl0eSAodm9sdW1lKVxuICBsZXQgc2NvcmUgPSB0b3RhbExpcXVpZGl0eTtcbiAgXG4gIC8vIEJvb3N0IGZvciBhY3RpdmUgbWFya2V0c1xuICBpZiAobWFya2V0LnN0YXRlID09PSBNYXJrZXRTdGF0ZS5BY3RpdmUpIHtcbiAgICBzY29yZSAqPSAxLjI7XG4gIH1cbiAgXG4gIC8vIEJvb3N0IGZvciBtYXJrZXRzIHdpdGggYmFsYW5jZWQgbGlxdWlkaXR5IChtb3JlIGludGVyZXN0aW5nKVxuICBpZiAodG90YWxMaXF1aWRpdHkgPiAwKSB7XG4gICAgY29uc3QgYmFsYW5jZSA9IE1hdGgubWluKHRvdGFsWWVzLCB0b3RhbE5vKSAvIE1hdGgubWF4KHRvdGFsWWVzLCB0b3RhbE5vKTtcbiAgICBzY29yZSAqPSAoMSArIGJhbGFuY2UgKiAwLjMpOyAvLyBVcCB0byAzMCUgYm9vc3QgZm9yIGJhbGFuY2VkIG1hcmtldHNcbiAgfVxuICBcbiAgcmV0dXJuIHNjb3JlO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYWxsIG1hcmtldHMgZnJvbSB0aGUgZmFjdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0cygpIHtcbiAgY29uc3QgW21hcmtldHMsIHNldE1hcmtldHNdID0gdXNlU3RhdGU8TWFya2V0RGF0YVtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGZldGNoTWFya2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICBjb25zdCBmYWN0b3J5ID0gZ2V0RmFjdG9yeUNvbnRyYWN0KHByb3ZpZGVyKTtcblxuICAgICAgLy8gR2V0IGFsbCBtYXJrZXQgYWRkcmVzc2VzIGZyb20gZmFjdG9yeVxuICAgICAgY29uc3QgbWFya2V0QWRkcmVzc2VzOiBzdHJpbmdbXSA9IGF3YWl0IGZhY3RvcnkuZ2V0TWFya2V0cygpO1xuICAgICAgXG4gICAgICAvLyBGZXRjaCBNYXJrZXRDcmVhdGVkIGV2ZW50cyB0byBnZXQgY3JlYXRpb24gdHJhbnNhY3Rpb24gaGFzaGVzIGFuZCBjcmVhdG9yIGFkZHJlc3Nlc1xuICAgICAgY29uc3QgY3JlYXRpb25UeE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICBjb25zdCBjcmVhdG9yTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFF1ZXJ5IE1hcmtldENyZWF0ZWQgZXZlbnRzIGZyb20gdGhlIGZhY3RvcnkgY29udHJhY3RcbiAgICAgICAgLy8gRXZlbnQgc2lnbmF0dXJlOiBNYXJrZXRDcmVhdGVkKGFkZHJlc3MgaW5kZXhlZCBtYXJrZXQsIGFkZHJlc3MgaW5kZXhlZCBjcmVhdG9yLCBhZGRyZXNzIGluZGV4ZWQgZmVlZEFkZHJlc3MpXG4gICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBldGhlcnMuaWQoXCJNYXJrZXRDcmVhdGVkKGFkZHJlc3MsYWRkcmVzcyxhZGRyZXNzKVwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgIGFkZHJlc3M6IEZBQ1RPUllfQUREUkVTUyxcbiAgICAgICAgICB0b3BpY3M6IFtldmVudFRvcGljXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgZXZlbnRzXG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGV2ZW50cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGV2ZW50IChtYXJrZXQgYWRkcmVzcyBpcyB0aGUgZmlyc3QgaW5kZXhlZCBwYXJhbWV0ZXIsIGNyZWF0b3IgaXMgc2Vjb25kKVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IGZhY3RvcnkuaW50ZXJmYWNlLnBhcnNlTG9nKHtcbiAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzLFxuICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWQgJiYgZGVjb2RlZC5hcmdzICYmIGRlY29kZWQuYXJncy5tYXJrZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya2V0QWRkcmVzcyA9IGRlY29kZWQuYXJncy5tYXJrZXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgY3JlYXRpb25UeE1hcC5zZXQobWFya2V0QWRkcmVzcywgbG9nLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgIC8vIEV4dHJhY3QgY3JlYXRvciBhZGRyZXNzIChzZWNvbmQgaW5kZXhlZCBwYXJhbWV0ZXIpXG4gICAgICAgICAgICAgIGlmIChkZWNvZGVkLmFyZ3MuY3JlYXRvcikge1xuICAgICAgICAgICAgICAgIGNyZWF0b3JNYXAuc2V0KG1hcmtldEFkZHJlc3MsIGRlY29kZWQuYXJncy5jcmVhdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyKSB7XG4gICAgICAgICAgICAvLyBUcnkgYWx0ZXJuYXRpdmUgcGFyc2luZyAtIG1hcmtldCBhZGRyZXNzIG1pZ2h0IGJlIGluIHRvcGljc1sxXSwgY3JlYXRvciBpbiB0b3BpY3NbMl1cbiAgICAgICAgICAgIGlmIChsb2cudG9waWNzICYmIGxvZy50b3BpY3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1sxXS5zbGljZSgyNikpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGNyZWF0b3JBZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoXCIweFwiICsgbG9nLnRvcGljc1syXS5zbGljZSgyNikpO1xuICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQobWFya2V0QWRkcmVzcywgY3JlYXRvckFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBNYXJrZXRDcmVhdGVkIGV2ZW50czpcIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHttYXJrZXRBZGRyZXNzZXMubGVuZ3RofSBtYXJrZXRzIGZyb20gZmFjdG9yeTpgLCBtYXJrZXRBZGRyZXNzZXMpO1xuXG4gICAgICAvLyBGZXRjaCBtZXRhZGF0YSBmcm9tIGJhY2tlbmQgQVBJXG4gICAgICBsZXQgYmFja2VuZE1hcmtldHM6IGFueVtdID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCI7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke2FwaVVybH0vYXBpL21hcmtldHNgKTtcbiAgICAgICAgYmFja2VuZE1hcmtldHMgPSByZXNwb25zZS5kYXRhIHx8IFtdO1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZU1hcmtldHNdIEZvdW5kICR7YmFja2VuZE1hcmtldHMubGVuZ3RofSBtYXJrZXRzIGluIGJhY2tlbmQgbWV0YWRhdGFgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0IG1ldGFkYXRhIGZyb20gYmFja2VuZDpcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGJhY2tlbmQgbWFya2V0cyBieSBtYXJrZXRfYWRkcmVzcyAocHJpbWFyeSkgYW5kIGZlZWRJZCAoZmFsbGJhY2spIGZvciBxdWljayBsb29rdXBcbiAgICAgIGNvbnN0IGJhY2tlbmRNYXBCeUFkZHJlc3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5RmVlZElkID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgIGJhY2tlbmRNYXJrZXRzLmZvckVhY2goKG06IGFueSkgPT4ge1xuICAgICAgICAvLyBQcmltYXJ5OiBtYXRjaCBieSBtYXJrZXRfYWRkcmVzcyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKG0ubWFya2V0X2FkZHJlc3MpIHtcbiAgICAgICAgICBjb25zdCBhZGRyTG93ZXIgPSBtLm1hcmtldF9hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYmFja2VuZE1hcEJ5QWRkcmVzcy5zZXQoYWRkckxvd2VyLCBtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjazogbWF0Y2ggYnkgZmVlZElkIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5mZWVkX2lkKSB7XG4gICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBtLmZlZWRfaWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuc2V0KGZlZWRJZExvd2VyLCBtKTtcbiAgICAgICAgICAvLyBBbHNvIHRyeSB3aXRob3V0IDB4IHByZWZpeCBpZiBwcmVzZW50XG4gICAgICAgICAgaWYgKGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIuc2xpY2UoMiksIG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZldGNoIGRhdGEgZm9yIGVhY2ggbWFya2V0IHVzaW5nIG5ldyBBQklcbiAgICAgIGNvbnN0IG1hcmtldFByb21pc2VzID0gbWFya2V0QWRkcmVzc2VzLm1hcChhc3luYyAoYWRkcmVzcykgPT4ge1xuICAgICAgICAvLyBVc2UgQnJvd3NlclByb3ZpZGVyIGFuZCBDb250cmFjdCBkaXJlY3RseSB3aXRoIG5ldyBBQklcbiAgICAgICAgbGV0IHByb3ZpZGVyRm9yQ29udHJhY3Q6IEJyb3dzZXJQcm92aWRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IG5ldyBCcm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm92aWRlckZvckNvbnRyYWN0ID0gcHJvdmlkZXIgYXMgYW55IGFzIEJyb3dzZXJQcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXJrZXRDb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFVzZSBuZXcgQUJJIG1ldGhvZHM6IHF1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVcbiAgICAgICAgICBjb25zdCBbcXVlc3Rpb24sIGRlYWRsaW5lLCByZXNvbHZlZCwgb3V0Y29tZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICAgICAgbWFya2V0Q29udHJhY3QuZGVhZGxpbmUoKSxcbiAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LnJlc29sdmVkKCksXG4gICAgICAgICAgICBtYXJrZXRDb250cmFjdC5vdXRjb21lKCksIC8vIGVudW06IDAsMSwyXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGFkZGl0aW9uYWwgZGF0YSBpZiBtZXRob2RzIGV4aXN0IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgICAgICBsZXQgY3VycmVudFByaWNlID0gMG47XG4gICAgICAgICAgbGV0IGxvY2tQcmljZSA9IDBuO1xuICAgICAgICAgIGxldCB0b3RhbFllcyA9IDBuO1xuICAgICAgICAgIGxldCB0b3RhbE5vID0gMG47XG4gICAgICAgICAgbGV0IGZlZWRJZCA9IFwiMHgwXCI7XG4gICAgICAgICAgbGV0IHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBhZGRpdGlvbmFsIGRhdGEgaWYgbWV0aG9kcyBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICAgICAgLy8gV3JhcCBlYWNoIGNhbGwgaW4gYSBwcm9taXNlIHRoYXQgY2F0Y2hlcyBlcnJvcnNcbiAgICAgICAgICBjb25zdCBzYWZlQ2FsbCA9IGFzeW5jIChmbjogKCkgPT4gUHJvbWlzZTxhbnk+LCBkZWZhdWx0VmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFtjdXJyZW50UHJpY2UsIGxvY2tQcmljZSwgc3RhdGUsIHRvdGFsWWVzLCB0b3RhbE5vLCBmZWVkSWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5nZXRDdXJyZW50UHJpY2UoKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC5zdGF0ZSgpLCAwKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QudG90YWxZZXMoKSwgMG4pLFxuICAgICAgICAgICAgICBzYWZlQ2FsbCgoKSA9PiBtYXJrZXRDb250cmFjdC50b3RhbE5vKCksIDBuKSxcbiAgICAgICAgICAgICAgc2FmZUNhbGwoKCkgPT4gbWFya2V0Q29udHJhY3QuZmVlZElkKCksIFwiMHgwXCIpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiBtZXRob2RzIGRvbid0IGV4aXN0LCBkZWZhdWx0cyBhcmUgYWxyZWFkeSBzZXQgYWJvdmVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU29tZSBvcHRpb25hbCBtZXRob2RzIG5vdCBhdmFpbGFibGUgZm9yIG1hcmtldCAke2FkZHJlc3N9LCB1c2luZyBkZWZhdWx0c2ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hcCByZXNvbHZlZC9vdXRjb21lIHRvIE1hcmtldFN0YXRlXG4gICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLlJlc29sdmVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyKGRlYWRsaW5lKSA8PSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5Mb2NrZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuQWN0aXZlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnZlcnQgZmVlZElkIGJ5dGVzMzIgdG8gc3RyaW5nIChyZW1vdmUgbnVsbCBieXRlcykgaWYgaXQncyBhIGJ5dGVzMzJcbiAgICAgICAgICBsZXQgZmVlZElkU3RyID0gXCJcIjtcbiAgICAgICAgICBsZXQgZmVlZElkSGV4ID0gXCIweDBcIjtcbiAgICAgICAgICBpZiAoZmVlZElkICYmIGZlZWRJZCAhPT0gXCIweDBcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmVlZElkU3RyID0gZXRoZXJzLnRvVXRmOFN0cmluZyhmZWVkSWQpLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgZmVlZElkSGV4ID0gZmVlZElkU3RyIHx8IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgZmVlZElkSGV4ID0gdHlwZW9mIGZlZWRJZCA9PT0gXCJzdHJpbmdcIiA/IGZlZWRJZCA6IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIG1hdGNoaW5nIGJhY2tlbmQgbWV0YWRhdGFcbiAgICAgICAgICAvLyBQcmltYXJ5OiBtYXRjaCBieSBtYXJrZXQgYWRkcmVzcyAobW9zdCByZWxpYWJsZSlcbiAgICAgICAgICBjb25zdCBhZGRyZXNzTG93ZXIgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbGV0IGJhY2tlbmRNYXJrZXQgPSBiYWNrZW5kTWFwQnlBZGRyZXNzLmdldChhZGRyZXNzTG93ZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZhbGxiYWNrOiBtYXRjaCBieSBmZWVkSWQgaWYgYWRkcmVzcyBtYXRjaCBmYWlsZWRcbiAgICAgICAgICBpZiAoIWJhY2tlbmRNYXJrZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRJZExvd2VyID0gZmVlZElkSGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBmZWVkSWROb1ByZWZpeCA9IGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykgPyBmZWVkSWRMb3dlci5zbGljZSgyKSA6IGZlZWRJZExvd2VyO1xuICAgICAgICAgICAgYmFja2VuZE1hcmtldCA9IGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkTG93ZXIpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWROb1ByZWZpeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkU3RyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNyZWF0aW9uVHhIYXNoID0gY3JlYXRpb25UeE1hcC5nZXQoYWRkcmVzc0xvd2VyKTtcbiAgICAgICAgICBjb25zdCBjcmVhdG9yQWRkcmVzcyA9IGNyZWF0b3JNYXAuZ2V0KGFkZHJlc3NMb3dlcik7XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IGltYWdlVXJsIGZyb20gYmFja2VuZCBtYXJrZXQgKHN1cHBvcnQgYm90aCBzbmFrZV9jYXNlIGFuZCBjYW1lbENhc2UpXG4gICAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSBiYWNrZW5kTWFya2V0Py5pbWFnZV91cmwgfHwgYmFja2VuZE1hcmtldD8uaW1hZ2VVcmwgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoaW1hZ2VVcmwgJiYgYWRkcmVzc0xvd2VyID09PSBtYXJrZXRBZGRyZXNzZXNbMF0/LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gaGFzIGltYWdlVXJsOmAsIGltYWdlVXJsLnN1YnN0cmluZygwLCAxMDApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBtYXJrZXREYXRhOiBNYXJrZXREYXRhID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZWRJZDogZmVlZElkSGV4LFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBjdXJyZW50UHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihjdXJyZW50UHJpY2UpIDogXCIwXCIsXG4gICAgICAgICAgICBsb2NrUHJpY2U6IGxvY2tQcmljZSA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKGxvY2tQcmljZSkgOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSBhcyBNYXJrZXRTdGF0ZSxcbiAgICAgICAgICAgIHRvdGFsWWVzOiB0b3RhbFllcyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSA6IFwiMFwiLFxuICAgICAgICAgICAgdG90YWxObzogdG90YWxObyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsTm8pIDogXCIwXCIsXG4gICAgICAgICAgICAvLyBVc2UgcXVlc3Rpb24gZnJvbSBjb250cmFjdCAobmV3IEFCSSlcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbiB8fCBiYWNrZW5kTWFya2V0Py5xdWVzdGlvbixcbiAgICAgICAgICAgIGNhdGVnb3J5OiBiYWNrZW5kTWFya2V0Py5jYXRlZ29yeSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBiYWNrZW5kTWFya2V0Py5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCwgLy8gU2V0IGltYWdlVXJsIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGNyZWF0aW9uVHhIYXNoOiBjcmVhdGlvblR4SGFzaCxcbiAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzOiBjcmVhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgYmFja2VuZCBtYXJrZXRfaWQgZm9yIEFQSSBjYWxscyAoTWFya2V0SW5mbywgTWFya2V0Q2hhdClcbiAgICAgICAgICAgIG1hcmtldElkOiBiYWNrZW5kTWFya2V0Py5tYXJrZXRfaWQgfHwgYmFja2VuZE1hcmtldD8uaWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gbWFya2V0RGF0YTtcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBtYXJrZXQgJHthZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgICAgIC8vIFRyeSB0byBnZXQgYXQgbGVhc3QgYmFzaWMgZGF0YSB1c2luZyBuZXcgQUJJIGlmIG90aGVyIGNhbGxzIGZhaWxcbiAgICAgICAgICBsZXQgcXVlc3Rpb24gPSBcIlwiO1xuICAgICAgICAgIGxldCBkZWFkbGluZSA9IDA7XG4gICAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IG91dGNvbWUgPSAwbjtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFzaWNDb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBNQVJLRVRfQUJJLCBwcm92aWRlckZvckNvbnRyYWN0KTtcbiAgICAgICAgICAgIFtxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5xdWVzdGlvbigpLFxuICAgICAgICAgICAgICBiYXNpY0NvbnRyYWN0LmRlYWRsaW5lKCksXG4gICAgICAgICAgICAgIGJhc2ljQ29udHJhY3QucmVzb2x2ZWQoKSxcbiAgICAgICAgICAgICAgYmFzaWNDb250cmFjdC5vdXRjb21lKCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGNhdGNoIChxdWVzdGlvbkVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmV0Y2ggYmFzaWMgZGF0YSBmb3IgbWFya2V0ICR7YWRkcmVzc306YCwgcXVlc3Rpb25FcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgc3RhdGUgZnJvbSByZXNvbHZlZC9kZWFkbGluZVxuICAgICAgICAgIGxldCBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWFkbGluZSA+IDAgJiYgZGVhZGxpbmUgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuTG9ja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXR1cm4gbWluaW1hbCBkYXRhIGlmIGNvbnRyYWN0IGNhbGwgZmFpbHMsIGJ1dCBzdGlsbCBpbmNsdWRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIG1hcmtldHMgYXJlIHNob3duIGV2ZW4gaWYgc29tZSBjYWxscyBmYWlsXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IFwiXCIsXG4gICAgICAgICAgICBjdXJyZW50UHJpY2U6IFwiMFwiLFxuICAgICAgICAgICAgbG9ja1ByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIHRvdGFsWWVzOiBcIjBcIixcbiAgICAgICAgICAgIHRvdGFsTm86IFwiMFwiLFxuICAgICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uIHx8IGBNYXJrZXQgJHthZGRyZXNzLnNsaWNlKDAsIDgpfS4uLiR7YWRkcmVzcy5zbGljZSgtNil9YCxcbiAgICAgICAgICB9IGFzIE1hcmtldERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtYXJrZXREYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwobWFya2V0UHJvbWlzZXMpO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCBkYXRhIGZvciAke21hcmtldERhdGEubGVuZ3RofSBtYXJrZXRzYCk7XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciBvdXQgbWFya2V0cyB3aXRoIGVtcHR5IGFkZHJlc3NlcyAoZmFpbGVkIGZldGNoZXMpXG4gICAgICBjb25zdCB2YWxpZE1hcmtldHMgPSBtYXJrZXREYXRhLmZpbHRlcihtID0+IG0uYWRkcmVzcyAmJiBtLmFkZHJlc3MgIT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBWYWxpZCBtYXJrZXRzIGFmdGVyIGZpbHRlcmluZzogJHt2YWxpZE1hcmtldHMubGVuZ3RofWApO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdHJlbmRpbmcgc2NvcmVzIGFuZCBhZGQgdG8gbWFya2V0IGRhdGFcbiAgICAgIGNvbnN0IG1hcmtldHNXaXRoVHJlbmRpbmcgPSB2YWxpZE1hcmtldHMubWFwKG1hcmtldCA9PiAoe1xuICAgICAgICAuLi5tYXJrZXQsXG4gICAgICAgIHRyZW5kaW5nU2NvcmU6IGNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUobWFya2V0KSxcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGaW5hbCBtYXJrZXRzIHRvIGRpc3BsYXk6YCwgbWFya2V0c1dpdGhUcmVuZGluZy5tYXAobSA9PiAoeyBcbiAgICAgICAgYWRkcmVzczogbS5hZGRyZXNzLCBcbiAgICAgICAgcXVlc3Rpb246IG0ucXVlc3Rpb24gfHwgJ05vIHF1ZXN0aW9uJywgXG4gICAgICAgIGhhc0ltYWdlOiAhIW0uaW1hZ2VVcmwsXG4gICAgICAgIGltYWdlVXJsOiBtLmltYWdlVXJsID8gYCR7bS5pbWFnZVVybC5zdWJzdHJpbmcoMCwgNTApfS4uLmAgOiAnbm9uZSdcbiAgICAgIH0pKSk7XG4gICAgICBcbiAgICAgIHNldE1hcmtldHMobWFya2V0c1dpdGhUcmVuZGluZyk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0czpcIiwgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldHNcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hNYXJrZXRzKCk7XG4gIH0sIFtmZXRjaE1hcmtldHNdKTtcblxuICByZXR1cm4geyBtYXJrZXRzLCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXRzIH07XG59XG5cbi8qKlxuICogSG9vayB0byBmZXRjaCBhIHNpbmdsZSBtYXJrZXQncyBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXJrZXQobWFya2V0QWRkcmVzczogc3RyaW5nIHwgbnVsbCkge1xuICBjb25zdCBbbWFya2V0LCBzZXRNYXJrZXRdID0gdXNlU3RhdGU8TWFya2V0RGF0YSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2V0QWRkcmVzcykge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoTWFya2V0KCk7XG4gIH0sIFttYXJrZXRBZGRyZXNzXSk7XG5cbiAgY29uc3QgZmV0Y2hNYXJrZXQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAvLyBVc2UgQnJvd3NlclByb3ZpZGVyIGFuZCBDb250cmFjdCBkaXJlY3RseSB3aXRoIG5ldyBBQklcbiAgICAgIGxldCBwcm92aWRlckZvckNvbnRyYWN0OiBCcm93c2VyUHJvdmlkZXI7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgICAgcHJvdmlkZXJGb3JDb250cmFjdCA9IG5ldyBCcm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJhc2VQcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgIHByb3ZpZGVyRm9yQ29udHJhY3QgPSBiYXNlUHJvdmlkZXIgYXMgYW55IGFzIEJyb3dzZXJQcm92aWRlcjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbWFya2V0Q29udHJhY3QgPSBuZXcgQ29udHJhY3QobWFya2V0QWRkcmVzcywgTUFSS0VUX0FCSSwgcHJvdmlkZXJGb3JDb250cmFjdCk7XG5cbiAgICAgIC8vIFVzZSBuZXcgQUJJIG1ldGhvZHM6IHF1ZXN0aW9uLCBkZWFkbGluZSwgcmVzb2x2ZWQsIG91dGNvbWVcbiAgICAgIGNvbnN0IFtxdWVzdGlvbiwgZGVhZGxpbmUsIHJlc29sdmVkLCBvdXRjb21lXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgbWFya2V0Q29udHJhY3QucXVlc3Rpb24oKSxcbiAgICAgICAgbWFya2V0Q29udHJhY3QuZGVhZGxpbmUoKSxcbiAgICAgICAgbWFya2V0Q29udHJhY3QucmVzb2x2ZWQoKSxcbiAgICAgICAgbWFya2V0Q29udHJhY3Qub3V0Y29tZSgpLCAvLyBlbnVtOiAwLDEsMlxuICAgICAgXSk7XG5cbiAgICAgIC8vIFRyeSB0byBnZXQgYWRkaXRpb25hbCBkYXRhIGlmIG1ldGhvZHMgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgbGV0IGN1cnJlbnRQcmljZSA9IDBuO1xuICAgICAgbGV0IGxvY2tQcmljZSA9IDBuO1xuICAgICAgbGV0IHRvdGFsWWVzID0gMG47XG4gICAgICBsZXQgdG90YWxObyA9IDBuO1xuICAgICAgbGV0IGZlZWRJZCA9IFwiMHgwXCI7XG4gICAgICBsZXQgc3RhdGUgPSBNYXJrZXRTdGF0ZS5BY3RpdmU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSBvbGQgbWV0aG9kcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAoaWYgdGhleSBleGlzdCBpbiBBQkkpXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC5nZXRDdXJyZW50UHJpY2UoKSk7XG4gICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSgwbikpOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSk7XG4gICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSgwbikpOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC5zdGF0ZSgpKTtcbiAgICAgICAgfSBjYXRjaCB7IHByb21pc2VzLnB1c2goUHJvbWlzZS5yZXNvbHZlKDApKTsgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gobWFya2V0Q29udHJhY3QudG90YWxZZXMoKSk7XG4gICAgICAgIH0gY2F0Y2ggeyBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSgwbikpOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChtYXJrZXRDb250cmFjdC50b3RhbE5vKCkpO1xuICAgICAgICB9IGNhdGNoIHsgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUoMG4pKTsgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gobWFya2V0Q29udHJhY3QuZmVlZElkKCkpO1xuICAgICAgICB9IGNhdGNoIHsgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUoXCIweDBcIikpOyB9XG4gICAgICAgIFxuICAgICAgICBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiBvbGQgbWV0aG9kcyBkb24ndCBleGlzdCwgdXNlIGRlZmF1bHRzXG4gICAgICAgIGNvbnNvbGUud2FybihgU29tZSBvcHRpb25hbCBtZXRob2RzIG5vdCBhdmFpbGFibGUgZm9yIG1hcmtldCAke21hcmtldEFkZHJlc3N9LCB1c2luZyBkZWZhdWx0c2ApO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXAgcmVzb2x2ZWQvb3V0Y29tZSB0byBNYXJrZXRTdGF0ZVxuICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHN0YXRlID0gTWFya2V0U3RhdGUuUmVzb2x2ZWQ7XG4gICAgICB9IGVsc2UgaWYgKE51bWJlcihkZWFkbGluZSkgPD0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgc3RhdGUgPSBNYXJrZXRTdGF0ZS5Mb2NrZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IE1hcmtldFN0YXRlLkFjdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgaWYgYXZhaWxhYmxlXG4gICAgICBsZXQgZmVlZElkU3RyID0gXCJcIjtcbiAgICAgIGxldCBmZWVkSWRIZXggPSBcIjB4MFwiO1xuICAgICAgaWYgKGZlZWRJZCAmJiBmZWVkSWQgIT09IFwiMHgwXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuICAgICAgICAgIGZlZWRJZEhleCA9IGZlZWRJZFN0ciB8fCBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBmZWVkSWRIZXggPSB0eXBlb2YgZmVlZElkID09PSBcInN0cmluZ1wiID8gZmVlZElkIDogZXRoZXJzLmhleGxpZnkoZmVlZElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRNYXJrZXQoe1xuICAgICAgICBhZGRyZXNzOiBtYXJrZXRBZGRyZXNzLFxuICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgY3VycmVudFByaWNlOiBjdXJyZW50UHJpY2UgPiAwbiA/IGV0aGVycy5mb3JtYXRFdGhlcihjdXJyZW50UHJpY2UpIDogXCIwXCIsXG4gICAgICAgIGxvY2tQcmljZTogbG9ja1ByaWNlID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIobG9ja1ByaWNlKSA6IFwiMFwiLFxuICAgICAgICBzdGF0ZTogc3RhdGUgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgIHRvdGFsWWVzOiB0b3RhbFllcyA+IDBuID8gZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSA6IFwiMFwiLFxuICAgICAgICB0b3RhbE5vOiB0b3RhbE5vID4gMG4gPyBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxObykgOiBcIjBcIixcbiAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0OlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0XCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgbWFya2V0LCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXQgfTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJldGhlcnMiLCJCcm93c2VyUHJvdmlkZXIiLCJDb250cmFjdCIsImF4aW9zIiwibWFya2V0QXJ0aWZhY3QiLCJnZXRGYWN0b3J5Q29udHJhY3QiLCJnZXRQcm92aWRlciIsIk1hcmtldFN0YXRlIiwiRkFDVE9SWV9BRERSRVNTIiwiTUFSS0VUX0FCSSIsImFiaSIsImNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUiLCJtYXJrZXQiLCJ0b3RhbFllcyIsInBhcnNlRmxvYXQiLCJ0b3RhbE5vIiwidG90YWxMaXF1aWRpdHkiLCJzY29yZSIsInN0YXRlIiwiQWN0aXZlIiwiYmFsYW5jZSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1c2VNYXJrZXRzIiwibWFya2V0cyIsInNldE1hcmtldHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJmZXRjaE1hcmtldHMiLCJwcm92aWRlciIsImZhY3RvcnkiLCJtYXJrZXRBZGRyZXNzZXMiLCJnZXRNYXJrZXRzIiwiY3JlYXRpb25UeE1hcCIsIk1hcCIsImNyZWF0b3JNYXAiLCJldmVudFRvcGljIiwiaWQiLCJmaWx0ZXIiLCJhZGRyZXNzIiwidG9waWNzIiwiZXZlbnRzIiwiZ2V0TG9ncyIsImxvZyIsImRlY29kZWQiLCJpbnRlcmZhY2UiLCJwYXJzZUxvZyIsImRhdGEiLCJhcmdzIiwibWFya2V0QWRkcmVzcyIsInRvTG93ZXJDYXNlIiwic2V0IiwidHJhbnNhY3Rpb25IYXNoIiwiY3JlYXRvciIsInBhcnNlRXJyIiwibGVuZ3RoIiwiZ2V0QWRkcmVzcyIsInNsaWNlIiwiY3JlYXRvckFkZHJlc3MiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsImJhY2tlbmRNYXJrZXRzIiwiYXBpVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsImdldCIsImJhY2tlbmRNYXBCeUFkZHJlc3MiLCJiYWNrZW5kTWFwQnlGZWVkSWQiLCJmb3JFYWNoIiwibSIsIm1hcmtldF9hZGRyZXNzIiwiYWRkckxvd2VyIiwiZmVlZF9pZCIsImZlZWRJZExvd2VyIiwic3RhcnRzV2l0aCIsIm1hcmtldFByb21pc2VzIiwibWFwIiwicHJvdmlkZXJGb3JDb250cmFjdCIsIndpbmRvdyIsImV0aGVyZXVtIiwibWFya2V0Q29udHJhY3QiLCJxdWVzdGlvbiIsImRlYWRsaW5lIiwicmVzb2x2ZWQiLCJvdXRjb21lIiwiUHJvbWlzZSIsImFsbCIsImN1cnJlbnRQcmljZSIsImxvY2tQcmljZSIsImZlZWRJZCIsInNhZmVDYWxsIiwiZm4iLCJkZWZhdWx0VmFsdWUiLCJnZXRDdXJyZW50UHJpY2UiLCJSZXNvbHZlZCIsIk51bWJlciIsImZsb29yIiwiRGF0ZSIsIm5vdyIsIkxvY2tlZCIsImZlZWRJZFN0ciIsImZlZWRJZEhleCIsInRvVXRmOFN0cmluZyIsInJlcGxhY2UiLCJoZXhsaWZ5IiwiYWRkcmVzc0xvd2VyIiwiYmFja2VuZE1hcmtldCIsImZlZWRJZE5vUHJlZml4IiwiY3JlYXRpb25UeEhhc2giLCJpbWFnZVVybCIsImltYWdlX3VybCIsInN1YnN0cmluZyIsIm1hcmtldERhdGEiLCJmb3JtYXRFdGhlciIsImNhdGVnb3J5IiwiZGVzY3JpcHRpb24iLCJtYXJrZXRJZCIsIm1hcmtldF9pZCIsInVuZGVmaW5lZCIsImJhc2ljQ29udHJhY3QiLCJxdWVzdGlvbkVyciIsInZhbGlkTWFya2V0cyIsIm1hcmtldHNXaXRoVHJlbmRpbmciLCJ0cmVuZGluZ1Njb3JlIiwiaGFzSW1hZ2UiLCJtZXNzYWdlIiwicmVmZXRjaCIsInVzZU1hcmtldCIsInNldE1hcmtldCIsImZldGNoTWFya2V0IiwiYmFzZVByb3ZpZGVyIiwicHJvbWlzZXMiLCJwdXNoIiwicmVzb2x2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});