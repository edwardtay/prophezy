"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_1__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getFactoryContract)(provider);\n            // Get all market addresses from factory\n            const marketAddresses = await factory.getMarkets();\n            // Fetch MarketCreated events to get creation transaction hashes and creator addresses\n            const creationTxMap = new Map();\n            const creatorMap = new Map();\n            try {\n                // Query MarketCreated events from the factory contract\n                // Event signature: MarketCreated(address indexed market, address indexed creator, address indexed feedAddress)\n                const eventTopic = ethers__WEBPACK_IMPORTED_MODULE_2__.id(\"MarketCreated(address,address,address)\");\n                const filter = {\n                    address: _lib_contracts__WEBPACK_IMPORTED_MODULE_1__.FACTORY_ADDRESS,\n                    topics: [\n                        eventTopic\n                    ]\n                };\n                const events = await provider.getLogs(filter);\n                // Parse events\n                for (const log of events){\n                    try {\n                        // Decode the event (market address is the first indexed parameter, creator is second)\n                        const decoded = factory.interface.parseLog({\n                            topics: log.topics,\n                            data: log.data\n                        });\n                        if (decoded && decoded.args && decoded.args.market) {\n                            const marketAddress = decoded.args.market.toLowerCase();\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            // Extract creator address (second indexed parameter)\n                            if (decoded.args.creator) {\n                                creatorMap.set(marketAddress, decoded.args.creator);\n                            }\n                        }\n                    } catch (parseErr) {\n                        // Try alternative parsing - market address might be in topics[1], creator in topics[2]\n                        if (log.topics && log.topics.length > 2) {\n                            const marketAddress = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(\"0x\" + log.topics[1].slice(26)).toLowerCase();\n                            const creatorAddress = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(\"0x\" + log.topics[2].slice(26));\n                            creationTxMap.set(marketAddress, log.transactionHash);\n                            creatorMap.set(marketAddress, creatorAddress);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.warn(\"Failed to fetch MarketCreated events:\", err);\n            }\n            console.log(\"[useMarkets] Found \".concat(marketAddresses.length, \" markets from factory:\"), marketAddresses);\n            // Fetch metadata from backend API\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n                console.log(\"[useMarkets] Found \".concat(backendMarkets.length, \" markets in backend metadata\"));\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market\n            const marketPromises = marketAddresses.map(async (address)=>{\n                const marketContract = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getMarketContract)(address, provider);\n                try {\n                    var _marketAddresses_;\n                    const [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                        marketContract.getCurrentPrice(),\n                        marketContract.lockPrice(),\n                        marketContract.state(),\n                        marketContract.totalYes(),\n                        marketContract.totalNo(),\n                        marketContract.feedId()\n                    ]);\n                    // Fetch question from contract separately (with error handling)\n                    let question = \"\";\n                    try {\n                        question = await marketContract.question();\n                    } catch (err) {\n                        console.warn(\"Failed to fetch question for market \".concat(address, \":\"), err);\n                    }\n                    // Convert feedId bytes32 to string (remove null bytes)\n                    const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_5__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    const feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_6__.hexlify(feedId);\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const creationTxHash = creationTxMap.get(addressLower);\n                    const creatorAddress = creatorMap.get(addressLower);\n                    // Extract imageUrl from backend market (support both snake_case and camelCase)\n                    const imageUrl = (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl) || null;\n                    if (imageUrl && addressLower === ((_marketAddresses_ = marketAddresses[0]) === null || _marketAddresses_ === void 0 ? void 0 : _marketAddresses_.toLowerCase())) {\n                        console.log(\"[useMarkets] Market \".concat(address, \" has imageUrl:\"), imageUrl.substring(0, 100));\n                    }\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(currentPrice),\n                        lockPrice: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(lockPrice),\n                        state: Number(state),\n                        totalYes: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(totalYes),\n                        totalNo: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(totalNo),\n                        // Use question from contract first, fallback to backend metadata\n                        question: question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question),\n                        category: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: imageUrl,\n                        creationTxHash: creationTxHash,\n                        creatorAddress: creatorAddress\n                    };\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Try to get at least the question from contract if other calls fail\n                    let question = \"\";\n                    try {\n                        question = await marketContract.question();\n                    } catch (questionErr) {\n                        console.warn(\"Could not fetch question for market \".concat(address));\n                    }\n                    // Return minimal data if contract call fails, but still include the address\n                    // This ensures markets are shown even if some calls fail\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: _lib_contracts__WEBPACK_IMPORTED_MODULE_1__.MarketState.Active,\n                        totalYes: \"0\",\n                        totalNo: \"0\",\n                        question: question || \"Market \".concat(address.slice(0, 8), \"...\").concat(address.slice(-6))\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            console.log(\"[useMarkets] Successfully fetched data for \".concat(marketData.length, \" markets\"));\n            // Filter out markets with empty addresses (failed fetches)\n            const validMarkets = marketData.filter((m)=>m.address && m.address !== \"0x0000000000000000000000000000000000000000\");\n            console.log(\"[useMarkets] Valid markets after filtering: \".concat(validMarkets.length));\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = validMarkets.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            console.log(\"[useMarkets] Final markets to display:\", marketsWithTrending.map((m)=>({\n                    address: m.address,\n                    question: m.question || \"No question\",\n                    hasImage: !!m.imageUrl,\n                    imageUrl: m.imageUrl ? \"\".concat(m.imageUrl.substring(0, 50), \"...\") : \"none\"\n                })));\n            setMarkets(marketsWithTrending);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n            const marketContract = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getMarketContract)(marketAddress, provider);\n            const [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                marketContract.getCurrentPrice(),\n                marketContract.lockPrice(),\n                marketContract.state(),\n                marketContract.totalYes(),\n                marketContract.totalNo(),\n                marketContract.feedId()\n            ]);\n            // Fetch question from contract\n            let question = \"\";\n            try {\n                question = await marketContract.question();\n            } catch (err) {\n                console.warn(\"Failed to fetch question for market \".concat(marketAddress, \":\"), err);\n            }\n            const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_5__.toUtf8String(feedId).replace(/\\0/g, \"\");\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_6__.hexlify(feedId),\n                currentPrice: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(currentPrice),\n                lockPrice: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(lockPrice),\n                state: Number(state),\n                totalYes: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(totalYes),\n                totalNo: ethers__WEBPACK_IMPORTED_MODULE_7__.formatEther(totalNo),\n                question: question\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ3pCO0FBQ047QUFRQTtBQUUxQjs7Q0FFQyxHQUNELFNBQVNVLHVCQUF1QkMsTUFBa0I7SUFDaEQsTUFBTUMsV0FBV0MsV0FBV0YsT0FBT0MsUUFBUTtJQUMzQyxNQUFNRSxVQUFVRCxXQUFXRixPQUFPRyxPQUFPO0lBQ3pDLE1BQU1DLGlCQUFpQkgsV0FBV0U7SUFFbEMscUNBQXFDO0lBQ3JDLElBQUlFLFFBQVFEO0lBRVosMkJBQTJCO0lBQzNCLElBQUlKLE9BQU9NLEtBQUssS0FBS1QsdURBQVdBLENBQUNVLE1BQU0sRUFBRTtRQUN2Q0YsU0FBUztJQUNYO0lBRUEsK0RBQStEO0lBQy9ELElBQUlELGlCQUFpQixHQUFHO1FBQ3RCLE1BQU1JLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQ1QsVUFBVUUsV0FBV00sS0FBS0UsR0FBRyxDQUFDVixVQUFVRTtRQUNqRUUsU0FBVSxJQUFJRyxVQUFVLEtBQU0sdUNBQXVDO0lBQ3ZFO0lBRUEsT0FBT0g7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU087SUFDZCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR3pCLCtDQUFRQSxDQUFlLEVBQUU7SUFDdkQsTUFBTSxDQUFDMEIsU0FBU0MsV0FBVyxHQUFHM0IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDNEIsT0FBT0MsU0FBUyxHQUFHN0IsK0NBQVFBLENBQWdCO0lBRWxELE1BQU04QixlQUFlNUIsa0RBQVdBLENBQUM7UUFDL0IsSUFBSTtZQUNGeUIsV0FBVztZQUNYRSxTQUFTO1lBRVQsTUFBTUUsV0FBV3hCLDJEQUFXQTtZQUM1QixNQUFNeUIsVUFBVTNCLGtFQUFrQkEsQ0FBQzBCO1lBRW5DLHdDQUF3QztZQUN4QyxNQUFNRSxrQkFBNEIsTUFBTUQsUUFBUUUsVUFBVTtZQUUxRCxzRkFBc0Y7WUFDdEYsTUFBTUMsZ0JBQWdC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dUUsT0FBTyxHQUMvRCxNQUFNQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ2hCTCxlQUFlTSxlQUFlO2dCQUM5Qk4sZUFBZUUsU0FBUztnQkFDeEJGLGVBQWVqRSxLQUFLO2dCQUNwQmlFLGVBQWV0RSxRQUFRO2dCQUN2QnNFLGVBQWVwRSxPQUFPO2dCQUN0Qm9FLGVBQWVHLE1BQU07YUFDdEI7WUFFSCwrQkFBK0I7WUFDL0IsSUFBSUksV0FBVztZQUNmLElBQUk7Z0JBQ0ZBLFdBQVcsTUFBTVAsZUFBZU8sUUFBUTtZQUMxQyxFQUFFLE9BQU81QixLQUFLO2dCQUNaQyxRQUFRQyxJQUFJLENBQUMsdUNBQXFELE9BQWRaLGVBQWMsTUFBSVU7WUFDeEU7WUFFQSxNQUFNNkIsWUFBWXZGLGdEQUFtQixDQUFDa0YsUUFBUU8sT0FBTyxDQUFDLE9BQU87WUFFN0R1QixVQUFVO2dCQUNSMUUsU0FBU1U7Z0JBQ1RrQyxRQUFRSyxhQUFhdkYsMkNBQWMsQ0FBQ2tGO2dCQUNwQ0YsY0FBY2hGLCtDQUFrQixDQUFDZ0Y7Z0JBQ2pDQyxXQUFXakYsK0NBQWtCLENBQUNpRjtnQkFDOUJuRSxPQUFPdUYsT0FBT3ZGO2dCQUNkTCxVQUFVVCwrQ0FBa0IsQ0FBQ1M7Z0JBQzdCRSxTQUFTWCwrQ0FBa0IsQ0FBQ1c7Z0JBQzVCMkUsVUFBVUE7WUFDWjtRQUNGLEVBQUUsT0FBTzVCLEtBQVU7WUFDakJDLFFBQVFsQyxLQUFLLENBQUMsMkJBQTJCaUM7WUFDekNoQyxTQUFTZ0MsSUFBSW1ELE9BQU8sSUFBSTtRQUMxQixTQUFVO1lBQ1JyRixXQUFXO1FBQ2I7SUFDRjtJQUVBLE9BQU87UUFBRWhCO1FBQVFlO1FBQVNFO1FBQU9xRixTQUFTRztJQUFZO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzP2QzYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7XG4gIGdldEZhY3RvcnlDb250cmFjdCxcbiAgZ2V0TWFya2V0Q29udHJhY3QsXG4gIGdldFByb3ZpZGVyLFxuICBNYXJrZXREYXRhLFxuICBNYXJrZXRTdGF0ZSxcbiAgRkFDVE9SWV9BRERSRVNTLFxufSBmcm9tIFwiLi4vbGliL2NvbnRyYWN0c1wiO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZSBiYXNlZCBvbiBsaXF1aWRpdHkgYW5kIGFjdGl2aXR5XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUobWFya2V0OiBNYXJrZXREYXRhKTogbnVtYmVyIHtcbiAgY29uc3QgdG90YWxZZXMgPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbFllcyk7XG4gIGNvbnN0IHRvdGFsTm8gPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbE5vKTtcbiAgY29uc3QgdG90YWxMaXF1aWRpdHkgPSB0b3RhbFllcyArIHRvdGFsTm87XG4gIFxuICAvLyBCYXNlIHNjb3JlIGZyb20gbGlxdWlkaXR5ICh2b2x1bWUpXG4gIGxldCBzY29yZSA9IHRvdGFsTGlxdWlkaXR5O1xuICBcbiAgLy8gQm9vc3QgZm9yIGFjdGl2ZSBtYXJrZXRzXG4gIGlmIChtYXJrZXQuc3RhdGUgPT09IE1hcmtldFN0YXRlLkFjdGl2ZSkge1xuICAgIHNjb3JlICo9IDEuMjtcbiAgfVxuICBcbiAgLy8gQm9vc3QgZm9yIG1hcmtldHMgd2l0aCBiYWxhbmNlZCBsaXF1aWRpdHkgKG1vcmUgaW50ZXJlc3RpbmcpXG4gIGlmICh0b3RhbExpcXVpZGl0eSA+IDApIHtcbiAgICBjb25zdCBiYWxhbmNlID0gTWF0aC5taW4odG90YWxZZXMsIHRvdGFsTm8pIC8gTWF0aC5tYXgodG90YWxZZXMsIHRvdGFsTm8pO1xuICAgIHNjb3JlICo9ICgxICsgYmFsYW5jZSAqIDAuMyk7IC8vIFVwIHRvIDMwJSBib29zdCBmb3IgYmFsYW5jZWQgbWFya2V0c1xuICB9XG4gIFxuICByZXR1cm4gc2NvcmU7XG59XG5cbi8qKlxuICogSG9vayB0byBmZXRjaCBhbGwgbWFya2V0cyBmcm9tIHRoZSBmYWN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXJrZXRzKCkge1xuICBjb25zdCBbbWFya2V0cywgc2V0TWFya2V0c10gPSB1c2VTdGF0ZTxNYXJrZXREYXRhW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZmV0Y2hNYXJrZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IGZhY3RvcnkgPSBnZXRGYWN0b3J5Q29udHJhY3QocHJvdmlkZXIpO1xuXG4gICAgICAvLyBHZXQgYWxsIG1hcmtldCBhZGRyZXNzZXMgZnJvbSBmYWN0b3J5XG4gICAgICBjb25zdCBtYXJrZXRBZGRyZXNzZXM6IHN0cmluZ1tdID0gYXdhaXQgZmFjdG9yeS5nZXRNYXJrZXRzKCk7XG4gICAgICBcbiAgICAgIC8vIEZldGNoIE1hcmtldENyZWF0ZWQgZXZlbnRzIHRvIGdldCBjcmVhdGlvbiB0cmFuc2FjdGlvbiBoYXNoZXMgYW5kIGNyZWF0b3IgYWRkcmVzc2VzXG4gICAgICBjb25zdCBjcmVhdGlvblR4TWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgIGNvbnN0IGNyZWF0b3JNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUXVlcnkgTWFya2V0Q3JlYXRlZCBldmVudHMgZnJvbSB0aGUgZmFjdG9yeSBjb250cmFjdFxuICAgICAgICAvLyBFdmVudCBzaWduYXR1cmU6IE1hcmtldENyZWF0ZWQoYWRkcmVzcyBpbmRleGVkIG1hcmtldCwgYWRkcmVzcyBpbmRleGVkIGNyZWF0b3IsIGFkZHJlc3MgaW5kZXhlZCBmZWVkQWRkcmVzcylcbiAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGV0aGVycy5pZChcIk1hcmtldENyZWF0ZWQoYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MpXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgYWRkcmVzczogRkFDVE9SWV9BRERSRVNTLFxuICAgICAgICAgIHRvcGljczogW2V2ZW50VG9waWNdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBldmVudHMgPSBhd2FpdCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBQYXJzZSBldmVudHNcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgZXZlbnQgKG1hcmtldCBhZGRyZXNzIGlzIHRoZSBmaXJzdCBpbmRleGVkIHBhcmFtZXRlciwgY3JlYXRvciBpcyBzZWNvbmQpXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gZmFjdG9yeS5pbnRlcmZhY2UucGFyc2VMb2coe1xuICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3MsXG4gICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZCAmJiBkZWNvZGVkLmFyZ3MgJiYgZGVjb2RlZC5hcmdzLm1hcmtldCkge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXRBZGRyZXNzID0gZGVjb2RlZC5hcmdzLm1hcmtldC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBjcmVhdGlvblR4TWFwLnNldChtYXJrZXRBZGRyZXNzLCBsb2cudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgLy8gRXh0cmFjdCBjcmVhdG9yIGFkZHJlc3MgKHNlY29uZCBpbmRleGVkIHBhcmFtZXRlcilcbiAgICAgICAgICAgICAgaWYgKGRlY29kZWQuYXJncy5jcmVhdG9yKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRvck1hcC5zZXQobWFya2V0QWRkcmVzcywgZGVjb2RlZC5hcmdzLmNyZWF0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXJzaW5nIC0gbWFya2V0IGFkZHJlc3MgbWlnaHQgYmUgaW4gdG9waWNzWzFdLCBjcmVhdG9yIGluIHRvcGljc1syXVxuICAgICAgICAgICAgaWYgKGxvZy50b3BpY3MgJiYgbG9nLnRvcGljcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtldEFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzFdLnNsaWNlKDI2KSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgY29uc3QgY3JlYXRvckFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhcIjB4XCIgKyBsb2cudG9waWNzWzJdLnNsaWNlKDI2KSk7XG4gICAgICAgICAgICAgIGNyZWF0aW9uVHhNYXAuc2V0KG1hcmtldEFkZHJlc3MsIGxvZy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICBjcmVhdG9yTWFwLnNldChtYXJrZXRBZGRyZXNzLCBjcmVhdG9yQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGZldGNoIE1hcmtldENyZWF0ZWQgZXZlbnRzOlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFt1c2VNYXJrZXRzXSBGb3VuZCAke21hcmtldEFkZHJlc3Nlcy5sZW5ndGh9IG1hcmtldHMgZnJvbSBmYWN0b3J5OmAsIG1hcmtldEFkZHJlc3Nlcyk7XG5cbiAgICAgIC8vIEZldGNoIG1ldGFkYXRhIGZyb20gYmFja2VuZCBBUElcbiAgICAgIGxldCBiYWNrZW5kTWFya2V0czogYW55W10gPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjMwMDFcIjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2ApO1xuICAgICAgICBiYWNrZW5kTWFya2V0cyA9IHJlc3BvbnNlLmRhdGEgfHwgW107XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRm91bmQgJHtiYWNrZW5kTWFya2V0cy5sZW5ndGh9IG1hcmtldHMgaW4gYmFja2VuZCBtZXRhZGF0YWApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXQgbWV0YWRhdGEgZnJvbSBiYWNrZW5kOlwiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgYmFja2VuZCBtYXJrZXRzIGJ5IG1hcmtldF9hZGRyZXNzIChwcmltYXJ5KSBhbmQgZmVlZElkIChmYWxsYmFjaykgZm9yIHF1aWNrIGxvb2t1cFxuICAgICAgY29uc3QgYmFja2VuZE1hcEJ5QWRkcmVzcyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICBjb25zdCBiYWNrZW5kTWFwQnlGZWVkSWQgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgYmFja2VuZE1hcmtldHMuZm9yRWFjaCgobTogYW55KSA9PiB7XG4gICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldF9hZGRyZXNzIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAobS5tYXJrZXRfYWRkcmVzcykge1xuICAgICAgICAgIGNvbnN0IGFkZHJMb3dlciA9IG0ubWFya2V0X2FkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBiYWNrZW5kTWFwQnlBZGRyZXNzLnNldChhZGRyTG93ZXIsIG0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrOiBtYXRjaCBieSBmZWVkSWQgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtLmZlZWRfaWQpIHtcbiAgICAgICAgICBjb25zdCBmZWVkSWRMb3dlciA9IG0uZmVlZF9pZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5zZXQoZmVlZElkTG93ZXIsIG0pO1xuICAgICAgICAgIC8vIEFsc28gdHJ5IHdpdGhvdXQgMHggcHJlZml4IGlmIHByZXNlbnRcbiAgICAgICAgICBpZiAoZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLnNldChmZWVkSWRMb3dlci5zbGljZSgyKSwgbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRmV0Y2ggZGF0YSBmb3IgZWFjaCBtYXJrZXRcbiAgICAgIGNvbnN0IG1hcmtldFByb21pc2VzID0gbWFya2V0QWRkcmVzc2VzLm1hcChhc3luYyAoYWRkcmVzcykgPT4ge1xuICAgICAgICBjb25zdCBtYXJrZXRDb250cmFjdCA9IGdldE1hcmtldENvbnRyYWN0KGFkZHJlc3MsIHByb3ZpZGVyKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFtjdXJyZW50UHJpY2UsIGxvY2tQcmljZSwgc3RhdGUsIHRvdGFsWWVzLCB0b3RhbE5vLCBmZWVkSWRdID1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3QuZ2V0Q3VycmVudFByaWNlKCksXG4gICAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC5zdGF0ZSgpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC50b3RhbFllcygpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC50b3RhbE5vKCksXG4gICAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmV0Y2ggcXVlc3Rpb24gZnJvbSBjb250cmFjdCBzZXBhcmF0ZWx5ICh3aXRoIGVycm9yIGhhbmRsaW5nKVxuICAgICAgICAgIGxldCBxdWVzdGlvbiA9IFwiXCI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXN0aW9uID0gYXdhaXQgbWFya2V0Q29udHJhY3QucXVlc3Rpb24oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGZldGNoIHF1ZXN0aW9uIGZvciBtYXJrZXQgJHthZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnZlcnQgZmVlZElkIGJ5dGVzMzIgdG8gc3RyaW5nIChyZW1vdmUgbnVsbCBieXRlcylcbiAgICAgICAgICBjb25zdCBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuICAgICAgICAgIGNvbnN0IGZlZWRJZEhleCA9IGZlZWRJZFN0ciB8fCBldGhlcnMuaGV4bGlmeShmZWVkSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIG1hdGNoaW5nIGJhY2tlbmQgbWV0YWRhdGFcbiAgICAgICAgICAvLyBQcmltYXJ5OiBtYXRjaCBieSBtYXJrZXQgYWRkcmVzcyAobW9zdCByZWxpYWJsZSlcbiAgICAgICAgICBjb25zdCBhZGRyZXNzTG93ZXIgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbGV0IGJhY2tlbmRNYXJrZXQgPSBiYWNrZW5kTWFwQnlBZGRyZXNzLmdldChhZGRyZXNzTG93ZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZhbGxiYWNrOiBtYXRjaCBieSBmZWVkSWQgaWYgYWRkcmVzcyBtYXRjaCBmYWlsZWRcbiAgICAgICAgICBpZiAoIWJhY2tlbmRNYXJrZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRJZExvd2VyID0gZmVlZElkSGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBmZWVkSWROb1ByZWZpeCA9IGZlZWRJZExvd2VyLnN0YXJ0c1dpdGgoJzB4JykgPyBmZWVkSWRMb3dlci5zbGljZSgyKSA6IGZlZWRJZExvd2VyO1xuICAgICAgICAgICAgYmFja2VuZE1hcmtldCA9IGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkTG93ZXIpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWROb1ByZWZpeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmRNYXBCeUZlZWRJZC5nZXQoZmVlZElkU3RyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNyZWF0aW9uVHhIYXNoID0gY3JlYXRpb25UeE1hcC5nZXQoYWRkcmVzc0xvd2VyKTtcbiAgICAgICAgICBjb25zdCBjcmVhdG9yQWRkcmVzcyA9IGNyZWF0b3JNYXAuZ2V0KGFkZHJlc3NMb3dlcik7XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IGltYWdlVXJsIGZyb20gYmFja2VuZCBtYXJrZXQgKHN1cHBvcnQgYm90aCBzbmFrZV9jYXNlIGFuZCBjYW1lbENhc2UpXG4gICAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSBiYWNrZW5kTWFya2V0Py5pbWFnZV91cmwgfHwgYmFja2VuZE1hcmtldD8uaW1hZ2VVcmwgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoaW1hZ2VVcmwgJiYgYWRkcmVzc0xvd2VyID09PSBtYXJrZXRBZGRyZXNzZXNbMF0/LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gTWFya2V0ICR7YWRkcmVzc30gaGFzIGltYWdlVXJsOmAsIGltYWdlVXJsLnN1YnN0cmluZygwLCAxMDApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBtYXJrZXREYXRhOiBNYXJrZXREYXRhID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZWRJZDogZmVlZElkSGV4LFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudFByaWNlKSxcbiAgICAgICAgICAgIGxvY2tQcmljZTogZXRoZXJzLmZvcm1hdEV0aGVyKGxvY2tQcmljZSksXG4gICAgICAgICAgICBzdGF0ZTogTnVtYmVyKHN0YXRlKSBhcyBNYXJrZXRTdGF0ZSxcbiAgICAgICAgICAgIHRvdGFsWWVzOiBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxZZXMpLFxuICAgICAgICAgICAgdG90YWxObzogZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsTm8pLFxuICAgICAgICAgICAgLy8gVXNlIHF1ZXN0aW9uIGZyb20gY29udHJhY3QgZmlyc3QsIGZhbGxiYWNrIHRvIGJhY2tlbmQgbWV0YWRhdGFcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbiB8fCBiYWNrZW5kTWFya2V0Py5xdWVzdGlvbixcbiAgICAgICAgICAgIGNhdGVnb3J5OiBiYWNrZW5kTWFya2V0Py5jYXRlZ29yeSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBiYWNrZW5kTWFya2V0Py5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCwgLy8gU2V0IGltYWdlVXJsIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGNyZWF0aW9uVHhIYXNoOiBjcmVhdGlvblR4SGFzaCxcbiAgICAgICAgICAgIGNyZWF0b3JBZGRyZXNzOiBjcmVhdG9yQWRkcmVzcyxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIG1hcmtldERhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbWFya2V0ICR7YWRkcmVzc306YCwgZXJyKTtcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGF0IGxlYXN0IHRoZSBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0IGlmIG90aGVyIGNhbGxzIGZhaWxcbiAgICAgICAgICBsZXQgcXVlc3Rpb24gPSBcIlwiO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWVzdGlvbiA9IGF3YWl0IG1hcmtldENvbnRyYWN0LnF1ZXN0aW9uKCk7XG4gICAgICAgICAgfSBjYXRjaCAocXVlc3Rpb25FcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZldGNoIHF1ZXN0aW9uIGZvciBtYXJrZXQgJHthZGRyZXNzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXR1cm4gbWluaW1hbCBkYXRhIGlmIGNvbnRyYWN0IGNhbGwgZmFpbHMsIGJ1dCBzdGlsbCBpbmNsdWRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIG1hcmtldHMgYXJlIHNob3duIGV2ZW4gaWYgc29tZSBjYWxscyBmYWlsXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IFwiXCIsXG4gICAgICAgICAgICBjdXJyZW50UHJpY2U6IFwiMFwiLFxuICAgICAgICAgICAgbG9ja1ByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIHN0YXRlOiBNYXJrZXRTdGF0ZS5BY3RpdmUsXG4gICAgICAgICAgICB0b3RhbFllczogXCIwXCIsXG4gICAgICAgICAgICB0b3RhbE5vOiBcIjBcIixcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbiB8fCBgTWFya2V0ICR7YWRkcmVzcy5zbGljZSgwLCA4KX0uLi4ke2FkZHJlc3Muc2xpY2UoLTYpfWAsXG4gICAgICAgICAgfSBhcyBNYXJrZXREYXRhO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWFya2V0RGF0YSA9IGF3YWl0IFByb21pc2UuYWxsKG1hcmtldFByb21pc2VzKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gU3VjY2Vzc2Z1bGx5IGZldGNoZWQgZGF0YSBmb3IgJHttYXJrZXREYXRhLmxlbmd0aH0gbWFya2V0c2ApO1xuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgb3V0IG1hcmtldHMgd2l0aCBlbXB0eSBhZGRyZXNzZXMgKGZhaWxlZCBmZXRjaGVzKVxuICAgICAgY29uc3QgdmFsaWRNYXJrZXRzID0gbWFya2V0RGF0YS5maWx0ZXIobSA9PiBtLmFkZHJlc3MgJiYgbS5hZGRyZXNzICE9PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gVmFsaWQgbWFya2V0cyBhZnRlciBmaWx0ZXJpbmc6ICR7dmFsaWRNYXJrZXRzLmxlbmd0aH1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHRyZW5kaW5nIHNjb3JlcyBhbmQgYWRkIHRvIG1hcmtldCBkYXRhXG4gICAgICBjb25zdCBtYXJrZXRzV2l0aFRyZW5kaW5nID0gdmFsaWRNYXJrZXRzLm1hcChtYXJrZXQgPT4gKHtcbiAgICAgICAgLi4ubWFya2V0LFxuICAgICAgICB0cmVuZGluZ1Njb3JlOiBjYWxjdWxhdGVUcmVuZGluZ1Njb3JlKG1hcmtldCksXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlTWFya2V0c10gRmluYWwgbWFya2V0cyB0byBkaXNwbGF5OmAsIG1hcmtldHNXaXRoVHJlbmRpbmcubWFwKG0gPT4gKHsgXG4gICAgICAgIGFkZHJlc3M6IG0uYWRkcmVzcywgXG4gICAgICAgIHF1ZXN0aW9uOiBtLnF1ZXN0aW9uIHx8ICdObyBxdWVzdGlvbicsIFxuICAgICAgICBoYXNJbWFnZTogISFtLmltYWdlVXJsLFxuICAgICAgICBpbWFnZVVybDogbS5pbWFnZVVybCA/IGAke20uaW1hZ2VVcmwuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogJ25vbmUnXG4gICAgICB9KSkpO1xuICAgICAgXG4gICAgICBzZXRNYXJrZXRzKG1hcmtldHNXaXRoVHJlbmRpbmcpO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldHM6XCIsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoTWFya2V0cygpO1xuICB9LCBbZmV0Y2hNYXJrZXRzXSk7XG5cbiAgcmV0dXJuIHsgbWFya2V0cywgbG9hZGluZywgZXJyb3IsIHJlZmV0Y2g6IGZldGNoTWFya2V0cyB9O1xufVxuXG4vKipcbiAqIEhvb2sgdG8gZmV0Y2ggYSBzaW5nbGUgbWFya2V0J3MgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFya2V0KG1hcmtldEFkZHJlc3M6IHN0cmluZyB8IG51bGwpIHtcbiAgY29uc3QgW21hcmtldCwgc2V0TWFya2V0XSA9IHVzZVN0YXRlPE1hcmtldERhdGEgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmZXRjaE1hcmtldCgpO1xuICB9LCBbbWFya2V0QWRkcmVzc10pO1xuXG4gIGNvbnN0IGZldGNoTWFya2V0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbWFya2V0QWRkcmVzcykgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgbWFya2V0Q29udHJhY3QgPSBnZXRNYXJrZXRDb250cmFjdChtYXJrZXRBZGRyZXNzLCBwcm92aWRlcik7XG5cbiAgICAgIGNvbnN0IFtjdXJyZW50UHJpY2UsIGxvY2tQcmljZSwgc3RhdGUsIHRvdGFsWWVzLCB0b3RhbE5vLCBmZWVkSWRdID1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIG1hcmtldENvbnRyYWN0LmdldEN1cnJlbnRQcmljZSgpLFxuICAgICAgICAgIG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpLFxuICAgICAgICAgIG1hcmtldENvbnRyYWN0LnN0YXRlKCksXG4gICAgICAgICAgbWFya2V0Q29udHJhY3QudG90YWxZZXMoKSxcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC50b3RhbE5vKCksXG4gICAgICAgICAgbWFya2V0Q29udHJhY3QuZmVlZElkKCksXG4gICAgICAgIF0pO1xuXG4gICAgICAvLyBGZXRjaCBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0XG4gICAgICBsZXQgcXVlc3Rpb24gPSBcIlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcXVlc3Rpb24gPSBhd2FpdCBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGZldGNoIHF1ZXN0aW9uIGZvciBtYXJrZXQgJHttYXJrZXRBZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmZWVkSWRTdHIgPSBldGhlcnMudG9VdGY4U3RyaW5nKGZlZWRJZCkucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuXG4gICAgICBzZXRNYXJrZXQoe1xuICAgICAgICBhZGRyZXNzOiBtYXJrZXRBZGRyZXNzLFxuICAgICAgICBmZWVkSWQ6IGZlZWRJZFN0ciB8fCBldGhlcnMuaGV4bGlmeShmZWVkSWQpLFxuICAgICAgICBjdXJyZW50UHJpY2U6IGV0aGVycy5mb3JtYXRFdGhlcihjdXJyZW50UHJpY2UpLFxuICAgICAgICBsb2NrUHJpY2U6IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpLFxuICAgICAgICBzdGF0ZTogTnVtYmVyKHN0YXRlKSBhcyBNYXJrZXRTdGF0ZSxcbiAgICAgICAgdG90YWxZZXM6IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbFllcyksXG4gICAgICAgIHRvdGFsTm86IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSxcbiAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0OlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0XCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgbWFya2V0LCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaDogZmV0Y2hNYXJrZXQgfTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJldGhlcnMiLCJheGlvcyIsImdldEZhY3RvcnlDb250cmFjdCIsImdldE1hcmtldENvbnRyYWN0IiwiZ2V0UHJvdmlkZXIiLCJNYXJrZXRTdGF0ZSIsIkZBQ1RPUllfQUREUkVTUyIsImNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUiLCJtYXJrZXQiLCJ0b3RhbFllcyIsInBhcnNlRmxvYXQiLCJ0b3RhbE5vIiwidG90YWxMaXF1aWRpdHkiLCJzY29yZSIsInN0YXRlIiwiQWN0aXZlIiwiYmFsYW5jZSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1c2VNYXJrZXRzIiwibWFya2V0cyIsInNldE1hcmtldHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJmZXRjaE1hcmtldHMiLCJwcm92aWRlciIsImZhY3RvcnkiLCJtYXJrZXRBZGRyZXNzZXMiLCJnZXRNYXJrZXRzIiwiY3JlYXRpb25UeE1hcCIsIk1hcCIsImNyZWF0b3JNYXAiLCJldmVudFRvcGljIiwiaWQiLCJmaWx0ZXIiLCJhZGRyZXNzIiwidG9waWNzIiwiZXZlbnRzIiwiZ2V0TG9ncyIsImxvZyIsImRlY29kZWQiLCJpbnRlcmZhY2UiLCJwYXJzZUxvZyIsImRhdGEiLCJhcmdzIiwibWFya2V0QWRkcmVzcyIsInRvTG93ZXJDYXNlIiwic2V0IiwidHJhbnNhY3Rpb25IYXNoIiwiY3JlYXRvciIsInBhcnNlRXJyIiwibGVuZ3RoIiwiZ2V0QWRkcmVzcyIsInNsaWNlIiwiY3JlYXRvckFkZHJlc3MiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsImJhY2tlbmRNYXJrZXRzIiwiYXBpVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsImdldCIsImJhY2tlbmRNYXBCeUFkZHJlc3MiLCJiYWNrZW5kTWFwQnlGZWVkSWQiLCJmb3JFYWNoIiwibSIsIm1hcmtldF9hZGRyZXNzIiwiYWRkckxvd2VyIiwiZmVlZF9pZCIsImZlZWRJZExvd2VyIiwic3RhcnRzV2l0aCIsIm1hcmtldFByb21pc2VzIiwibWFwIiwibWFya2V0Q29udHJhY3QiLCJjdXJyZW50UHJpY2UiLCJsb2NrUHJpY2UiLCJmZWVkSWQiLCJQcm9taXNlIiwiYWxsIiwiZ2V0Q3VycmVudFByaWNlIiwicXVlc3Rpb24iLCJmZWVkSWRTdHIiLCJ0b1V0ZjhTdHJpbmciLCJyZXBsYWNlIiwiZmVlZElkSGV4IiwiaGV4bGlmeSIsImFkZHJlc3NMb3dlciIsImJhY2tlbmRNYXJrZXQiLCJmZWVkSWROb1ByZWZpeCIsImNyZWF0aW9uVHhIYXNoIiwiaW1hZ2VVcmwiLCJpbWFnZV91cmwiLCJzdWJzdHJpbmciLCJtYXJrZXREYXRhIiwiZm9ybWF0RXRoZXIiLCJOdW1iZXIiLCJjYXRlZ29yeSIsImRlc2NyaXB0aW9uIiwicXVlc3Rpb25FcnIiLCJ2YWxpZE1hcmtldHMiLCJtYXJrZXRzV2l0aFRyZW5kaW5nIiwidHJlbmRpbmdTY29yZSIsImhhc0ltYWdlIiwibWVzc2FnZSIsInJlZmV0Y2giLCJ1c2VNYXJrZXQiLCJzZXRNYXJrZXQiLCJmZXRjaE1hcmtldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});