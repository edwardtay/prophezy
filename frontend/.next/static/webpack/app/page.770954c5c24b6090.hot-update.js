"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useMarkets.ts":
/*!*********************************!*\
  !*** ./src/hooks/useMarkets.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMarket: function() { return /* binding */ useMarket; },\n/* harmony export */   useMarkets: function() { return /* binding */ useMarkets; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _lib_contracts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n\n\n\n\n/**\n * Calculate trending score based on liquidity and activity\n */ function calculateTrendingScore(market) {\n    const totalYes = parseFloat(market.totalYes);\n    const totalNo = parseFloat(market.totalNo);\n    const totalLiquidity = totalYes + totalNo;\n    // Base score from liquidity (volume)\n    let score = totalLiquidity;\n    // Boost for active markets\n    if (market.state === _lib_contracts__WEBPACK_IMPORTED_MODULE_1__.MarketState.Active) {\n        score *= 1.2;\n    }\n    // Boost for markets with balanced liquidity (more interesting)\n    if (totalLiquidity > 0) {\n        const balance = Math.min(totalYes, totalNo) / Math.max(totalYes, totalNo);\n        score *= 1 + balance * 0.3; // Up to 30% boost for balanced markets\n    }\n    return score;\n}\n/**\n * Hook to fetch all markets from the factory\n */ function useMarkets() {\n    const [markets, setMarkets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchMarkets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n            const factory = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getFactoryContract)(provider);\n            // Get all market addresses from factory\n            const marketAddresses = await factory.getMarkets();\n            // Fetch metadata from backend API\n            let backendMarkets = [];\n            try {\n                const apiUrl = \"http://localhost:3001\" || 0;\n                const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(apiUrl, \"/api/markets\"));\n                backendMarkets = response.data || [];\n            } catch (err) {\n                console.warn(\"Failed to fetch market metadata from backend:\", err);\n            }\n            // Create a map of backend markets by market_address (primary) and feedId (fallback) for quick lookup\n            const backendMapByAddress = new Map();\n            const backendMapByFeedId = new Map();\n            backendMarkets.forEach((m)=>{\n                // Primary: match by market_address if available\n                if (m.market_address) {\n                    const addrLower = m.market_address.toLowerCase();\n                    backendMapByAddress.set(addrLower, m);\n                }\n                // Fallback: match by feedId if available\n                if (m.feed_id) {\n                    const feedIdLower = m.feed_id.toLowerCase();\n                    backendMapByFeedId.set(feedIdLower, m);\n                    // Also try without 0x prefix if present\n                    if (feedIdLower.startsWith(\"0x\")) {\n                        backendMapByFeedId.set(feedIdLower.slice(2), m);\n                    }\n                }\n            });\n            // Fetch data for each market\n            const marketPromises = marketAddresses.map(async (address)=>{\n                const marketContract = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getMarketContract)(address, provider);\n                try {\n                    const [currentPrice, lockPrice, state, totalYes, totalNo, feedId, question] = await Promise.all([\n                        marketContract.getCurrentPrice(),\n                        marketContract.lockPrice(),\n                        marketContract.state(),\n                        marketContract.totalYes(),\n                        marketContract.totalNo(),\n                        marketContract.feedId(),\n                        marketContract.question().catch(()=>\"\")\n                    ]);\n                    // Convert feedId bytes32 to string (remove null bytes)\n                    const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_3__.toUtf8String(feedId).replace(/\\0/g, \"\");\n                    const feedIdHex = feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(feedId);\n                    // Try to find matching backend metadata\n                    // Primary: match by market address (most reliable)\n                    const addressLower = address.toLowerCase();\n                    let backendMarket = backendMapByAddress.get(addressLower);\n                    // Fallback: match by feedId if address match failed\n                    if (!backendMarket) {\n                        const feedIdLower = feedIdHex.toLowerCase();\n                        const feedIdNoPrefix = feedIdLower.startsWith(\"0x\") ? feedIdLower.slice(2) : feedIdLower;\n                        backendMarket = backendMapByFeedId.get(feedIdLower) || backendMapByFeedId.get(feedIdNoPrefix) || backendMapByFeedId.get(feedIdStr.toLowerCase());\n                    }\n                    const marketData = {\n                        address,\n                        feedId: feedIdHex,\n                        currentPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(currentPrice),\n                        lockPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(lockPrice),\n                        state: Number(state),\n                        totalYes: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalYes),\n                        totalNo: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalNo),\n                        // Use question from contract first, fallback to backend metadata\n                        question: question || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.question),\n                        category: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.category,\n                        description: backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.description,\n                        imageUrl: (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.image_url) || (backendMarket === null || backendMarket === void 0 ? void 0 : backendMarket.imageUrl)\n                    };\n                    return marketData;\n                } catch (err) {\n                    console.error(\"Error fetching market \".concat(address, \":\"), err);\n                    // Return minimal data if contract call fails\n                    return {\n                        address,\n                        feedId: \"\",\n                        currentPrice: \"0\",\n                        lockPrice: \"0\",\n                        state: _lib_contracts__WEBPACK_IMPORTED_MODULE_1__.MarketState.Active,\n                        totalYes: \"0\",\n                        totalNo: \"0\"\n                    };\n                }\n            });\n            const marketData = await Promise.all(marketPromises);\n            // Calculate trending scores and add to market data\n            const marketsWithTrending = marketData.map((market)=>({\n                    ...market,\n                    trendingScore: calculateTrendingScore(market)\n                }));\n            // Return empty array - all markets removed\n            setMarkets([]);\n        } catch (err) {\n            console.error(\"Failed to fetch markets:\", err);\n            setError(err.message || \"Failed to fetch markets\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchMarkets();\n    }, [\n        fetchMarkets\n    ]);\n    return {\n        markets,\n        loading,\n        error,\n        refetch: fetchMarkets\n    };\n}\n/**\n * Hook to fetch a single market's data\n */ function useMarket(marketAddress) {\n    const [market, setMarket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marketAddress) {\n            setLoading(false);\n            return;\n        }\n        fetchMarket();\n    }, [\n        marketAddress\n    ]);\n    const fetchMarket = async ()=>{\n        if (!marketAddress) return;\n        try {\n            setLoading(true);\n            setError(null);\n            const provider = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n            const marketContract = (0,_lib_contracts__WEBPACK_IMPORTED_MODULE_1__.getMarketContract)(marketAddress, provider);\n            const [currentPrice, lockPrice, state, totalYes, totalNo, feedId] = await Promise.all([\n                marketContract.getCurrentPrice(),\n                marketContract.lockPrice(),\n                marketContract.state(),\n                marketContract.totalYes(),\n                marketContract.totalNo(),\n                marketContract.feedId()\n            ]);\n            const feedIdStr = ethers__WEBPACK_IMPORTED_MODULE_3__.toUtf8String(feedId).replace(/\\0/g, \"\");\n            setMarket({\n                address: marketAddress,\n                feedId: feedIdStr || ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(feedId),\n                currentPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(currentPrice),\n                lockPrice: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(lockPrice),\n                state: Number(state),\n                totalYes: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalYes),\n                totalNo: ethers__WEBPACK_IMPORTED_MODULE_5__.formatEther(totalNo)\n            });\n        } catch (err) {\n            console.error(\"Failed to fetch market:\", err);\n            setError(err.message || \"Failed to fetch market\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    return {\n        market,\n        loading,\n        error,\n        refetch: fetchMarket\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXJrZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5RDtBQUN6QjtBQUNOO0FBT0E7QUFFMUI7O0NBRUMsR0FDRCxTQUFTUyx1QkFBdUJDLE1BQWtCO0lBQ2hELE1BQU1DLFdBQVdDLFdBQVdGLE9BQU9DLFFBQVE7SUFDM0MsTUFBTUUsVUFBVUQsV0FBV0YsT0FBT0csT0FBTztJQUN6QyxNQUFNQyxpQkFBaUJILFdBQVdFO0lBRWxDLHFDQUFxQztJQUNyQyxJQUFJRSxRQUFRRDtJQUVaLDJCQUEyQjtJQUMzQixJQUFJSixPQUFPTSxLQUFLLEtBQUtSLHVEQUFXQSxDQUFDUyxNQUFNLEVBQUU7UUFDdkNGLFNBQVM7SUFDWDtJQUVBLCtEQUErRDtJQUMvRCxJQUFJRCxpQkFBaUIsR0FBRztRQUN0QixNQUFNSSxVQUFVQyxLQUFLQyxHQUFHLENBQUNULFVBQVVFLFdBQVdNLEtBQUtFLEdBQUcsQ0FBQ1YsVUFBVUU7UUFDakVFLFNBQVUsSUFBSUcsVUFBVSxLQUFNLHVDQUF1QztJQUN2RTtJQUVBLE9BQU9IO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNPO0lBQ2QsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUd4QiwrQ0FBUUEsQ0FBZSxFQUFFO0lBQ3ZELE1BQU0sQ0FBQ3lCLFNBQVNDLFdBQVcsR0FBRzFCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQzJCLE9BQU9DLFNBQVMsR0FBRzVCLCtDQUFRQSxDQUFnQjtJQUVsRCxNQUFNNkIsZUFBZTNCLGtEQUFXQSxDQUFDO1FBQy9CLElBQUk7WUFDRndCLFdBQVc7WUFDWEUsU0FBUztZQUVULE1BQU1FLFdBQVd2QiwyREFBV0E7WUFDNUIsTUFBTXdCLFVBQVUxQixrRUFBa0JBLENBQUN5QjtZQUVuQyx3Q0FBd0M7WUFDeEMsTUFBTUUsa0JBQTRCLE1BQU1ELFFBQVFFLFVBQVU7WUFFMUQsa0NBQWtDO1lBQ2xDLElBQUlDLGlCQUF3QixF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Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZU1hcmtldHMudHM/ZDNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IHtcbiAgZ2V0RmFjdG9yeUNvbnRyYWN0LFxuICBnZXRNYXJrZXRDb250cmFjdCxcbiAgZ2V0UHJvdmlkZXIsXG4gIE1hcmtldERhdGEsXG4gIE1hcmtldFN0YXRlLFxufSBmcm9tIFwiLi4vbGliL2NvbnRyYWN0c1wiO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0cmVuZGluZyBzY29yZSBiYXNlZCBvbiBsaXF1aWRpdHkgYW5kIGFjdGl2aXR5XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyZW5kaW5nU2NvcmUobWFya2V0OiBNYXJrZXREYXRhKTogbnVtYmVyIHtcbiAgY29uc3QgdG90YWxZZXMgPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbFllcyk7XG4gIGNvbnN0IHRvdGFsTm8gPSBwYXJzZUZsb2F0KG1hcmtldC50b3RhbE5vKTtcbiAgY29uc3QgdG90YWxMaXF1aWRpdHkgPSB0b3RhbFllcyArIHRvdGFsTm87XG4gIFxuICAvLyBCYXNlIHNjb3JlIGZyb20gbGlxdWlkaXR5ICh2b2x1bWUpXG4gIGxldCBzY29yZSA9IHRvdGFsTGlxdWlkaXR5O1xuICBcbiAgLy8gQm9vc3QgZm9yIGFjdGl2ZSBtYXJrZXRzXG4gIGlmIChtYXJrZXQuc3RhdGUgPT09IE1hcmtldFN0YXRlLkFjdGl2ZSkge1xuICAgIHNjb3JlICo9IDEuMjtcbiAgfVxuICBcbiAgLy8gQm9vc3QgZm9yIG1hcmtldHMgd2l0aCBiYWxhbmNlZCBsaXF1aWRpdHkgKG1vcmUgaW50ZXJlc3RpbmcpXG4gIGlmICh0b3RhbExpcXVpZGl0eSA+IDApIHtcbiAgICBjb25zdCBiYWxhbmNlID0gTWF0aC5taW4odG90YWxZZXMsIHRvdGFsTm8pIC8gTWF0aC5tYXgodG90YWxZZXMsIHRvdGFsTm8pO1xuICAgIHNjb3JlICo9ICgxICsgYmFsYW5jZSAqIDAuMyk7IC8vIFVwIHRvIDMwJSBib29zdCBmb3IgYmFsYW5jZWQgbWFya2V0c1xuICB9XG4gIFxuICByZXR1cm4gc2NvcmU7XG59XG5cbi8qKlxuICogSG9vayB0byBmZXRjaCBhbGwgbWFya2V0cyBmcm9tIHRoZSBmYWN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXJrZXRzKCkge1xuICBjb25zdCBbbWFya2V0cywgc2V0TWFya2V0c10gPSB1c2VTdGF0ZTxNYXJrZXREYXRhW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZmV0Y2hNYXJrZXRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IGZhY3RvcnkgPSBnZXRGYWN0b3J5Q29udHJhY3QocHJvdmlkZXIpO1xuXG4gICAgICAvLyBHZXQgYWxsIG1hcmtldCBhZGRyZXNzZXMgZnJvbSBmYWN0b3J5XG4gICAgICBjb25zdCBtYXJrZXRBZGRyZXNzZXM6IHN0cmluZ1tdID0gYXdhaXQgZmFjdG9yeS5nZXRNYXJrZXRzKCk7XG5cbiAgICAgIC8vIEZldGNoIG1ldGFkYXRhIGZyb20gYmFja2VuZCBBUElcbiAgICAgIGxldCBiYWNrZW5kTWFya2V0czogYW55W10gPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjMwMDFcIjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7YXBpVXJsfS9hcGkvbWFya2V0c2ApO1xuICAgICAgICBiYWNrZW5kTWFya2V0cyA9IHJlc3BvbnNlLmRhdGEgfHwgW107XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldCBtZXRhZGF0YSBmcm9tIGJhY2tlbmQ6XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBiYWNrZW5kIG1hcmtldHMgYnkgbWFya2V0X2FkZHJlc3MgKHByaW1hcnkpIGFuZCBmZWVkSWQgKGZhbGxiYWNrKSBmb3IgcXVpY2sgbG9va3VwXG4gICAgICBjb25zdCBiYWNrZW5kTWFwQnlBZGRyZXNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgIGNvbnN0IGJhY2tlbmRNYXBCeUZlZWRJZCA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICBiYWNrZW5kTWFya2V0cy5mb3JFYWNoKChtOiBhbnkpID0+IHtcbiAgICAgICAgLy8gUHJpbWFyeTogbWF0Y2ggYnkgbWFya2V0X2FkZHJlc3MgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtLm1hcmtldF9hZGRyZXNzKSB7XG4gICAgICAgICAgY29uc3QgYWRkckxvd2VyID0gbS5tYXJrZXRfYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJhY2tlbmRNYXBCeUFkZHJlc3Muc2V0KGFkZHJMb3dlciwgbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2s6IG1hdGNoIGJ5IGZlZWRJZCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKG0uZmVlZF9pZCkge1xuICAgICAgICAgIGNvbnN0IGZlZWRJZExvd2VyID0gbS5mZWVkX2lkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLnNldChmZWVkSWRMb3dlciwgbSk7XG4gICAgICAgICAgLy8gQWxzbyB0cnkgd2l0aG91dCAweCBwcmVmaXggaWYgcHJlc2VudFxuICAgICAgICAgIGlmIChmZWVkSWRMb3dlci5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuc2V0KGZlZWRJZExvd2VyLnNsaWNlKDIpLCBtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGZXRjaCBkYXRhIGZvciBlYWNoIG1hcmtldFxuICAgICAgY29uc3QgbWFya2V0UHJvbWlzZXMgPSBtYXJrZXRBZGRyZXNzZXMubWFwKGFzeW5jIChhZGRyZXNzKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gZ2V0TWFya2V0Q29udHJhY3QoYWRkcmVzcywgcHJvdmlkZXIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgW2N1cnJlbnRQcmljZSwgbG9ja1ByaWNlLCBzdGF0ZSwgdG90YWxZZXMsIHRvdGFsTm8sIGZlZWRJZCwgcXVlc3Rpb25dID1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgbWFya2V0Q29udHJhY3QuZ2V0Q3VycmVudFByaWNlKCksXG4gICAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmxvY2tQcmljZSgpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC5zdGF0ZSgpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC50b3RhbFllcygpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC50b3RhbE5vKCksXG4gICAgICAgICAgICAgIG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLFxuICAgICAgICAgICAgICBtYXJrZXRDb250cmFjdC5xdWVzdGlvbigpLmNhdGNoKCgpID0+IFwiXCIpLCAvLyBGZXRjaCBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0LCBmYWxsYmFjayB0byBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBmZWVkSWQgYnl0ZXMzMiB0byBzdHJpbmcgKHJlbW92ZSBudWxsIGJ5dGVzKVxuICAgICAgICAgIGNvbnN0IGZlZWRJZFN0ciA9IGV0aGVycy50b1V0ZjhTdHJpbmcoZmVlZElkKS5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG4gICAgICAgICAgY29uc3QgZmVlZElkSGV4ID0gZmVlZElkU3RyIHx8IGV0aGVycy5oZXhsaWZ5KGZlZWRJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgbWF0Y2hpbmcgYmFja2VuZCBtZXRhZGF0YVxuICAgICAgICAgIC8vIFByaW1hcnk6IG1hdGNoIGJ5IG1hcmtldCBhZGRyZXNzIChtb3N0IHJlbGlhYmxlKVxuICAgICAgICAgIGNvbnN0IGFkZHJlc3NMb3dlciA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsZXQgYmFja2VuZE1hcmtldCA9IGJhY2tlbmRNYXBCeUFkZHJlc3MuZ2V0KGFkZHJlc3NMb3dlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmFsbGJhY2s6IG1hdGNoIGJ5IGZlZWRJZCBpZiBhZGRyZXNzIG1hdGNoIGZhaWxlZFxuICAgICAgICAgIGlmICghYmFja2VuZE1hcmtldCkge1xuICAgICAgICAgICAgY29uc3QgZmVlZElkTG93ZXIgPSBmZWVkSWRIZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRJZE5vUHJlZml4ID0gZmVlZElkTG93ZXIuc3RhcnRzV2l0aCgnMHgnKSA/IGZlZWRJZExvd2VyLnNsaWNlKDIpIDogZmVlZElkTG93ZXI7XG4gICAgICAgICAgICBiYWNrZW5kTWFya2V0ID0gYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRMb3dlcikgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTWFwQnlGZWVkSWQuZ2V0KGZlZWRJZE5vUHJlZml4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZE1hcEJ5RmVlZElkLmdldChmZWVkSWRTdHIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbWFya2V0RGF0YTogTWFya2V0RGF0YSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBmZWVkSWQ6IGZlZWRJZEhleCxcbiAgICAgICAgICAgIGN1cnJlbnRQcmljZTogZXRoZXJzLmZvcm1hdEV0aGVyKGN1cnJlbnRQcmljZSksXG4gICAgICAgICAgICBsb2NrUHJpY2U6IGV0aGVycy5mb3JtYXRFdGhlcihsb2NrUHJpY2UpLFxuICAgICAgICAgICAgc3RhdGU6IE51bWJlcihzdGF0ZSkgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgICAgICB0b3RhbFllczogZXRoZXJzLmZvcm1hdEV0aGVyKHRvdGFsWWVzKSxcbiAgICAgICAgICAgIHRvdGFsTm86IGV0aGVycy5mb3JtYXRFdGhlcih0b3RhbE5vKSxcbiAgICAgICAgICAgIC8vIFVzZSBxdWVzdGlvbiBmcm9tIGNvbnRyYWN0IGZpcnN0LCBmYWxsYmFjayB0byBiYWNrZW5kIG1ldGFkYXRhXG4gICAgICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24gfHwgYmFja2VuZE1hcmtldD8ucXVlc3Rpb24sXG4gICAgICAgICAgICBjYXRlZ29yeTogYmFja2VuZE1hcmtldD8uY2F0ZWdvcnksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYmFja2VuZE1hcmtldD8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpbWFnZVVybDogYmFja2VuZE1hcmtldD8uaW1hZ2VfdXJsIHx8IGJhY2tlbmRNYXJrZXQ/LmltYWdlVXJsLCAvLyBTdXBwb3J0IGJvdGggbmFtaW5nIGNvbnZlbnRpb25zXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBtYXJrZXREYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBtYXJrZXQgJHthZGRyZXNzfTpgLCBlcnIpO1xuICAgICAgICAgIC8vIFJldHVybiBtaW5pbWFsIGRhdGEgaWYgY29udHJhY3QgY2FsbCBmYWlsc1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZmVlZElkOiBcIlwiLFxuICAgICAgICAgICAgY3VycmVudFByaWNlOiBcIjBcIixcbiAgICAgICAgICAgIGxvY2tQcmljZTogXCIwXCIsXG4gICAgICAgICAgICBzdGF0ZTogTWFya2V0U3RhdGUuQWN0aXZlLFxuICAgICAgICAgICAgdG90YWxZZXM6IFwiMFwiLFxuICAgICAgICAgICAgdG90YWxObzogXCIwXCIsXG4gICAgICAgICAgfSBhcyBNYXJrZXREYXRhO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWFya2V0RGF0YSA9IGF3YWl0IFByb21pc2UuYWxsKG1hcmtldFByb21pc2VzKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHRyZW5kaW5nIHNjb3JlcyBhbmQgYWRkIHRvIG1hcmtldCBkYXRhXG4gICAgICBjb25zdCBtYXJrZXRzV2l0aFRyZW5kaW5nID0gbWFya2V0RGF0YS5tYXAobWFya2V0ID0+ICh7XG4gICAgICAgIC4uLm1hcmtldCxcbiAgICAgICAgdHJlbmRpbmdTY29yZTogY2FsY3VsYXRlVHJlbmRpbmdTY29yZShtYXJrZXQpLFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgLSBhbGwgbWFya2V0cyByZW1vdmVkXG4gICAgICBzZXRNYXJrZXRzKFtdKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRzOlwiLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0c1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaE1hcmtldHMoKTtcbiAgfSwgW2ZldGNoTWFya2V0c10pO1xuXG4gIHJldHVybiB7IG1hcmtldHMsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldHMgfTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGZldGNoIGEgc2luZ2xlIG1hcmtldCdzIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcmtldChtYXJrZXRBZGRyZXNzOiBzdHJpbmcgfCBudWxsKSB7XG4gIGNvbnN0IFttYXJrZXQsIHNldE1hcmtldF0gPSB1c2VTdGF0ZTxNYXJrZXREYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXRBZGRyZXNzKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmV0Y2hNYXJrZXQoKTtcbiAgfSwgW21hcmtldEFkZHJlc3NdKTtcblxuICBjb25zdCBmZXRjaE1hcmtldCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1hcmtldEFkZHJlc3MpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IG1hcmtldENvbnRyYWN0ID0gZ2V0TWFya2V0Q29udHJhY3QobWFya2V0QWRkcmVzcywgcHJvdmlkZXIpO1xuXG4gICAgICBjb25zdCBbY3VycmVudFByaWNlLCBsb2NrUHJpY2UsIHN0YXRlLCB0b3RhbFllcywgdG90YWxObywgZmVlZElkXSA9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC5nZXRDdXJyZW50UHJpY2UoKSxcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC5sb2NrUHJpY2UoKSxcbiAgICAgICAgICBtYXJrZXRDb250cmFjdC5zdGF0ZSgpLFxuICAgICAgICAgIG1hcmtldENvbnRyYWN0LnRvdGFsWWVzKCksXG4gICAgICAgICAgbWFya2V0Q29udHJhY3QudG90YWxObygpLFxuICAgICAgICAgIG1hcmtldENvbnRyYWN0LmZlZWRJZCgpLFxuICAgICAgICBdKTtcblxuICAgICAgY29uc3QgZmVlZElkU3RyID0gZXRoZXJzLnRvVXRmOFN0cmluZyhmZWVkSWQpLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcblxuICAgICAgc2V0TWFya2V0KHtcbiAgICAgICAgYWRkcmVzczogbWFya2V0QWRkcmVzcyxcbiAgICAgICAgZmVlZElkOiBmZWVkSWRTdHIgfHwgZXRoZXJzLmhleGxpZnkoZmVlZElkKSxcbiAgICAgICAgY3VycmVudFByaWNlOiBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudFByaWNlKSxcbiAgICAgICAgbG9ja1ByaWNlOiBldGhlcnMuZm9ybWF0RXRoZXIobG9ja1ByaWNlKSxcbiAgICAgICAgc3RhdGU6IE51bWJlcihzdGF0ZSkgYXMgTWFya2V0U3RhdGUsXG4gICAgICAgIHRvdGFsWWVzOiBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxZZXMpLFxuICAgICAgICB0b3RhbE5vOiBldGhlcnMuZm9ybWF0RXRoZXIodG90YWxObyksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXQ6XCIsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBtYXJrZXRcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBtYXJrZXQsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoOiBmZXRjaE1hcmtldCB9O1xufVxuXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsImV0aGVycyIsImF4aW9zIiwiZ2V0RmFjdG9yeUNvbnRyYWN0IiwiZ2V0TWFya2V0Q29udHJhY3QiLCJnZXRQcm92aWRlciIsIk1hcmtldFN0YXRlIiwiY2FsY3VsYXRlVHJlbmRpbmdTY29yZSIsIm1hcmtldCIsInRvdGFsWWVzIiwicGFyc2VGbG9hdCIsInRvdGFsTm8iLCJ0b3RhbExpcXVpZGl0eSIsInNjb3JlIiwic3RhdGUiLCJBY3RpdmUiLCJiYWxhbmNlIiwiTWF0aCIsIm1pbiIsIm1heCIsInVzZU1hcmtldHMiLCJtYXJrZXRzIiwic2V0TWFya2V0cyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoTWFya2V0cyIsInByb3ZpZGVyIiwiZmFjdG9yeSIsIm1hcmtldEFkZHJlc3NlcyIsImdldE1hcmtldHMiLCJiYWNrZW5kTWFya2V0cyIsImFwaVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwicmVzcG9uc2UiLCJnZXQiLCJkYXRhIiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJiYWNrZW5kTWFwQnlBZGRyZXNzIiwiTWFwIiwiYmFja2VuZE1hcEJ5RmVlZElkIiwiZm9yRWFjaCIsIm0iLCJtYXJrZXRfYWRkcmVzcyIsImFkZHJMb3dlciIsInRvTG93ZXJDYXNlIiwic2V0IiwiZmVlZF9pZCIsImZlZWRJZExvd2VyIiwic3RhcnRzV2l0aCIsInNsaWNlIiwibWFya2V0UHJvbWlzZXMiLCJtYXAiLCJhZGRyZXNzIiwibWFya2V0Q29udHJhY3QiLCJjdXJyZW50UHJpY2UiLCJsb2NrUHJpY2UiLCJmZWVkSWQiLCJxdWVzdGlvbiIsIlByb21pc2UiLCJhbGwiLCJnZXRDdXJyZW50UHJpY2UiLCJjYXRjaCIsImZlZWRJZFN0ciIsInRvVXRmOFN0cmluZyIsInJlcGxhY2UiLCJmZWVkSWRIZXgiLCJoZXhsaWZ5IiwiYWRkcmVzc0xvd2VyIiwiYmFja2VuZE1hcmtldCIsImZlZWRJZE5vUHJlZml4IiwibWFya2V0RGF0YSIsImZvcm1hdEV0aGVyIiwiTnVtYmVyIiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsImltYWdlVXJsIiwiaW1hZ2VfdXJsIiwibWFya2V0c1dpdGhUcmVuZGluZyIsInRyZW5kaW5nU2NvcmUiLCJtZXNzYWdlIiwicmVmZXRjaCIsInVzZU1hcmtldCIsIm1hcmtldEFkZHJlc3MiLCJzZXRNYXJrZXQiLCJmZXRjaE1hcmtldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useMarkets.ts\n"));

/***/ })

});